<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DroneScout V13.0 - Smart Spot Discovery</title>
    <!-- Build: 2025-10-31-23:50 UTC - FORCE RELOAD -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- V6 Fix: Proper Leaflet loading on ALL devices (no conditional loading) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <!-- V6.1: Updated to latest Chart.js version -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a2a6c 0%, #0f1b4d 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            background: #f5f7fa;
            min-height: 100vh;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 2px solid #e0e6ed;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            min-width: fit-content;
        }

        .nav-tab.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
        }

        .content {
            padding: 20px;
            padding-bottom: 80px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .preferences-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .preferences-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .preferences-title {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }
        .preferences-toggle {
            background: none;
            border: none;
            color: #00d4ff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .slider-label {
            font-size: 13px;
            font-weight: 600;
            color: #666;
        }
        .slider-label.active {
            color: #00d4ff;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e6ed;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .x10-badge {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .x10-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .x10-features {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .feature-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
        }

        .spot-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .spot-card:active {
            transform: scale(0.98);
        }

        .spot-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        /* Skeleton loading states */
        .skeleton-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
        }

        .skeleton-image {
            width: 100%;
            height: 180px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-content {
            padding: 15px;
        }

        .skeleton-title {
            height: 20px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 10px;
            width: 70%;
        }

        .skeleton-text {
            height: 14px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
            width: 90%;
        }

        .skeleton-badge {
            height: 24px;
            width: 80px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 12px;
            display: inline-block;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }

        .risk-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        .risk-badge.high {
            background: rgba(39, 174, 96, 0.9);
            color: white;
        }

        .risk-badge.medium {
            background: rgba(255, 193, 7, 0.9);
            color: white;
        }

        .risk-badge.low {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        /* Compact weather card - horizontal layout */
        .weather-card {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 10px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 13px;
        }

        .weather-compact {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .weather-temp-icon {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            color: #1e3c72;
        }

        .weather-temp-icon .temp {
            font-size: 18px;
        }

        .weather-temp-icon .icon {
            font-size: 20px;
        }

        .weather-details {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #666;
        }

        .weather-detail-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .flying-status {
            padding: 6px 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            font-size: 12px;
            display: inline-block;
        }

        .status-good {
            background: #d1f4e0;
            color: #1d7a3c;
        }

        .status-caution {
            background: #fff3cd;
            color: #856404;
        }

        .status-bad {
            background: #f8d7da;
            color: #721c24;
        }

        .warnings {
            margin-top: 8px;
            padding: 8px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            border-radius: 4px;
        }

        .warning-item {
            font-size: 11px;
            color: #856404;
            margin: 3px 0;
            display: flex;
            align-items: flex-start;
            gap: 4px;
            line-height: 1.3;
        }

        /* Photo source badge */
        .photo-source-badge {
            position: absolute;
            top: 12px;
            right: 50px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .photo-source-badge.streetview {
            background: rgba(66, 133, 244, 0.9);
            color: white;
        }

        .photo-source-badge.stock {
            background: rgba(128, 128, 128, 0.8);
            color: white;
        }

        .favorite-star {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s;
            backdrop-filter: blur(10px);
        }

        .favorite-star.active {
            color: #ffc107;
        }

        .spot-info {
            padding: 15px;
        }

        .spot-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 8px;
        }

        .spot-desc {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .spot-distance {
            font-size: 13px;
            color: #00d4ff;
            font-weight: 600;
        }

        .map-container {
            width: 100%;
            height: 400px;
            min-height: 400px;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            background: #e0e6ed;
        }

        .risk-category {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .risk-cat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .risk-cat-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .risk-cat-score {
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-medium {
            background: #fff3cd;
            color: #856404;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        .risk-cat-bar {
            width: 100%;
            height: 6px;
            background: #e0e6ed;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .risk-cat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            transition: width 0.3s;
        }

        .risk-cat-desc {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .flight-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e0e6ed;
        }

        .flight-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .flight-location {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }

        .flight-date {
            font-size: 13px;
            color: #666;
        }

        .flight-details {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
        }

        .flight-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge-synced {
            background: #e8f5e9;
            color: #1b5e20;
        }

        .badge-manual {
            background: #e7f3ff;
            color: #0056b3;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 6px;
        }

        .badge.rated {
            background: #d4edda;
            color: #155724;
        }

        .badge.pending {
            background: #fff3cd;
            color: #856404;
        }

        .btn-small {
            flex: 1;
            padding: 8px;
            background: #00d4ff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-small.secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn-small.danger {
            background: #dc3545;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 16px;
            color: #666;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        .status-indicator.checking {
            background: #ffc107;
        }

        .status-text {
            flex: 1;
            font-size: 13px;
            color: #666;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section-title {
            font-size: 14px;
            font-weight: 700;
            color: #1e3c72;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e6ed;
        }

        .advanced-toggle {
            background: white;
            border: 2px solid #e0e6ed;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .advanced-toggle:hover {
            border-color: #00d4ff;
        }

        .advanced-toggle.open {
            background: #f0f5fa;
            border-color: #00d4ff;
        }

        .advanced-content {
            display: none;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #00d4ff;
        }

        .advanced-content.open {
            display: block;
        }

        /* V10.0: Profile UI styles */
        .profile-subsection {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e6ed;
        }

        .profile-subsection:last-child {
            border-bottom: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .waiver-item,
        .drone-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e0e6ed;
            margin-bottom: 10px;
        }

        .waiver-item:last-child,
        .drone-item:last-child {
            margin-bottom: 0;
        }

        .sync-info {
            font-size: 13px;
            color: #666;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            border-left: 4px solid #00d4ff;
            margin: 10px 0;
        }

        .chart-container {
            width: 100%;
            height: 250px;
            margin-bottom: 20px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .help-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 12px;
        }

        .help-section p {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            list-style: none;
            padding: 0;
        }

        .help-section li {
            font-size: 14px;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            position: relative;
        }

        .help-section li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #00d4ff;
            font-weight: 700;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .star-rating {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .star {
            font-size: 32px;
            color: #e0e6ed;
            cursor: pointer;
            transition: all 0.2s;
        }

        .star.active {
            color: #ffc107;
        }

        .star:hover {
            transform: scale(1.1);
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #00d4ff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sync-message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
            font-weight: 600;
        }

        .sync-message.success {
            background: #d4edda;
            color: #155724;
        }

        .sync-message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .back-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            margin-bottom: 10px;
        }

        .toggle-favorites-btn {
            background: white;
            border: 2px solid #e0e6ed;
            color: #666;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-favorites-btn.active {
            background: #ffc107;
            color: white;
            border-color: #ffc107;
        }

        .export-btn {
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üöÅ DroneScout V12.0</h1>
            <p>Plan ‚Ä¢ Discover ‚Ä¢ Map ‚Ä¢ Assess ‚Ä¢ Fly ‚Ä¢ Sync ‚Ä¢ Analyze</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="planner">Trip Planner</button>
            <button class="nav-tab" data-tab="upcoming">Upcoming</button>
            <button class="nav-tab" data-tab="history">History</button>
            <button class="nav-tab" data-tab="settings">Settings</button>
            <button class="nav-tab" data-tab="analytics">Analytics</button>
            <button class="nav-tab" data-tab="help">Help</button>
        </div>

        <div class="content" id="content">
            <!-- Content will be dynamically rendered -->
        </div>
    </div>

    <!-- Rating Modal -->
    <div class="modal" id="ratingModal">
        <div class="modal-content">
            <div class="modal-header">Rate Your Flight</div>
            <div id="ratingContent"></div>
        </div>
    </div>

    <!-- Save Flight Plan Modal -->
    <div class="modal" id="savePlanModal">
        <div class="modal-content">
            <div class="modal-header">Save Flight Plan</div>
            <div id="savePlanContent"></div>
        </div>
    </div>

    <script>
        // Initialize app
        document.addEventListener('DOMContentLoaded', initializeApp);

        function initializeApp() {
            // App state
            const state = {
                currentTab: 'planner',
                selectedSpot: null,
                destination: '',
                plannerMode: 'auto',
                routeStart: '',
                routeEnd: '',
                spots: [],
                upcomingFlights: loadFromStorage('upcomingFlights') || [],
                flights: loadFromStorage('flights') || [],
                ratings: loadFromStorage('ratings') || [],
                // V10.0: Preferences always default to 50-50 (don't persist between sessions)
                preferences: {
                    cityscape: 50,
                    nature: 50,
                    architecture: 50
                },
                // V10: User profile for intelligent recommendations
                userProfile: loadFromStorage('userProfile') || {
                    certifications: {
                        part107: false,
                        part107Expiry: null,
                        trust: false
                    },
                    waivers: [],
                    drones: [],
                    preferences: {
                        searchRadius_mi: 15,
                        maxDriveTime_min: 20,
                        experience: 'intermediate',
                        avoidCrowds: true
                    }
                },
                favorites: loadFromStorage('favorites') || [],
                showFavoritesOnly: false,
                showPreferences: false,
                currentRating: null,
                syncSettings: loadFromStorage('syncSettings') || {
                    workerUrl: 'https://dronescout-proxy.dronescout-api.workers.dev',
                    lastSync: null,
                    connectionStatus: 'checking'
                },
                syncMessage: null,
                expandedFlight: null,
                // V6: Map state
                map: null,
                mapMarkers: [],
                destinationCoords: null,
                userLocation: null,
                // V6.1: Route mode state
                routeStartCoords: null,
                routeEndCoords: null,
                routePolyline: null,
                // V9: Spot search center for preference ranking
                searchCenter: null,
                // V9.1: Loading state for spots
                loadingSpots: false
            };

            // LocalStorage helpers
            function loadFromStorage(key) {
                try {
                    const data = localStorage.getItem('dronescout_' + key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    return null;
                }
            }

            function saveToStorage(key, value) {
                try {
                    localStorage.setItem('dronescout_' + key, JSON.stringify(value));
                } catch (e) {
                    console.error('Storage error:', e);
                }
            }

            // Demo data with full v2 features
            const scenicSpots = [
                {
                    id: 1,
                    name: "Constitution Trail Overlook",
                    description: "Scenic trail with open fields and tree lines. Great for tracking shots and nature content.",
                    coordinates: { lat: 40.4842, lng: -88.9936 },
                    imageUrl: "https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80",
                    flightInstructions: "Launch from north parking area. Fly heading 180¬∞ (south) along tree line. Maintain 150 ft AGL to capture trail and surrounding farmland. Look east for sunrise golden hour shots.",
                    bestTime: "Golden hour (sunrise/sunset)",
                    x10Advantage: "X10's advanced autonomy excels at tree line tracking. Superior range enables full trail coverage. Nightsense allows twilight flights when trails are empty.",
                    distance: "2.3 mi",
                    riskScore: 88,
                    shotTypes: { landscape: 70, nature: 30, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 4.2 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "Visual line of sight waived (Part 107.31) - BVLOS certified", compliant: true },
                        { authority: "Local Parks", rule: "Drone flights permitted with Part 107 certification", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "8-12 mph SW",
                        visibility: "10+ miles",
                        temp: "72¬∞F",
                        conditions: "Clear"
                    }
                },
                {
                    id: 2,
                    name: "Downtown Skyline - Miller Park",
                    description: "Urban skyline shots with historic buildings and modern architecture blend.",
                    coordinates: { lat: 40.4781, lng: -88.9937 },
                    imageUrl: "https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80",
                    flightInstructions: "Launch from Miller Park. Fly heading 45¬∞ (northeast) toward downtown. Maintain 300 ft AGL for optimal building perspective.",
                    bestTime: "Blue hour (twilight) for city lights",
                    x10Advantage: "Nightsense capability captures stunning blue hour shots other drones miss. Elite obstacle avoidance navigates urban environment safely.",
                    distance: "3.7 mi",
                    riskScore: 72,
                    shotTypes: { cityscape: 80, architecture: 20, landscape: 0, nature: 0 },
                    airspaceDetails: {
                        class: "Class G with LAANC",
                        ceiling: "Up to 400 ft AGL with authorization",
                        laancRequired: "Yes (auto-approved up to 400 ft)",
                        nearestAirport: "Central Illinois Regional (BMI) - 3.8 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "LAANC authorization obtained", compliant: true },
                        { authority: "City of Bloomington", rule: "Municipal approval for park launches", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "6-10 mph SSW",
                        visibility: "10+ miles",
                        temp: "68¬∞F",
                        conditions: "Partly cloudy"
                    }
                },
                {
                    id: 3,
                    name: "Evergreen Lake Nature Preserve",
                    description: "Natural lake with wildlife and dense tree cover. Excellent for aerial shots of water reflections.",
                    coordinates: { lat: 40.5142, lng: -88.9687 },
                    imageUrl: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80",
                    flightInstructions: "Launch from east parking area. Fly heading 270¬∞ (west) over lake. Maintain 200 ft AGL to capture full lake and fountain.",
                    bestTime: "Early morning for calm water reflections",
                    x10Advantage: "X10 Nightsense unlocks magical twilight/blue hour shots. Advanced obstacle avoidance navigates dense canopy safely.",
                    distance: "5.1 mi",
                    riskScore: 91,
                    shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 6.1 mi S"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "BVLOS operations authorized", compliant: true },
                        { authority: "McLean County", rule: "Preserve permits drone use for photography", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "5-8 mph W",
                        visibility: "10+ miles",
                        temp: "65¬∞F",
                        conditions: "Clear"
                    }
                }
            ];

            // API Keys
            const UNSPLASH_API_KEY = 'PWgTvrIDkfEdi93dvP2knidPZa7z8IbdhnvbZRrBIw4';

            // Google Places API - Get your key at: https://console.cloud.google.com/google/maps-apis/credentials
            // Enable: Places API (New), Maps JavaScript API
            const GOOGLE_PLACES_API_KEY = 'AIzaSyDzWCokRTf0EIwEJ_fCrpLud-F-5JiRfYY';

            // Fetch real images from Unsplash API (location-specific)
            async function fetchUnsplashImage(category, locationName = '', spotName = '') {
                try {
                    // Build specific search query from location name
                    // For "South Main Street, Crystal Lake, McHenry County, Illinois"
                    // Extract: "South Main Street Crystal Lake Illinois"
                    let searchLocation = locationName;

                    if (locationName.includes(',')) {
                        const parts = locationName.split(',').map(p => p.trim());
                        // Use first part (street/place) + second part (city) + last part (state)
                        // Skip middle parts like "McHenry County"
                        if (parts.length >= 3) {
                            searchLocation = `${parts[0]} ${parts[1]} ${parts[parts.length - 1]}`;
                        } else if (parts.length === 2) {
                            searchLocation = `${parts[0]} ${parts[1]}`;
                        } else {
                            searchLocation = parts[0];
                        }
                    }

                    // Map categories to search terms
                    const categoryTerms = {
                        viewpoint: 'aerial view',
                        water: 'waterfront',
                        park: 'park',
                        nature: 'nature',
                        architecture: 'architecture',
                        landmark: 'downtown',
                        landscape: 'aerial'
                    };

                    const categoryTerm = categoryTerms[category] || 'aerial';

                    // Combine location + category for location-specific images
                    // e.g., "South Main Street Crystal Lake Illinois downtown"
                    const query = searchLocation ? `${searchLocation} ${categoryTerm}` : categoryTerm;

                    const url = `https://api.unsplash.com/photos/random?query=${encodeURIComponent(query)}&orientation=landscape`;

                    console.log(`üîç Unsplash search: "${query}"`);

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Client-ID ${UNSPLASH_API_KEY}`
                        }
                    });

                    if (!response.ok) {
                        console.warn('Unsplash API error, using fallback image');
                        return getFallbackImage(category);
                    }

                    const data = await response.json();
                    return data.urls.regular || data.urls.small;
                } catch (error) {
                    console.error('Unsplash fetch error:', error);
                    return getFallbackImage(category);
                }
            }

            // Fallback images if Unsplash fails
            function getFallbackImage(category) {
                const fallbackImages = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return fallbackImages[category] || fallbackImages.landscape;
            }

            // Google Street View API functions (via Cloudflare Worker proxy)
            /**
             * Fetch a Street View image for a location
             * Falls back to Unsplash if no Street View available
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @param {string} category - Image category for Unsplash fallback
             * @param {string} locationName - Location name for Unsplash fallback
             * @returns {Promise<{imageUrl: string, source: string, metadata: object}>}
             */
            async function fetchLocationImage(lat, lon, category = 'landscape', locationName = '') {
                try {
                    // Get worker URL from settings
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('Worker URL not configured, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }

                    // Try Google Street View first
                    const streetViewUrl = `${workerUrl}/api/streetview/image?lat=${lat}&lon=${lon}&size=600x400`;
                    const response = await fetch(streetViewUrl);

                    if (!response.ok) {
                        console.warn('Street View API error, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }

                    const data = await response.json();

                    if (data.success && data.hasStreetView) {
                        console.log('Using Street View image');
                        return {
                            imageUrl: data.imageUrl,
                            source: 'streetview',
                            metadata: data.metadata || {}
                        };
                    } else {
                        // No Street View available, fall back to Unsplash
                        console.log('No Street View available, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }
                } catch (error) {
                    console.error('fetchLocationImage error:', error);
                    const imageUrl = await fetchUnsplashImage(category, locationName);
                    return {
                        imageUrl,
                        source: 'unsplash',
                        metadata: {}
                    };
                }
            }

            /**
             * Check if Street View is available at a location
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @returns {Promise<{hasStreetView: boolean, metadata: object}>}
             */
            async function checkStreetViewAvailability(lat, lon) {
                try {
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        return { hasStreetView: false, metadata: {} };
                    }

                    const metadataUrl = `${workerUrl}/api/streetview/metadata?lat=${lat}&lon=${lon}`;
                    const response = await fetch(metadataUrl);

                    if (!response.ok) {
                        return { hasStreetView: false, metadata: {} };
                    }

                    const data = await response.json();
                    return {
                        hasStreetView: data.hasStreetView || false,
                        metadata: data.location ? {
                            location: data.location,
                            date: data.date,
                            copyright: data.copyright
                        } : {}
                    };
                } catch (error) {
                    console.error('checkStreetViewAvailability error:', error);
                    return { hasStreetView: false, metadata: {} };
                }
            }

            // OpenWeather API functions (via Cloudflare Worker proxy)
            /**
             * Fetch current weather at a location
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @param {string} units - 'imperial' or 'metric'
             * @returns {Promise<{weather: object, error: string}>}
             */
            async function fetchCurrentWeather(lat, lon, units = 'imperial') {
                try {
                    // Check cache first (15 minute TTL)
                    const cacheKey = `weather_${lat.toFixed(4)}_${lon.toFixed(4)}_${units}`;
                    const cached = localStorage.getItem(cacheKey);

                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        const age = Date.now() - timestamp;
                        const TTL = 15 * 60 * 1000; // 15 minutes in milliseconds

                        if (age < TTL) {
                            console.log(`Weather cache hit (${Math.floor(age / 1000)}s old)`);
                            return data;
                        } else {
                            console.log('Weather cache expired, fetching fresh data');
                            localStorage.removeItem(cacheKey);
                        }
                    }

                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('Worker URL not configured, weather unavailable');
                        return { weather: null, error: 'Worker URL not configured' };
                    }

                    const weatherUrl = `${workerUrl}/api/weather/current?lat=${lat}&lon=${lon}&units=${units}`;
                    const response = await fetch(weatherUrl);

                    if (!response.ok) {
                        console.warn('Weather API error');
                        return { weather: null, error: 'Weather API error' };
                    }

                    const apiData = await response.json();

                    if (apiData.success && apiData.weather) {
                        console.log('Weather data fetched successfully');
                        const result = {
                            weather: apiData.weather,
                            error: null
                        };

                        // Cache the result
                        try {
                            localStorage.setItem(cacheKey, JSON.stringify({
                                data: result,
                                timestamp: Date.now()
                            }));
                        } catch (e) {
                            console.warn('Failed to cache weather data:', e);
                        }

                        return result;
                    } else {
                        return {
                            weather: null,
                            error: apiData.error || 'Unknown weather error'
                        };
                    }
                } catch (error) {
                    console.error('fetchCurrentWeather error:', error);
                    return {
                        weather: null,
                        error: error.message
                    };
                }
            }

            /**
             * Format weather data for display
             * @param {object} weather - Weather object from fetchCurrentWeather
             * @returns {string} Formatted weather string
             */
            function formatWeatherDisplay(weather) {
                if (!weather) return 'Weather unavailable';

                const { temp, tempUnit, conditions, windSpeed, windSpeedUnit, visibility, visibilityUnit } = weather;
                return `${temp}${tempUnit}, ${conditions}, Wind ${windSpeed}${windSpeedUnit}, Vis ${visibility}${visibilityUnit}`;
            }

            /**
             * TESTING ONLY: Simulate bad weather conditions
             * Uncomment the return statement to test bad weather display
             * @param {object} weather - Real weather object
             * @returns {object} Modified weather with bad conditions
             */
            function simulateBadWeather(weather) {
                // UNCOMMENT THIS RETURN TO TEST BAD WEATHER:
                /*
                return {
                    temp: 28,
                    tempUnit: '¬∞F',
                    conditions: 'Rain',
                    windSpeed: 32,
                    windSpeedUnit: 'mph',
                    visibility: 2.1,
                    visibilityUnit: 'mi',
                    humidity: 95,
                    flyingConditions: {
                        safe: false,
                        risk: 'high',
                        riskColor: 'red',
                        warnings: [
                            'High wind speeds - unsafe for most drones',
                            'Low visibility - may not meet FAA VLOS requirements',
                            'Precipitation detected - risk of moisture damage',
                            'Below freezing - reduced battery performance'
                        ],
                        recommendation: 'Do not fly - unsafe conditions'
                    }
                };
                */
                return weather; // Return real weather (normal operation)
            }

            /**
             * Get weather icon emoji based on conditions
             * @param {string} conditions - Weather condition string
             * @returns {string} Weather emoji
             */
            function getWeatherIcon(conditions) {
                const icons = {
                    'Clear': '‚òÄÔ∏è',
                    'Clouds': '‚òÅÔ∏è',
                    'Rain': 'üåßÔ∏è',
                    'Snow': '‚ùÑÔ∏è',
                    'Drizzle': 'üå¶Ô∏è',
                    'Thunderstorm': '‚õàÔ∏è',
                    'Mist': 'üå´Ô∏è',
                    'Fog': 'üå´Ô∏è',
                    'Haze': 'üå´Ô∏è'
                };
                return icons[conditions] || 'üå§Ô∏è';
            }

            /**
             * Render compact weather card with flying conditions
             * @param {object} weather - Weather object from API
             * @returns {string} HTML for compact weather card
             */
            function renderWeatherCard(weather) {
                if (!weather || !weather.flyingConditions) {
                    return '<div style="text-align: center; color: #999; font-size: 12px; padding: 8px; margin-top: 12px;">Weather unavailable</div>';
                }

                // Apply bad weather simulation if enabled (for testing)
                const w = simulateBadWeather(weather);
                const statusClass = w.flyingConditions.risk === 'low' ? 'status-good'
                                  : w.flyingConditions.risk === 'medium' ? 'status-caution'
                                  : 'status-bad';

                const warnings = w.flyingConditions.warnings && w.flyingConditions.warnings.length > 0
                    ? `<div class="warnings">${w.flyingConditions.warnings.map(warn => `<div class="warning-item">‚ö†Ô∏è ${warn}</div>`).join('')}</div>`
                    : '';

                return `
                    <div class="weather-card">
                        <div class="weather-compact">
                            <div class="weather-temp-icon">
                                <span class="icon">${getWeatherIcon(w.conditions)}</span>
                                <span class="temp">${w.temp}${w.tempUnit}</span>
                            </div>
                            <div class="weather-details">
                                <div class="weather-detail-item">üí® ${w.windSpeed}${w.windSpeedUnit}</div>
                                <div class="weather-detail-item">üëÅÔ∏è ${w.visibility}${w.visibilityUnit}</div>
                            </div>
                        </div>
                        <div class="flying-status ${statusClass}">
                            ${w.flyingConditions.recommendation}
                        </div>
                        ${warnings}
                    </div>
                `;
            }

            // Nominatim Geocoding API functions
            async function geocodeLocation(locationQuery) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(locationQuery)}&format=json&limit=1`,
                        {
                            headers: {
                                'User-Agent': 'DroneScout/5.3 (Flight Planning App)'
                            }
                        }
                    );

                    if (!response.ok) throw new Error('Geocoding failed');

                    const results = await response.json();
                    if (results.length === 0) return null;

                    return {
                        lat: parseFloat(results[0].lat),
                        lng: parseFloat(results[0].lon),
                        displayName: results[0].display_name
                    };
                } catch (error) {
                    console.error('Geocoding error:', error);
                    return null;
                }
            }

            // ========================================
            // V10.0: GOOGLE PLACES API INTEGRATION
            // ========================================

            /**
             * V10.0: Search for scenic locations using Google Places via Cloudflare Worker
             * Returns verified locations with real names, photos, and ratings
             * Searches ALL types: urban, nature, architecture, water, landmarks, etc.
             */
            async function searchGooglePlaces(lat, lng, radiusMeters, locationName = '') {
                try {
                    console.log(`üîç Google Places search via worker: ${radiusMeters}m radius from [${lat.toFixed(4)}, ${lng.toFixed(4)}]`);

                    // Check if worker URL is configured
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('‚ö†Ô∏è Worker URL not configured. Using OSM fallback.');
                        return { success: false, error: 'Worker URL not configured' };
                    }

                    // Call Cloudflare Worker endpoint (no CORS issues!)
                    const url = `${workerUrl}/api/places/nearbysearch?lat=${lat}&lon=${lng}&radius=${radiusMeters}`;

                    console.log(`üì° Fetching from worker: ${url}`);

                    const response = await fetch(url);

                    if (!response.ok) {
                        console.error('Worker API error:', response.status);
                        return { success: false, error: `Worker error: ${response.status}` };
                    }

                    const data = await response.json();

                    if (!data.success || !data.results || data.results.length === 0) {
                        console.warn('No Google Places found in this area');
                        return { success: false, error: data.error || 'No places found' };
                    }

                    console.log(`‚úÖ Found ${data.count} unique Google Places (from ${data.totalRawResults} raw results)`);
                    console.log(`üìã Search types: ${data.searchTypes?.join(', ')}`);

                    // Filter and process places
                    const processedSpots = await processGooglePlaces(
                        data.results,
                        lat,
                        lng,
                        locationName
                    );

                    return {
                        success: true,
                        spots: processedSpots,
                        count: processedSpots.length
                    };

                } catch (error) {
                    console.error('‚ùå Google Places search error:', error);
                    return { success: false, error: error.message };
                }
            }

            /**
             * Fetch photo from Google Places Photos API via worker
             */
            async function fetchGooglePlacesPhoto(photoReference, maxWidth = 800) {
                try {
                    if (!photoReference) {
                        return null;
                    }

                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('Worker URL not configured for photo fetch');
                        return null;
                    }

                    // Get photo URL from worker (worker handles API key)
                    const response = await fetch(`${workerUrl}/api/places/photo?photo_reference=${photoReference}&maxwidth=${maxWidth}`);

                    if (!response.ok) {
                        console.error('Photo fetch error:', response.status);
                        return null;
                    }

                    const data = await response.json();
                    return data.photoUrl || null;

                } catch (error) {
                    console.error('Google Places photo error:', error);
                    return null;
                }
            }

            /**
             * Get additional place details including photos
             */
            async function getGooglePlaceDetails(placeId) {
                try {
                    const url = `https://maps.googleapis.com/maps/api/place/details/json?` +
                                `place_id=${placeId}&` +
                                `fields=name,geometry,photos,rating,types,formatted_address,opening_hours,website&` +
                                `key=${GOOGLE_PLACES_API_KEY}`;

                    const response = await fetch(url);
                    if (!response.ok) return null;

                    const data = await response.json();
                    return data.result;

                } catch (error) {
                    console.error('Place details error:', error);
                    return null;
                }
            }

            /**
             * Process Google Places results into DroneScout spot format
             */
            async function processGooglePlaces(places, centerLat, centerLng, locationName = '') {
                const spots = [];

                // Limit to first 15 spots
                const limitedPlaces = places.slice(0, 15);

                for (let index = 0; index < limitedPlaces.length; index++) {
                    const place = limitedPlaces[index];

                    try {
                        const placeLat = place.geometry.location.lat;
                        const placeLng = place.geometry.location.lng;

                        // Calculate distance
                        const distance = calculateDistance(centerLat, centerLng, placeLat, placeLng);

                        // Determine spot type from Google Place types
                        const spotType = determineSpotTypeFromGooglePlace(place);

                        // Get photo (use first photo if available)
                        let imageUrl = null;
                        let imageSource = 'placeholder';

                        if (place.photos && place.photos.length > 0) {
                            // Use Google Places photo
                            imageUrl = await fetchGooglePlacesPhoto(place.photos[0].photo_reference);
                            imageSource = 'google_places';
                            console.log(`üì∏ Using Google Places photo for: ${place.name}`);
                        }

                        // Fallback to Street View or Unsplash if no Google photo
                        if (!imageUrl) {
                            console.log(`üîÑ No Google photo for ${place.name}, trying Street View/Unsplash`);
                            const fallbackImage = await fetchLocationImage(
                                placeLat,
                                placeLng,
                                spotType.category,
                                place.name
                            );
                            imageUrl = fallbackImage.imageUrl;
                            imageSource = fallbackImage.source;
                        }

                        // Fetch weather and obstacles in parallel
                        const [weatherData, obstacleData] = await Promise.all([
                            fetchCurrentWeather(placeLat, placeLng, 'imperial'),
                            detectObstacles(placeLat, placeLng, 500).catch(() => ({ count: 0, types: [], risk: 'low' }))
                        ]);

                        // Build spot object
                        spots.push({
                            id: place.place_id,
                            name: place.name,
                            description: generateDescriptionFromGooglePlace(place, locationName),
                            coordinates: { lat: placeLat, lng: placeLng },
                            imageUrl: imageUrl,
                            imageSource: imageSource,
                            imageMetadata: {
                                googlePlaceId: place.place_id,
                                rating: place.rating,
                                userRatingsTotal: place.user_ratings_total
                            },
                            flightInstructions: generateFlightInstructions(spotType, {
                                name: place.name,
                                types: place.types
                            }),
                            bestTime: spotType.bestTime,
                            x10Advantage: "X10's advanced autonomy and Nightsense capability enable safe navigation and stunning shots in varied lighting conditions.",
                            distance: `${distance.toFixed(1)} mi`,
                            riskScore: calculateRiskScoreFromGooglePlace(place, obstacleData),
                            shotTypes: spotType.shotTypes,
                            airspaceDetails: {
                                class: "Class G (Uncontrolled)",
                                ceiling: "Up to 400 ft AGL authorized",
                                laancRequired: "Check local requirements",
                                nearestAirport: "Verify on SkyVector/B4UFLY"
                            },
                            regulations: [
                                { authority: "FAA Part 107", rule: "Visual line of sight required (unless BVLOS waiver)", compliant: true },
                                { authority: "Local Authority", rule: "Verify local drone regulations before flight", compliant: true }
                            ],
                            weather: weatherData.weather,
                            weatherError: weatherData.error,
                            weatherConditions: weatherData.weather ? {
                                wind: `${weatherData.weather.windSpeed} ${weatherData.weather.windSpeedUnit}`,
                                visibility: `${weatherData.weather.visibility} ${weatherData.weather.visibilityUnit}`,
                                temp: `${weatherData.weather.temp}${weatherData.weather.tempUnit}`,
                                conditions: weatherData.weather.conditions
                            } : {
                                wind: "Check current conditions",
                                visibility: "Check current conditions",
                                temp: "Check current conditions",
                                conditions: "Verify before flight"
                            },
                            intelligence: {
                                obstacles: obstacleData,
                                access: { status: 'public', score: 15 }, // Google Places are typically public
                                populationDensity: estimatePopulationDensity(locationName, { types: place.types }),
                                cellCoverage: 'good', // Assume good coverage for popular places
                                googleRating: place.rating,
                                googleReviews: place.user_ratings_total
                            }
                        });

                    } catch (error) {
                        console.error(`Error processing place ${place.name}:`, error);
                    }
                }

                // Sort by distance
                return spots.sort((a, b) => {
                    const distA = parseFloat(a.distance);
                    const distB = parseFloat(b.distance);
                    return distA - distB;
                });
            }

            /**
             * Determine spot type from Google Place types
             */
            function determineSpotTypeFromGooglePlace(place) {
                const types = place.types || [];
                const name = (place.name || '').toLowerCase();

                // Check for water/beach
                if (types.includes('beach') || types.includes('lake') || name.includes('beach') || name.includes('lake')) {
                    return {
                        category: 'water',
                        name: 'Water Feature',
                        bestTime: 'Early morning for calm water',
                        shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 }
                    };
                }

                // Check for parks
                if (types.includes('park') || types.includes('campground')) {
                    return {
                        category: 'park',
                        name: 'Park',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 50, landscape: 30, cityscape: 20, architecture: 0 }
                    };
                }

                // Check for natural features
                if (types.includes('natural_feature') || name.includes('mountain') || name.includes('hill')) {
                    return {
                        category: 'viewpoint',
                        name: 'Viewpoint',
                        bestTime: 'Golden hour (sunrise/sunset)',
                        shotTypes: { landscape: 80, nature: 20, cityscape: 0, architecture: 0 }
                    };
                }

                // Default to tourist attraction
                return {
                    category: 'landmark',
                    name: 'Landmark',
                    bestTime: 'Golden hour or blue hour',
                    shotTypes: { architecture: 40, cityscape: 30, landscape: 20, nature: 10 }
                };
            }

            /**
             * Generate description from Google Place data
             */
            function generateDescriptionFromGooglePlace(place, locationName = '') {
                const parts = [];

                // Use Google's name (it's verified and accurate)
                parts.push(place.name);

                // Add rating if available
                if (place.rating && place.user_ratings_total) {
                    parts.push(`${place.rating}‚òÖ (${place.user_ratings_total} reviews)`);
                }

                // Add types
                if (place.types && place.types.length > 0) {
                    const readableTypes = place.types
                        .filter(t => !t.includes('point_of_interest') && !t.includes('establishment'))
                        .map(t => t.replace(/_/g, ' '))
                        .slice(0, 2);
                    if (readableTypes.length > 0) {
                        parts.push(readableTypes.join(', '));
                    }
                }

                return parts.join(' ‚Ä¢ ');
            }

            /**
             * Calculate risk score from Google Place
             */
            function calculateRiskScoreFromGooglePlace(place, obstacleData) {
                let risk = 'low';

                // Check obstacles
                if (obstacleData.count > 5) {
                    risk = 'high';
                } else if (obstacleData.count > 2) {
                    risk = 'medium';
                }

                // Popular places with lots of people
                if (place.user_ratings_total > 1000) {
                    risk = 'medium'; // Potentially crowded
                }

                return risk;
            }

            /**
             * V10.1: Unified search function - Foursquare Places Discovery (PRIMARY), then fallbacks
             * Comprehensive location discovery across urban, suburban, rural - everything in between!
             */
            async function searchForDroneSpots(lat, lng, radiusKm = null, locationName = '') {
                try {
                    // Use user profile radius if not specified
                    if (!radiusKm) {
                        radiusKm = state.userProfile.preferences.searchRadius_mi * 1.60934; // Convert miles to km
                    }

                    console.log(`üöÅ Searching for drone spots: ${radiusKm.toFixed(1)}km (${(radiusKm * 0.621371).toFixed(1)} mi) radius`);

                    // V13.0: Check airspace classification and aircraft (runs in parallel with spot search)
                    const airspacePromise = checkAirspace(lat, lng, radiusKm);
                    const faaAirspacePromise = checkFAAAirspace(lat, lng);

                    // PRIMARY METHOD: Foursquare Places Discovery
                    // Find ALL types of photo-worthy locations: urban, suburban, rural, nature
                    const [foursquareResult, aircraftData, faaData] = await Promise.all([
                        searchFoursquarePlaces(lat, lng, radiusKm, locationName),
                        airspacePromise,
                        faaAirspacePromise
                    ]);

                    if (foursquareResult.success && foursquareResult.spots.length > 0) {
                        console.log(`‚úÖ Using ${foursquareResult.count} places from Foursquare`);

                        // V13.0: Add both aircraft and FAA airspace data to spots
                        foursquareResult.spots.forEach(spot => {
                            // V12.0: Aircraft proximity status
                            if (aircraftData && aircraftData.success) {
                                spot.airspace = determineAirspaceStatus(
                                    spot.coordinates.lat,
                                    spot.coordinates.lng,
                                    aircraftData
                                );
                            }

                            // V13.0: FAA airspace classification
                            if (faaData && faaData.success && faaData.airspace) {
                                spot.faaAirspace = faaData.airspace;
                            }

                            // V13.0: Calculate overall flight status (aircraft + FAA airspace)
                            spot.overallStatus = determineOverallFlightStatus(spot.airspace, spot.faaAirspace);
                        });

                        return foursquareResult.spots;
                    }

                    // Fallback to OpenStreetMap if Foursquare fails
                    console.log('‚ö†Ô∏è Foursquare places unavailable. Trying OpenStreetMap...');
                    const osmSpots = await searchPOIsNearLocation(lat, lng, radiusKm, locationName);

                    if (osmSpots && osmSpots.length > 0) {
                        console.log(`‚úÖ Using ${osmSpots.length} spots from OpenStreetMap`);

                        // V13.0: Add both aircraft and FAA airspace data to OSM spots
                        const aircraftData = await airspacePromise;
                        const faaData = await faaAirspacePromise;

                        osmSpots.forEach(spot => {
                            // V12.0: Aircraft proximity
                            if (aircraftData && aircraftData.success) {
                                spot.airspace = determineAirspaceStatus(
                                    spot.coordinates.lat,
                                    spot.coordinates.lng,
                                    aircraftData
                                );
                            }

                            // V13.0: FAA airspace classification
                            if (faaData && faaData.success && faaData.airspace) {
                                spot.faaAirspace = faaData.airspace;
                            }

                            // V13.0: Calculate overall flight status (aircraft + FAA airspace)
                            spot.overallStatus = determineOverallFlightStatus(spot.airspace, spot.faaAirspace);
                        });

                        return osmSpots;
                    }

                    console.warn('‚ùå No spots found from any source');
                    return [];

                } catch (error) {
                    console.error('Search error:', error);
                    return [];
                }
            }

            /**
             * V13.0: Check FAA airspace classification
             * Returns official FAA airspace class and LAANC requirements
             */
            async function checkFAAAirspace(lat, lng) {
                try {
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('‚ö†Ô∏è Worker URL not configured for airspace classification');
                        return { success: false, airspace: null };
                    }

                    const url = `${workerUrl}/api/airspace/classification?lat=${lat}&lon=${lng}`;

                    console.log(`üèõÔ∏è Checking FAA airspace classification...`);

                    const response = await fetch(url);

                    if (!response.ok) {
                        console.warn('FAA Airspace API error:', response.status);
                        return { success: false, airspace: null };
                    }

                    const data = await response.json();

                    if (data.success && data.airspace) {
                        const airspaceClass = data.airspace.class;
                        const laanc = data.airspace.laancRequired ? 'Required' : 'Not Required';
                        console.log(`üèõÔ∏è Airspace: Class ${airspaceClass} (LAANC: ${laanc})`);
                    }

                    return data;

                } catch (error) {
                    console.error('‚ùå FAA Airspace classification error:', error);
                    return { success: false, airspace: null, error: error.message };
                }
            }

            /**
             * V12.0: Check airspace for aircraft using OpenSky Network
             * Returns aircraft within radius of location
             */
            async function checkAirspace(lat, lng, radiusKm) {
                try {
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('‚ö†Ô∏è Worker URL not configured for airspace check');
                        return { success: false, aircraft: [], count: 0 };
                    }

                    const radiusMeters = Math.round(radiusKm * 1000);
                    const url = `${workerUrl}/api/airspace/aircraft?lat=${lat}&lon=${lng}&radius=${radiusMeters}`;

                    console.log(`‚úàÔ∏è Checking airspace: ${radiusKm}km radius...`);

                    const response = await fetch(url);

                    if (!response.ok) {
                        console.warn('Airspace API error:', response.status);
                        return { success: false, aircraft: [], count: 0 };
                    }

                    const data = await response.json();

                    if (data.success && data.count > 0) {
                        console.log(`‚úàÔ∏è Found ${data.count} aircraft in area`);
                    } else {
                        console.log('‚úÖ No aircraft detected in area');
                    }

                    return data;

                } catch (error) {
                    console.error('‚ùå Airspace check error:', error);
                    return { success: false, aircraft: [], count: 0, error: error.message };
                }
            }

            /**
             * V12.0: Determine airspace status for a spot based on aircraft proximity
             * V12.1 FIX: Only consider LOW ALTITUDE aircraft as conflicts
             *
             * Logic:
             * - Drones fly max 400 ft AGL (FAA Part 107)
             * - Only aircraft below 1,500 ft AGL are relevant conflicts
             * - High-altitude commercial traffic (8,000+ ft) is NOT a concern
             *
             * Returns: { status: 'clear|caution|restricted', message: string, closestAircraft: object }
             */
            function determineAirspaceStatus(spotLat, spotLng, aircraftData) {
                if (!aircraftData || !aircraftData.success || aircraftData.count === 0) {
                    return {
                        status: 'clear',
                        message: 'No aircraft detected',
                        aircraft: [],
                        closestAircraft: null
                    };
                }

                // FILTER 1: Only consider aircraft below 1,500 ft (low altitude = potential conflict)
                // Drones max 400 ft, so aircraft above 1,500 ft pose no operational conflict
                const LOW_ALTITUDE_THRESHOLD_FT = 1500;

                const lowAltitudeAircraft = aircraftData.aircraft.filter(ac => {
                    return ac.altitudeFt <= LOW_ALTITUDE_THRESHOLD_FT;
                });

                // If no low-altitude aircraft, check for proximity of any aircraft (informational)
                if (lowAltitudeAircraft.length === 0) {
                    // Check if there are high-altitude aircraft nearby (for information only)
                    const nearbyHighAltitude = aircraftData.aircraft.filter(ac => {
                        const distance = calculateDistance(spotLat, spotLng, ac.latitude, ac.longitude);
                        ac.spotDistance = distance;
                        ac.spotDistanceMiles = (distance * 0.000621371).toFixed(1);
                        return distance <= 8047; // 5 miles
                    });

                    if (nearbyHighAltitude.length > 0) {
                        nearbyHighAltitude.sort((a, b) => a.spotDistance - b.spotDistance);
                        const closest = nearbyHighAltitude[0];
                        return {
                            status: 'clear',
                            message: `Clear to fly - nearest aircraft at ${closest.altitudeFt.toLocaleString()} ft (above drone altitude)`,
                            aircraft: [],
                            closestAircraft: null,
                            highAltitudeInfo: nearbyHighAltitude
                        };
                    }

                    return {
                        status: 'clear',
                        message: 'No low-altitude aircraft detected',
                        aircraft: [],
                        closestAircraft: null
                    };
                }

                // FILTER 2: Find low-altitude aircraft within 5 miles of this specific spot
                const nearbyAircraft = lowAltitudeAircraft.filter(ac => {
                    const distance = calculateDistance(spotLat, spotLng, ac.latitude, ac.longitude);
                    ac.spotDistance = distance; // meters
                    ac.spotDistanceMiles = (distance * 0.000621371).toFixed(1);
                    return distance <= 8047; // 5 miles in meters
                });

                if (nearbyAircraft.length === 0) {
                    return {
                        status: 'clear',
                        message: 'No low-altitude aircraft within 5 miles',
                        aircraft: [],
                        closestAircraft: null
                    };
                }

                // Sort by distance from spot
                nearbyAircraft.sort((a, b) => a.spotDistance - b.spotDistance);
                const closest = nearbyAircraft[0];

                // Determine status based on closest LOW-ALTITUDE aircraft
                const distanceMiles = parseFloat(closest.spotDistanceMiles);
                const altitudeFt = closest.altitudeFt;

                // VERY CLOSE + LOW ALTITUDE = DANGER
                if (distanceMiles < 1 && altitudeFt < 500) {
                    return {
                        status: 'restricted',
                        message: `‚ö†Ô∏è LOW AIRCRAFT ALERT: ${distanceMiles} mi away at ${altitudeFt} ft - DO NOT FLY`,
                        aircraft: nearbyAircraft,
                        closestAircraft: closest
                    };
                }
                // CLOSE + LOW ALTITUDE = HIGH CAUTION
                else if (distanceMiles < 3 && altitudeFt < 1000) {
                    return {
                        status: 'restricted',
                        message: `Aircraft ${distanceMiles} mi away (${closest.callsign}) at ${altitudeFt} ft - Wait for clearance`,
                        aircraft: nearbyAircraft,
                        closestAircraft: closest
                    };
                }
                // MODERATE DISTANCE + LOW ALTITUDE = CAUTION
                else if (distanceMiles < 5) {
                    return {
                        status: 'caution',
                        message: `Low-altitude aircraft ${distanceMiles} mi away (${closest.callsign}) at ${altitudeFt} ft - Monitor before flying`,
                        aircraft: nearbyAircraft,
                        closestAircraft: closest
                    };
                }
                // EDGE CASE: Shouldn't reach here due to 5-mile filter above
                else {
                    return {
                        status: 'clear',
                        message: 'No immediate aircraft conflicts',
                        aircraft: [],
                        closestAircraft: null
                    };
                }
            }

            /**
             * V13.0: Determine overall flight status combining aircraft + FAA airspace
             * Returns the most restrictive status from both factors
             */
            function determineOverallFlightStatus(aircraftStatus, faaAirspace) {
                // If no data available, return unknown status
                if (!aircraftStatus && !faaAirspace) {
                    return {
                        status: 'unknown',
                        message: 'Airspace data unavailable',
                        factors: []
                    };
                }

                const factors = [];
                let overallStatus = 'clear';
                let messages = [];

                // Factor 1: Aircraft proximity
                if (aircraftStatus) {
                    factors.push({
                        type: 'aircraft',
                        status: aircraftStatus.status,
                        message: aircraftStatus.message
                    });

                    if (aircraftStatus.status === 'restricted') {
                        overallStatus = 'restricted';
                        messages.push(aircraftStatus.message);
                    } else if (aircraftStatus.status === 'caution' && overallStatus !== 'restricted') {
                        overallStatus = 'caution';
                        messages.push(aircraftStatus.message);
                    } else if (aircraftStatus.status === 'clear') {
                        messages.push('‚úàÔ∏è ' + aircraftStatus.message);
                    }
                }

                // Factor 2: FAA Airspace classification
                if (faaAirspace) {
                    const airspaceStatus = faaAirspace.laancRequired ?
                        (faaAirspace.class === 'B' ? 'restricted' : 'caution') :
                        'clear';

                    factors.push({
                        type: 'faa_airspace',
                        status: airspaceStatus,
                        class: faaAirspace.class,
                        laancRequired: faaAirspace.laancRequired,
                        message: `Class ${faaAirspace.class} airspace${faaAirspace.laancRequired ? ' - LAANC authorization required' : ''}`
                    });

                    // Class B is most restrictive (requires ATC clearance)
                    if (faaAirspace.class === 'B' && faaAirspace.laancRequired) {
                        overallStatus = 'restricted';
                        messages.push(`üèõÔ∏è Class B airspace - ATC authorization required via LAANC`);
                    }
                    // Class C/D/E requires LAANC but can be approved
                    else if (faaAirspace.laancRequired && overallStatus !== 'restricted') {
                        overallStatus = 'caution';
                        messages.push(`üèõÔ∏è Class ${faaAirspace.class} - LAANC authorization required`);
                    }
                    // Class G is uncontrolled
                    else if (faaAirspace.class === 'G') {
                        messages.push(`üèõÔ∏è Class G (uncontrolled airspace)`);
                    }
                }

                // Compile final message
                let finalMessage = '';
                if (overallStatus === 'restricted') {
                    finalMessage = 'üö´ DO NOT FLY: ' + messages.join(' ‚Ä¢ ');
                } else if (overallStatus === 'caution') {
                    finalMessage = '‚ö†Ô∏è AUTHORIZATION REQUIRED: ' + messages.join(' ‚Ä¢ ');
                } else {
                    finalMessage = '‚úÖ CLEAR TO FLY: ' + messages.join(' ‚Ä¢ ');
                }

                return {
                    status: overallStatus,
                    message: finalMessage,
                    factors: factors,
                    aircraft: aircraftStatus?.aircraft || [],
                    faaAirspace: faaAirspace
                };
            }

            /**
             * V10.1: Search Foursquare for places via Cloudflare Worker
             * Per Claude chat recommendation - comprehensive location discovery
             */
            async function searchFoursquarePlaces(lat, lng, radiusKm, locationName = '') {
                try {
                    console.log(`üìç Foursquare place search: ${radiusKm}km radius from [${lat.toFixed(4)}, ${lng.toFixed(4)}]`);

                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('‚ö†Ô∏è Worker URL not configured');
                        return { success: false, error: 'Worker URL not configured' };
                    }

                    // Convert km to meters for Foursquare API (must be integer)
                    const radiusMeters = Math.round(radiusKm * 1000);
                    const url = `${workerUrl}/api/foursquare/discover?lat=${lat}&lon=${lng}&radius=${radiusMeters}`;

                    console.log(`üì° Fetching from worker: ${url}`);

                    const response = await fetch(url);

                    if (!response.ok) {
                        console.error('Worker API error:', response.status);
                        return { success: false, error: `Worker error: ${response.status}` };
                    }

                    const data = await response.json();

                    if (!data.success || !data.results || data.results.length === 0) {
                        console.warn('No Foursquare places found');
                        return { success: false, error: data.error || 'No places found' };
                    }

                    console.log(`‚úÖ Found ${data.count} places from Foursquare (${data.totalPlacesAnalyzed} analyzed)`);

                    // Process Foursquare places into DroneScout format
                    const processedSpots = await processFoursquarePlaces(data.results, lat, lng, locationName);

                    return {
                        success: true,
                        spots: processedSpots,
                        count: processedSpots.length
                    };

                } catch (error) {
                    console.error('‚ùå Foursquare place search error:', error);
                    return { success: false, error: error.message };
                }
            }

            /**
             * Process Foursquare places into DroneScout spot format
             */
            async function processFoursquarePlaces(places, centerLat, centerLng, locationName = '') {
                const spots = [];

                for (let index = 0; index < Math.min(places.length, 15); index++) {
                    const place = places[index];

                    try {
                        // Calculate distance
                        const distance = calculateDistance(centerLat, centerLng, place.lat, place.lng);

                        // Determine spot type from Foursquare categories
                        const spotType = {
                            category: place.primaryCategory || 'landmark',
                            name: place.primaryCategory || 'Drone Spot',
                            bestTime: 'Golden hour',
                            shotTypes: determineShotTypesFromCategories(place.categories)
                        };

                        // Use Foursquare photo (now included with premium credits)
                        const imageUrl = place.photoUrl || null;
                        const imageSource = place.photoUrl ? 'foursquare' : 'none';

                        // Fetch weather and obstacles in parallel
                        const [weatherData, obstacleData] = await Promise.all([
                            fetchCurrentWeather(place.lat, place.lng, 'imperial'),
                            detectObstacles(place.lat, place.lng, 500).catch(() => ({ count: 0, types: [], risk: 'low' }))
                        ]);

                        // Build description from Foursquare data
                        let description = place.description;
                        if (place.tips && place.tips.length > 0) {
                            description += ` ‚Ä¢ "${place.tips[0].text}"`;
                        }

                        spots.push({
                            id: place.fsq_id,
                            name: place.name,
                            description: description,
                            coordinates: { lat: place.lat, lng: place.lng },
                            imageUrl: imageUrl,
                            imageSource: imageSource,
                            imageMetadata: {
                                foursquareId: place.fsq_id,
                                categories: place.categories,
                                popularity: place.popularity,
                                rating: place.rating,
                                droneScore: place.droneScore
                            },
                            flightInstructions: place.tips && place.tips.length > 0 ?
                                `Photo-worthy location - ${place.tips.length} community tip(s)` :
                                `Drone score: ${place.droneScore}/100`,
                            bestTime: spotType.bestTime,
                            x10Advantage: "X10's advanced autonomy enables safe navigation to capture stunning aerial perspectives.",
                            distance: `${distance.toFixed(1)} mi`,
                            riskScore: calculateRiskScore({}, spotType),
                            shotTypes: spotType.shotTypes,
                            airspaceDetails: {
                                class: "Class G (Uncontrolled)",
                                ceiling: "Up to 400 ft AGL authorized",
                                laancRequired: "Check local requirements",
                                nearestAirport: "Verify on SkyVector/B4UFLY"
                            },
                            regulations: [
                                { authority: "FAA Part 107", rule: "Visual line of sight required", compliant: true },
                                { authority: "Local Authority", rule: "Verify local drone regulations before flight", compliant: true }
                            ],
                            weather: weatherData.weather,
                            weatherError: weatherData.error,
                            weatherConditions: weatherData.weather ? {
                                wind: `${weatherData.weather.windSpeed} ${weatherData.weather.windSpeedUnit}`,
                                visibility: `${weatherData.weather.visibility} ${weatherData.weather.visibilityUnit}`,
                                temp: `${weatherData.weather.temp}${weatherData.weather.tempUnit}`,
                                conditions: weatherData.weather.conditions
                            } : {
                                wind: "Check current conditions",
                                visibility: "Check current conditions",
                                temp: "Check current conditions",
                                conditions: "Verify before flight"
                            },
                            intelligence: {
                                obstacles: obstacleData,
                                access: { status: 'check_locally', score: 10 },
                                populationDensity: { density: 'unknown' },
                                cellCoverage: 'good',
                                foursquareScore: place.droneScore
                            }
                        });

                    } catch (error) {
                        console.error(`Error processing place ${place.name}:`, error);
                    }
                }

                // Sort by drone score (already sorted from worker, but ensure)
                return spots.sort((a, b) => {
                    return (b.imageMetadata.droneScore || 0) - (a.imageMetadata.droneScore || 0);
                });
            }

            /**
             * Determine shot types from Foursquare categories
             */
            function determineShotTypesFromCategories(categories) {
                if (!categories || categories.length === 0) {
                    return { cityscape: 50, nature: 50, landscape: 50, architecture: 50 };
                }

                const categoryNames = categories.map(c => c.toLowerCase());

                // Urban/City indicators
                const cityKeywords = ['city', 'urban', 'downtown', 'skyline', 'landmark', 'monument', 'building', 'stadium', 'university', 'bridge', 'harbor'];
                const cityScore = categoryNames.filter(c => cityKeywords.some(k => c.includes(k))).length;

                // Nature indicators
                const natureKeywords = ['nature', 'park', 'beach', 'garden', 'scenic', 'viewpoint', 'outdoors', 'natural'];
                const natureScore = categoryNames.filter(c => natureKeywords.some(k => c.includes(k))).length;

                // Architecture indicators
                const archKeywords = ['architecture', 'historic', 'building', 'monument', 'church', 'cathedral', 'temple'];
                const archScore = categoryNames.filter(c => archKeywords.some(k => c.includes(k))).length;

                return {
                    cityscape: Math.min(100, cityScore * 30 + 30),
                    nature: Math.min(100, natureScore * 30 + 30),
                    landscape: Math.min(100, natureScore * 25 + 25),
                    architecture: Math.min(100, archScore * 25 + 25)
                };
            }

            // ========================================
            // LEGACY: Overpass API POI search functions
            // V10.0: Use user's preferred search radius
            async function searchPOIsNearLocation(lat, lng, radiusKm = null, locationName = '') {
                try {
                    // Use user profile radius if not specified
                    if (!radiusKm) {
                        radiusKm = state.userProfile.preferences.searchRadius_mi * 1.60934; // Convert miles to km
                    }

                    // V10.0: Enhanced query with broader location types
                    console.log(`üîç Searching ${radiusKm}km radius (${(radiusKm * 0.621371).toFixed(1)} mi) from [${lat.toFixed(4)}, ${lng.toFixed(4)}]`);
                    const query = `
                        [out:json][timeout:25];
                        (
                          node["tourism"="viewpoint"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="peak"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="park"](around:${radiusKm * 1000},${lat},${lng});
                          way["natural"="water"](around:${radiusKm * 1000},${lat},${lng});
                          relation["natural"="water"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="nature_reserve"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="beach"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="beach_resort"](around:${radiusKm * 1000},${lat},${lng});
                          way["landuse"="forest"](around:${radiusKm * 1000},${lat},${lng});
                          node["man_made"="tower"]["tower:type"="observation"](around:${radiusKm * 1000},${lat},${lng});
                          way["tourism"="attraction"](around:${radiusKm * 1000},${lat},${lng});
                          node["tourism"="attraction"](around:${radiusKm * 1000},${lat},${lng});
                          way["building"="commercial"]["building:levels"](around:${radiusKm * 1000},${lat},${lng});
                          node["historic"="monument"](around:${radiusKm * 1000},${lat},${lng});
                          way["amenity"="place_of_worship"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="stadium"](around:${radiusKm * 1000},${lat},${lng});
                          node["leisure"="marina"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="marina"](around:${radiusKm * 1000},${lat},${lng});
                          node["amenity"="boat_ramp"](around:${radiusKm * 1000},${lat},${lng});
                          way["waterway"="river"](around:${radiusKm * 1000},${lat},${lng});
                          way["waterway"="canal"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="coastline"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="garden"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="common"](around:${radiusKm * 1000},${lat},${lng});
                        );
                        out center tags 40;
                    `;

                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: 'data=' + encodeURIComponent(query)
                    });

                    if (!response.ok) {
                        console.error('Overpass API HTTP error:', response.status, response.statusText);
                        throw new Error(`Overpass API failed: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log(`‚úÖ Overpass returned ${data.elements?.length || 0} POIs for location`);

                    if (!data.elements || data.elements.length === 0) {
                        console.warn('‚ö†Ô∏è No POIs found in this area. Try a different location or radius.');
                        return [];
                    }

                    return await processPOIs(data.elements, lat, lng, locationName);
                } catch (error) {
                    console.error('‚ùå POI search error:', error.message || error);
                    return [];
                }
            }

            // V10.0: Detect obstacles near a location (power lines, towers, etc.)
            // V13.0.2: Enhanced to return obstacle details with names and locations
            async function detectObstacles(lat, lng, radiusMeters = 500) {
                try {
                    // Query for major obstacles with full data
                    const query = `
                        [out:json][timeout:3];
                        (
                          way["power"="line"](around:${radiusMeters},${lat},${lng});
                          node["power"="tower"](around:${radiusMeters},${lat},${lng});
                          way["man_made"="tower"](around:${radiusMeters},${lat},${lng});
                          node["man_made"="tower"](around:${radiusMeters},${lat},${lng});
                          node["man_made"="mast"](around:${radiusMeters},${lat},${lng});
                        );
                        out body;
                    `;

                    // Add timeout to prevent hanging
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2500);

                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: 'data=' + encodeURIComponent(query),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        return { count: 0, types: [], obstacles: [], risk: 'low' };
                    }

                    const data = await response.json();
                    const count = data.elements.length;

                    // Build detailed obstacle list
                    const obstacles = data.elements.map(el => {
                        let type = 'Unknown';
                        let name = el.tags?.name || null;

                        if (el.tags?.power === 'line') {
                            type = 'Power Line';
                        } else if (el.tags?.power === 'tower') {
                            type = 'Power Tower';
                        } else if (el.tags?.man_made === 'tower') {
                            type = el.tags?.['tower:type'] ? `${el.tags['tower:type']} Tower` : 'Tower';
                        } else if (el.tags?.man_made === 'mast') {
                            type = 'Mast';
                        }

                        // Calculate distance from spot
                        const obstacleLatLng = el.type === 'way' ?
                            (el.center ? { lat: el.center.lat, lon: el.center.lon } : null) :
                            { lat: el.lat, lon: el.lon };

                        let distance = null;
                        if (obstacleLatLng) {
                            const distMeters = calculateDistance(lat, lng, obstacleLatLng.lat, obstacleLatLng.lon);
                            distance = Math.round(distMeters * 3.28084); // Convert to feet
                        }

                        return {
                            id: el.id,
                            type: type,
                            name: name,
                            distance: distance,
                            tags: el.tags || {}
                        };
                    }).filter(o => o.distance !== null); // Remove obstacles without location

                    // Sort by distance (closest first)
                    obstacles.sort((a, b) => a.distance - b.distance);

                    // Get unique types
                    const types = [...new Set(obstacles.map(o => o.type))];

                    return {
                        count,
                        types: types,
                        obstacles: obstacles, // NEW: Full obstacle details
                        risk: count === 0 ? 'low' : count < 3 ? 'medium' : 'high'
                    };
                } catch (error) {
                    // Silent fail - don't block spot loading if obstacle detection times out
                    console.warn('Obstacle detection error:', error);
                    return { count: 0, types: [], obstacles: [], risk: 'low' };
                }
            }

            // V10.0: Estimate population density (heuristic approach)
            function estimatePopulationDensity(locationName, tags) {
                // Major cities - high density
                const majorCities = /New York|NYC|Manhattan|Brooklyn|Chicago|Los Angeles|LA|San Francisco|SF|Philadelphia|Washington DC|Miami|Boston|Seattle/i;
                if (majorCities.test(locationName)) {
                    return {
                        density: 'high',
                        peoplePerSqMi: 10000,
                        requiresWaiver: true,
                        reason: 'Major urban area - over-people waiver required'
                    };
                }

                // Mid-size cities - medium density
                const midCities = /Austin|Denver|Portland|Atlanta|Dallas|Houston|Phoenix|Detroit|Nashville|Charlotte/i;
                if (midCities.test(locationName)) {
                    return {
                        density: 'medium',
                        peoplePerSqMi: 3000,
                        requiresWaiver: true,
                        reason: 'Urban area - check crowd density at flight time'
                    };
                }

                // Check OSM tags for urban indicators
                if (tags.building || tags['building:levels'] || tags.shop || tags.office || tags.amenity === 'restaurant') {
                    return {
                        density: 'medium',
                        peoplePerSqMi: 2000,
                        requiresWaiver: true,
                        reason: 'Commercial/residential area - avoid crowds'
                    };
                }

                // Nature areas - low density
                if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest' || tags.natural === 'water') {
                    return {
                        density: 'low',
                        peoplePerSqMi: 100,
                        requiresWaiver: false,
                        reason: 'Remote natural area'
                    };
                }

                // Parks can vary
                if (tags.leisure === 'park') {
                    // Urban parks might be crowded
                    if (majorCities.test(locationName) || midCities.test(locationName)) {
                        return {
                            density: 'medium',
                            peoplePerSqMi: 1500,
                            requiresWaiver: true,
                            reason: 'Urban park - may have crowds during peak times'
                        };
                    }
                    return {
                        density: 'low',
                        peoplePerSqMi: 500,
                        requiresWaiver: false,
                        reason: 'Suburban/rural park'
                    };
                }

                // Default: suburban/rural
                return {
                    density: 'low',
                    peoplePerSqMi: 500,
                    requiresWaiver: false,
                    reason: 'Low population area'
                };
            }

            // V10.0: Determine land access from OSM tags
            function determineLandAccess(tags) {
                // Check access tag
                const access = tags.access || tags.Access;
                const ownership = tags.ownership || tags.Ownership;
                const operator = tags.operator || tags.Operator;

                // Explicit access tags
                if (access === 'private' || access === 'no') {
                    return {
                        status: 'restricted',
                        type: 'private',
                        score: 0,
                        reason: 'Private property - no public access'
                    };
                }

                if (access === 'permissive' || access === 'yes') {
                    return {
                        status: 'accessible',
                        type: 'public',
                        score: 15,
                        reason: 'Public access permitted'
                    };
                }

                if (access === 'customers' || access === 'destination') {
                    return {
                        status: 'restricted',
                        type: 'limited',
                        score: 5,
                        reason: 'Limited access (customers only)'
                    };
                }

                // Check ownership
                if (ownership === 'private') {
                    return {
                        status: 'caution',
                        type: 'private',
                        score: 5,
                        reason: 'Private property - verify access rights'
                    };
                }

                if (ownership === 'public' || ownership === 'municipal' || ownership === 'state' || ownership === 'federal') {
                    // Public land but may have drone restrictions
                    if (operator && /National Park|State Park|NPS/.test(operator)) {
                        return {
                            status: 'permit_required',
                            type: 'public_restricted',
                            score: 10,
                            reason: 'Public land - permit may be required for drones'
                        };
                    }
                    return {
                        status: 'accessible',
                        type: 'public',
                        score: 15,
                        reason: 'Public land'
                    };
                }

                // Check for specific place types that indicate access
                if (tags.leisure === 'park' || tags.leisure === 'nature_reserve') {
                    return {
                        status: 'accessible',
                        type: 'public',
                        score: 15,
                        reason: 'Public park/reserve'
                    };
                }

                if (tags.tourism === 'viewpoint' || tags.tourism === 'attraction') {
                    return {
                        status: 'accessible',
                        type: 'public',
                        score: 12,
                        reason: 'Tourist viewpoint - likely accessible'
                    };
                }

                if (tags.landuse === 'military') {
                    return {
                        status: 'restricted',
                        type: 'military',
                        score: 0,
                        reason: 'Military installation - no access'
                    };
                }

                // Default: Unknown but assume public viewpoint if it's in OSM
                return {
                    status: 'unknown',
                    type: 'assumed_public',
                    score: 10,
                    reason: 'Public access likely (verify before flight)'
                };
            }

            // Process POIs into spot format (async to fetch real images + weather)
            async function processPOIs(elements, centerLat, centerLng, locationName = '') {
                const spots = [];

                // Limit to first 15 spots to avoid excessive API calls
                const limitedElements = elements.slice(0, 15);

                // Process each element and fetch images + weather
                for (let index = 0; index < limitedElements.length; index++) {
                    const element = limitedElements[index];

                    // Get coordinates (handle nodes and ways differently)
                    let poiLat, poiLng;
                    if (element.lat && element.lon) {
                        poiLat = element.lat;
                        poiLng = element.lon;
                    } else if (element.center) {
                        poiLat = element.center.lat;
                        poiLng = element.center.lon;
                    } else {
                        continue; // Skip if no coordinates
                    }

                    // Calculate distance
                    const distance = calculateDistance(centerLat, centerLng, poiLat, poiLng);

                    // Determine spot type and generate appropriate data
                    const tags = element.tags || {};
                    const spotType = determineSpotType(tags, locationName, tags);

                    // V10.0: Get real place name from reverse geocoding if OSM name missing
                    let name = tags.name;
                    let realLocationName = locationName;

                    if (!name) {
                        // No OSM name - do reverse geocoding to get real address/place name
                        const reverseGeocode = await fetch(
                            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${poiLat}&lon=${poiLng}&zoom=18&addressdetails=1`,
                            { headers: { 'User-Agent': 'DroneScout/10.0' } }
                        ).then(r => r.json()).catch(() => null);

                        if (reverseGeocode) {
                            // Build a meaningful name from address components
                            const addr = reverseGeocode.address || {};
                            name = addr.road || addr.neighbourhood || addr.suburb ||
                                   addr.village || addr.hamlet || addr.town ||
                                   reverseGeocode.display_name?.split(',')[0] ||
                                   `${spotType.name} at ${addr.city || addr.county || 'Unknown Location'}`;

                            realLocationName = reverseGeocode.display_name || locationName;
                            console.log(`üè∑Ô∏è Reverse geocoded: "${name}" from`, addr);
                        } else {
                            name = `${spotType.name} ${index + 1}`;
                        }
                    }

                    // Debug: Log OSM tags to see what data is available
                    console.log(`üìç Spot: ${name}`, 'OSM Tags:', tags);

                    // V10.0: Fetch image, weather, and obstacles in parallel
                    // Use full location context for accurate image search
                    const imageSearchQuery = realLocationName || `${name}, ${locationName}`;
                    console.log(`üñºÔ∏è Image search query: "${imageSearchQuery}"`);

                    const [imageData, weatherData, obstacleData] = await Promise.all([
                        fetchLocationImage(poiLat, poiLng, spotType.category, imageSearchQuery),
                        fetchCurrentWeather(poiLat, poiLng, 'imperial'),
                        detectObstacles(poiLat, poiLng, 500).catch(() => ({ count: 0, types: [], risk: 'low' }))
                    ]);

                    // V10.0: Determine land access from OSM tags
                    const accessInfo = determineLandAccess(tags);

                    // V10.0: Estimate population density
                    const populationInfo = estimatePopulationDensity(locationName, tags);

                    spots.push({
                        id: element.id || Date.now() + index,
                        name: name,
                        description: generateDescription(tags, spotType, realLocationName, name),
                        coordinates: { lat: poiLat, lng: poiLng },
                        imageUrl: imageData.imageUrl,
                        imageSource: imageData.source, // 'streetview' or 'unsplash'
                        imageMetadata: imageData.metadata || {},
                        flightInstructions: generateFlightInstructions(spotType, tags),
                        bestTime: spotType.bestTime,
                        x10Advantage: "X10's advanced autonomy and Nightsense capability enable safe navigation and stunning shots in varied lighting conditions.",
                        distance: `${distance.toFixed(1)} mi`,
                        riskScore: calculateRiskScore(tags, spotType),
                        shotTypes: spotType.shotTypes,
                        airspaceDetails: {
                            class: "Class G (Uncontrolled)",
                            ceiling: "Up to 400 ft AGL authorized",
                            laancRequired: "Check local requirements",
                            nearestAirport: "Verify on SkyVector/B4UFLY"
                        },
                        regulations: [
                            { authority: "FAA Part 107", rule: "Visual line of sight required (unless BVLOS waiver)", compliant: true },
                            { authority: "Local Authority", rule: "Verify local drone regulations before flight", compliant: true }
                        ],
                        // Real weather data from OpenWeather API
                        weather: weatherData.weather,
                        weatherError: weatherData.error,
                        // Legacy weatherConditions for backwards compatibility
                        weatherConditions: weatherData.weather ? {
                            wind: `${weatherData.weather.windSpeed} ${weatherData.weather.windSpeedUnit}`,
                            visibility: `${weatherData.weather.visibility} ${weatherData.weather.visibilityUnit}`,
                            temp: `${weatherData.weather.temp}${weatherData.weather.tempUnit}`,
                            conditions: weatherData.weather.conditions
                        } : {
                            wind: "Check current conditions",
                            visibility: "Check current conditions",
                            temp: "Check current conditions",
                            conditions: "Verify before flight"
                        },
                        // V10.0: Intelligence data for smart scoring
                        intelligence: {
                            obstacles: obstacleData,
                            access: accessInfo,
                            populationDensity: populationInfo,
                            cellCoverage: 'unknown' // Placeholder for future enhancement
                        }
                    });
                }

                // Sort by distance
                return spots.sort((a, b) => {
                    const distA = parseFloat(a.distance);
                    const distB = parseFloat(b.distance);
                    return distA - distB;
                });
            }

            // Helper function to calculate distance in miles
            function calculateDistance(lat1, lng1, lat2, lng2) {
                const R = 3959; // Earth's radius in miles
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng / 2) * Math.sin(dLng / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Determine spot type from OSM tags
            function determineSpotType(tags, locationName = '', osmTags = {}) {
                // Detect if location is urban (major city)
                const isUrban = locationName && (
                    /New York|NYC|Manhattan|Brooklyn|Queens|Bronx|Staten Island/i.test(locationName) ||
                    /Chicago|Los Angeles|LA|San Francisco|SF|Seattle|Boston|Philadelphia|Washington DC|DC|Miami/i.test(locationName) ||
                    /Houston|Phoenix|Dallas|Austin|Denver|Portland|Atlanta|Detroit/i.test(locationName)
                );

                // Check OSM tags for urban indicators
                const hasUrbanTags = osmTags.building || osmTags['building:levels'] ||
                                    osmTags.highway || osmTags.amenity === 'restaurant' ||
                                    osmTags.shop || osmTags.office;

                const isCity = isUrban || hasUrbanTags;

                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    return {
                        category: 'viewpoint',
                        name: 'Viewpoint',
                        bestTime: 'Golden hour (sunrise/sunset)',
                        shotTypes: isCity
                            ? { cityscape: 70, architecture: 20, landscape: 10, nature: 0 }
                            : { landscape: 80, nature: 20, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.natural === 'water' || tags.natural === 'beach') {
                    return {
                        category: 'water',
                        name: 'Water Feature',
                        bestTime: 'Early morning for calm water',
                        shotTypes: isCity
                            ? { cityscape: 40, architecture: 20, landscape: 20, nature: 20 }
                            : { nature: 60, landscape: 40, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.leisure === 'park') {
                    return {
                        category: 'park',
                        name: 'Park',
                        bestTime: 'Golden hour',
                        shotTypes: isCity
                            ? { cityscape: 40, nature: 30, architecture: 20, landscape: 10 }
                            : { nature: 50, landscape: 30, cityscape: 20, architecture: 0 }
                    };
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return {
                        category: 'nature',
                        name: 'Nature Reserve',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 70, landscape: 30, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.man_made === 'tower') {
                    return {
                        category: 'architecture',
                        name: 'Observation Tower',
                        bestTime: 'Blue hour for city lights',
                        shotTypes: { architecture: 50, cityscape: 30, landscape: 20, nature: 0 }
                    };
                } else if (tags.historic === 'monument') {
                    return {
                        category: 'architecture',
                        name: 'Monument',
                        bestTime: 'Golden hour or blue hour',
                        shotTypes: { architecture: 60, cityscape: 30, landscape: 10, nature: 0 }
                    };
                } else if (tags.tourism === 'attraction' && tags.building) {
                    return {
                        category: 'architecture',
                        name: 'Landmark',
                        bestTime: 'Golden hour or blue hour',
                        shotTypes: { architecture: 50, cityscape: 40, landscape: 10, nature: 0 }
                    };
                } else if (tags.building === 'commercial' && tags['building:levels']) {
                    return {
                        category: 'cityscape',
                        name: 'High-Rise',
                        bestTime: 'Blue hour for city lights',
                        shotTypes: { cityscape: 70, architecture: 30, landscape: 0, nature: 0 }
                    };
                } else if (tags.amenity === 'place_of_worship') {
                    return {
                        category: 'architecture',
                        name: 'Place of Worship',
                        bestTime: 'Golden hour',
                        shotTypes: { architecture: 60, cityscape: 25, landscape: 15, nature: 0 }
                    };
                } else if (tags.leisure === 'stadium') {
                    return {
                        category: 'architecture',
                        name: 'Stadium',
                        bestTime: 'Event days or blue hour',
                        shotTypes: { architecture: 50, cityscape: 40, landscape: 10, nature: 0 }
                    };
                } else if (tags.leisure === 'marina' || tags.amenity === 'boat_ramp') {
                    return {
                        category: 'water',
                        name: tags.leisure === 'marina' ? 'Marina' : 'Boat Launch',
                        bestTime: 'Early morning or golden hour',
                        shotTypes: { nature: 50, landscape: 30, cityscape: 20, architecture: 0 }
                    };
                } else if (tags.waterway === 'river' || tags.waterway === 'canal') {
                    return {
                        category: 'water',
                        name: tags.waterway === 'river' ? 'River' : 'Canal',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.leisure === 'garden' || tags.leisure === 'common') {
                    return {
                        category: 'nature',
                        name: tags.leisure === 'garden' ? 'Garden' : 'Common',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 60, landscape: 30, cityscape: 10, architecture: 0 }
                    };
                } else if (tags.leisure === 'beach_resort') {
                    return {
                        category: 'water',
                        name: 'Beach Resort',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 50, landscape: 40, cityscape: 10, architecture: 0 }
                    };
                } else if (tags.tourism === 'attraction') {
                    return {
                        category: 'landmark',
                        name: 'Tourist Attraction',
                        bestTime: 'Golden hour',
                        shotTypes: isCity
                            ? { cityscape: 50, architecture: 30, landscape: 20, nature: 0 }
                            : { landscape: 50, nature: 30, cityscape: 20, architecture: 0 }
                    };
                } else {
                    return {
                        category: 'landscape',
                        name: 'Scenic Spot',
                        bestTime: 'Golden hour',
                        shotTypes: isCity
                            ? { cityscape: 40, architecture: 30, landscape: 20, nature: 10 }
                            : { landscape: 50, nature: 30, cityscape: 10, architecture: 10 }
                    };
                }
            }

            // Helper: Convert meters to feet
            function metersToFeet(meters) {
                const feet = Math.round(meters * 3.28084);
                return feet.toLocaleString(); // Add comma separators for large numbers
            }

            // Generate description based on tags
            function generateDescription(tags, spotType, locationName = '', spotName = '') {
                // Use real OSM description if available
                if (tags.description) {
                    return tags.description;
                }

                // Build description from available OSM tags and location name
                let parts = [];
                let context = [];

                // Use spot name if it's meaningful (not generic like "Viewpoint 1")
                if (spotName && !spotName.match(/Viewpoint \d+|Park \d+|Water Feature \d+/)) {
                    // We have a real location name - use it!
                    parts.push(spotName);
                }

                // Add location context
                if (locationName) {
                    const cleanLocation = locationName.split(',').slice(0, 2).join(',');
                    if (!parts.some(p => p.includes(cleanLocation))) {
                        context.push(cleanLocation);
                    }
                }

                // Primary feature description with more detail
                if (tags.natural === 'peak') {
                    parts.push(tags.ele ? `Mountain peak at ${metersToFeet(tags.ele)} ft elevation` : 'Mountain peak');
                } else if (tags.natural === 'beach') {
                    parts.push('Beach area');
                    if (tags.surface) parts.push(`${tags.surface} surface`);
                } else if (tags.natural === 'water') {
                    const waterType = tags.water || 'water';
                    parts.push(`${waterType.charAt(0).toUpperCase() + waterType.slice(1)}`);
                } else if (tags.tourism === 'viewpoint') {
                    // More specific viewpoint descriptions
                    if (tags.man_made === 'tower' || tags.building === 'yes') {
                        parts.push('Observation deck');
                    } else {
                        parts.push('Scenic viewpoint');
                    }
                    if (tags.ele) parts.push(`at ${metersToFeet(tags.ele)} ft elevation`);
                    if (tags.direction) parts.push(`facing ${tags.direction}`);
                } else if (tags.leisure === 'park') {
                    if (tags['park:type']) {
                        parts.push(`${tags['park:type']} park`.replace(/_/g, ' '));
                    } else {
                        parts.push('Public park');
                    }
                } else if (tags.leisure === 'nature_reserve') {
                    parts.push('Nature reserve');
                } else if (tags.landuse === 'forest') {
                    parts.push(tags.leaf_type ? `${tags.leaf_type} forest` : 'Forest area');
                } else if (tags.man_made === 'tower') {
                    if (tags['tower:type'] === 'observation') {
                        parts.push('Observation tower');
                    } else {
                        parts.push('Tower');
                    }
                    if (tags.height) parts.push(`${tags.height} tall`);
                } else if (tags.tourism === 'attraction') {
                    parts.push('Tourist attraction');
                } else if (tags.building) {
                    if (tags.building === 'commercial') parts.push('Commercial building');
                    else if (tags.building !== 'yes') parts.push(tags.building);
                }

                // Add contextual information
                if (tags['addr:city']) context.push(`in ${tags['addr:city']}`);
                if (tags.operator) context.push(`operated by ${tags.operator}`);
                if (tags.wikipedia || tags.wikidata) context.push('notable landmark');
                if (tags.heritage) context.push('historic site');
                if (tags.wheelchair === 'yes') context.push('accessible');

                // Add access warnings
                if (tags.access === 'private') {
                    context.push('‚ö†Ô∏è private property');
                } else if (tags.access === 'permissive') {
                    context.push('permission required');
                } else if (tags.fee === 'yes') {
                    context.push('admission fee');
                }

                // Build final description
                let desc = '';
                if (parts.length > 0) {
                    desc = parts.join(' ');
                    if (context.length > 0) {
                        desc += ` - ${context.join(', ')}`;
                    }
                    return desc;
                }

                // If no specific parts, at least include context
                if (context.length > 0) {
                    return context.join(', ');
                }

                // Fallback - shouldn't hit this with reverse geocoding
                return `${spotType.name} location`;
            }

            // Get contextual drone photography advice based on spot type
            function getGenericDroneAdvice(tags, spotType) {
                // More descriptive, less generic advice
                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    if (tags.man_made === 'tower' || tags.building) {
                        return 'Elevated observation point with panoramic views. Ideal for 360¬∞ aerial shots and wide-angle landscape footage.';
                    }
                    return 'Scenic overlook offering expansive views. Perfect for panoramic aerial shots and sunrise/sunset captures.';
                } else if (tags.natural === 'water') {
                    const waterType = tags.water;
                    if (waterType === 'lake' || waterType === 'reservoir') {
                        return 'Water feature with potential for reflection shots. Best for calm morning captures with mirror-like surface effects.';
                    } else if (waterType === 'river') {
                        return 'Flowing water feature. Great for dynamic footage following waterways and capturing movement.';
                    }
                    return 'Natural water area. Excellent for capturing reflections, waterscapes, and aerial perspectives of aquatic environments.';
                } else if (tags.natural === 'beach') {
                    return 'Coastal area with beach access. Perfect for shoreline tracking shots, wave patterns, and coastal landscapes.';
                } else if (tags.leisure === 'park') {
                    return 'Public park with open green space. Good for varied terrain shots, tree canopy patterns, and recreational area footage.';
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return 'Protected natural area. Excellent for wildlife habitat views, forest canopy footage, and ecological landscapes.';
                } else if (tags.tourism === 'attraction') {
                    return 'Notable point of interest. Suitable for architectural details, crowd dynamics, and tourist area perspectives.';
                } else {
                    return 'Drone-friendly location with aerial photography opportunities. Check local regulations before flying.';
                }
            }

            // Generate flight instructions
            function generateFlightInstructions(spotType, tags) {
                if (spotType.category === 'viewpoint') {
                    return 'Launch from designated area. Ascend to 200-300 ft AGL for panoramic shots. Capture 360¬∞ orbit and reveal shots.';
                } else if (spotType.category === 'water') {
                    return 'Launch from shoreline. Fly low (50-150 ft AGL) to capture reflections. Use slow tracking shots parallel to water.';
                } else if (spotType.category === 'park') {
                    return 'Launch from open area. Mix of altitudes: low for detail (100 ft), medium for context (200 ft), high for establishing (300 ft).';
                } else {
                    return 'Survey area from 200 ft AGL. Identify key features. Capture varied angles and perspectives. Maintain safe distances from obstacles.';
                }
            }

            // Get image URL based on spot type
            function getImageForSpotType(category) {
                const images = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return images[category] || images.landscape;
            }

            // Calculate risk score based on tags
            function calculateRiskScore(tags, spotType) {
                let score = 75; // Base score

                // Increase score for nature/open areas
                if (tags.natural || tags.leisure === 'park' || tags.leisure === 'nature_reserve') {
                    score += 10;
                }

                // Decrease score for urban/complex areas
                if (tags.man_made || tags.building) {
                    score -= 15;
                }

                // Adjust for accessibility
                if (tags.access === 'private') {
                    score -= 20;
                }

                return Math.max(50, Math.min(95, score));
            }

            // Calculate adjusted risk score based on learning
            function getAdjustedRiskScore(spot) {
                const baseScore = spot.riskScore;
                if (state.ratings.length === 0) return baseScore;

                const shotTypeRatings = {};
                const shotTypeCounts = {};

                state.ratings.forEach(rating => {
                    const flight = state.flights.find(f => f.id === rating.flightId);
                    if (flight && flight.spotData && flight.spotData.shotTypes) {
                        const shotTypes = flight.spotData.shotTypes;
                        const dominantType = Object.keys(shotTypes).reduce((a, b) =>
                            shotTypes[a] > shotTypes[b] ? a : b
                        );

                        if (!shotTypeRatings[dominantType]) {
                            shotTypeRatings[dominantType] = 0;
                            shotTypeCounts[dominantType] = 0;
                        }

                        const avgRating = (rating.descAccuracy + rating.shotTypeMatch + rating.accessibility) / 3;
                        shotTypeRatings[dominantType] += avgRating;
                        shotTypeCounts[dominantType]++;
                    }
                });

                Object.keys(shotTypeRatings).forEach(type => {
                    shotTypeRatings[type] = shotTypeRatings[type] / shotTypeCounts[type];
                });

                const dominantType = Object.keys(spot.shotTypes).reduce((a, b) =>
                    spot.shotTypes[a] > spot.shotTypes[b] ? a : b
                );

                if (shotTypeRatings[dominantType]) {
                    const avgRating = shotTypeRatings[dominantType];
                    const adjustedScore = baseScore * (avgRating / 3);
                    return Math.round(Math.max(1, Math.min(100, adjustedScore)));
                }

                return baseScore;
            }

            // V9.0: Calculate preference match score for spot ranking
            function calculatePreferenceMatch(shotTypes, preferences) {
                if (!shotTypes || !preferences) return 50;

                // Map slider values to shot type weights
                // Cityscape slider: 0=landscape, 100=cityscape
                const cityscapeWeight = preferences.cityscape / 100;
                const landscapeWeight = (100 - preferences.cityscape) / 100;

                // Nature slider: 0=architecture, 100=nature
                const natureWeight = preferences.nature / 100;
                const architectureWeight = (100 - preferences.nature) / 100;

                // Calculate weighted match
                const match =
                    (shotTypes.cityscape || 0) * cityscapeWeight +
                    (shotTypes.landscape || 0) * landscapeWeight +
                    (shotTypes.nature || 0) * natureWeight +
                    (shotTypes.architecture || 0) * architectureWeight;

                // Normalize (shotTypes sum to ~100)
                const totalShotTypeValue = Object.values(shotTypes).reduce((a, b) => a + b, 0);
                const preferenceScore = totalShotTypeValue > 0 ? (match / totalShotTypeValue) * 100 : 50;

                return Math.round(preferenceScore);
            }

            // V9.0: Calculate spot score combining distance and preference match
            // V10.0: Intelligent scoring algorithm
            function calculateSpotScore(spot, searchCenter, preferences) {
                if (!searchCenter) {
                    // Fallback to risk score if no search center
                    return spot.riskScore || 50;
                }

                let totalScore = 0;
                const breakdown = {
                    legal: 0,
                    accessibility: 0,
                    safety: 0,
                    photoQuality: 0
                };

                // ===== LEGAL VIABILITY (25 points) =====
                // Local regulations (10 pts) - placeholder for now
                breakdown.legal += 10;

                // Population density with waiver check (15 pts)
                if (spot.intelligence && spot.intelligence.populationDensity) {
                    const popInfo = spot.intelligence.populationDensity;
                    const hasOverPeopleWaiver = state.userProfile.waivers.some(w => w.type === 'over_people');

                    if (!popInfo.requiresWaiver) {
                        // Low density, no waiver needed
                        breakdown.legal += 15;
                    } else if (hasOverPeopleWaiver) {
                        // High density but user has waiver
                        breakdown.legal += 15;
                    } else {
                        // High density, no waiver = penalized
                        breakdown.legal += 5;
                    }
                } else {
                    breakdown.legal += 10; // Default middle score
                }

                // ===== ACCESSIBILITY (25 points) =====
                // Land access (15 pts)
                if (spot.intelligence && spot.intelligence.access) {
                    breakdown.accessibility += spot.intelligence.access.score;
                } else {
                    breakdown.accessibility += 10; // Default assume accessible
                }

                // Proximity (10 pts)
                const distance = parseFloat(spot.distance) || 0;
                const maxDistance = state.userProfile.preferences.searchRadius_mi;
                const proximityScore = Math.max(0, 10 - (distance / maxDistance * 10));
                breakdown.accessibility += proximityScore;

                // ===== SAFETY (20 points) =====
                // Obstacles (10 pts)
                if (spot.intelligence && spot.intelligence.obstacles) {
                    const obsRisk = spot.intelligence.obstacles.risk;
                    if (obsRisk === 'low') breakdown.safety += 10;
                    else if (obsRisk === 'medium') breakdown.safety += 6;
                    else breakdown.safety += 3;
                } else {
                    breakdown.safety += 8; // Default assume safe
                }

                // Emergency landing (5 pts) - check spot type
                if (spot.shotTypes) {
                    const hasNature = (spot.shotTypes.nature || 0) + (spot.shotTypes.landscape || 0);
                    breakdown.safety += Math.min(5, hasNature / 20); // More nature = better emergency options
                }

                // Cell coverage (5 pts) - assume good for now
                breakdown.safety += 4;

                // ===== PHOTO QUALITY (30 points) =====
                // Preference match (20 pts)
                const preferenceMatch = calculatePreferenceMatch(spot.shotTypes, preferences);
                breakdown.photoQuality += (preferenceMatch / 100) * 20;

                // Weather conditions (10 pts)
                if (spot.weather && spot.weather.flyable) {
                    if (spot.weather.flyingConditions === 'excellent') breakdown.photoQuality += 10;
                    else if (spot.weather.flyingConditions === 'good') breakdown.photoQuality += 8;
                    else if (spot.weather.flyingConditions === 'fair') breakdown.photoQuality += 5;
                    else breakdown.photoQuality += 2;
                } else {
                    breakdown.photoQuality += 6; // Default assume fair
                }

                // Calculate final score
                totalScore = breakdown.legal + breakdown.accessibility + breakdown.safety + breakdown.photoQuality;

                // Store breakdown for display in spot detail
                spot.scoreBreakdown = breakdown;

                return Math.round(totalScore);
            }

            // V9.0: Get match badge color based on percentage
            function getMatchColor(percentage) {
                if (percentage >= 90) return '#22c55e'; // Green
                if (percentage >= 70) return '#eab308'; // Yellow
                if (percentage >= 50) return '#f97316'; // Orange
                return '#94a3b8'; // Gray
            }

            // V9.0: Get match label based on percentage
            function getMatchLabel(percentage) {
                if (percentage >= 90) return 'Perfect Match';
                if (percentage >= 70) return 'Good Match';
                if (percentage >= 50) return 'Moderate Match';
                return 'Low Match';
            }

            // V9.0: Count spots by dominant shot type
            function countSpotsByType(type) {
                return state.spots.filter(spot => {
                    if (!spot.shotTypes) return false;
                    const dominant = Object.keys(spot.shotTypes).reduce((a, b) =>
                        spot.shotTypes[a] > spot.shotTypes[b] ? a : b
                    );
                    return dominant === type;
                }).length;
            }

            // Cloud sync functions
            async function checkConnection() {
                try {
                    state.syncSettings.connectionStatus = 'checking';
                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (response.ok) {
                        state.syncSettings.connectionStatus = 'connected';
                        console.log('Connection check successful:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status
                        });
                    } else {
                        state.syncSettings.connectionStatus = 'error';
                        const errorText = await response.text();
                        console.error('Connection check failed:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status,
                            statusText: response.statusText,
                            body: errorText
                        });
                    }
                } catch (error) {
                    state.syncSettings.connectionStatus = 'error';
                    console.error('Connection check error:', {
                        message: error.message,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                }
            }

            async function syncFlights() {
                try {
                    state.syncMessage = { type: 'info', text: 'Syncing...' };
                    render();

                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Sync failed');

                    const data = await response.json();

                    if (data.flights && Array.isArray(data.flights)) {
                        data.flights.forEach(flight => {
                            const existingIndex = state.flights.findIndex(f => f.id === flight.id && f.type === 'synced');
                            const processedFlight = {
                                id: flight.id,
                                type: 'synced',
                                synced: true, // V7.1: Flag for showing "View Flight Path" button
                                name: flight.name || `Flight ${new Date(flight.created_at).toLocaleDateString()}`,
                                date: flight.created_at,
                                created_at: flight.created_at,
                                duration: flight.duration_seconds,
                                duration_seconds: flight.duration_seconds,
                                location: flight.location || null,
                                notes: '',
                                mediaUrls: flight.media_urls || [],
                                syncedAt: new Date().toISOString(),
                                metadata: flight.metadata || {}
                            };

                            if (existingIndex >= 0) {
                                processedFlight.notes = state.flights[existingIndex].notes || '';
                                processedFlight.locationName = state.flights[existingIndex].locationName || null;
                                state.flights[existingIndex] = processedFlight;
                            } else {
                                state.flights.unshift(processedFlight);
                            }
                        });
                    }

                    state.syncSettings.lastSync = new Date().toISOString();
                    state.syncSettings.connectionStatus = 'connected';
                    state.syncMessage = { type: 'success', text: `Synced ${data.flights ? data.flights.length : 0} flights. Resolving locations...` };
                    saveToStorage('flights', state.flights);
                    saveToStorage('syncSettings', state.syncSettings);
                    render();

                    // Reverse geocode locations for newly synced flights (rate limited)
                    await reverseGeocodeAllFlights();

                    // Fetch historical weather for flights (V10.2)
                    state.syncMessage = { type: 'info', text: 'Fetching weather data...' };
                    render();
                    await fetchWeatherForFlights();
                    state.syncMessage = { type: 'success', text: `Synced ${data.flights ? data.flights.length : 0} flights with weather data` };
                    render();
                } catch (error) {
                    console.error('Sync error:', {
                        message: error.message,
                        stack: error.stack,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                    state.syncSettings.connectionStatus = 'error';
                    state.syncMessage = {
                        type: 'error',
                        text: `Sync failed: ${error.message}. Check console for details.`
                    };
                    render();
                }
            }

            // Fetch detailed flight data including telemetry track
            async function fetchFlightDetails(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/details`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight details');

                    const data = await response.json();

                    if (data.success) {
                        return {
                            flight: data.flight,
                            telemetry: data.telemetry
                        };
                    }

                    return null;
                } catch (error) {
                    console.error('Error fetching flight details:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight details: ${error.message}` };
                    render();
                    return null;
                }
            }

            // Fetch media (photos/videos) for a flight
            async function fetchFlightMedia(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/media`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight media');

                    const data = await response.json();

                    if (data.success) {
                        return data.media;
                    }

                    return [];
                } catch (error) {
                    console.error('Error fetching flight media:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load media: ${error.message}` };
                    render();
                    return [];
                }
            }

            // Load complete flight data (details + media)
            async function loadSyncedFlightData(flightId) {
                state.syncMessage = { type: 'info', text: 'Loading flight data...' };
                render();

                const [details, media] = await Promise.all([
                    fetchFlightDetails(flightId),
                    fetchFlightMedia(flightId)
                ]);

                if (details) {
                    // Update the flight in state with detailed data
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0) {
                        state.flights[flightIndex] = {
                            ...state.flights[flightIndex],
                            details: details.flight,
                            telemetry: details.telemetry,
                            mediaUrls: media.map(m => m.downloadUrl),
                            mediaDetails: media
                        };
                        saveToStorage('flights', state.flights);
                    }

                    state.syncMessage = { type: 'success', text: 'Flight data loaded' };
                    render();
                    return { details, media };
                }

                return null;
            }

            // V10.2: Fetch historical weather for all flights
            async function fetchWeatherForFlights() {
                try {
                    console.log('üìä Fetching weather for flights...');
                    let weatherFetched = 0;

                    // Process flights in batches to avoid rate limiting
                    for (const flight of state.flights) {
                        // Skip if already has weather data
                        if (flight.weather) {
                            console.log(`Flight ${flight.id} already has weather data`);
                            continue;
                        }

                        // Get location from telemetry track if available, otherwise from location field
                        let lat, lon;

                        if (flight.telemetry?.track && flight.telemetry.track.length > 0) {
                            // Use first valid GPS point from telemetry
                            const firstPoint = flight.telemetry.track.find(p => p.lat !== 0 && p.lon !== 0);
                            if (firstPoint) {
                                lat = firstPoint.lat;
                                lon = firstPoint.lon;
                                console.log(`Using telemetry GPS for flight ${flight.id}: ${lat}, ${lon}`);
                            }
                        } else if (flight.location) {
                            // Try location field (might be structured differently)
                            if (flight.location.latitude && flight.location.longitude) {
                                lat = flight.location.latitude;
                                lon = flight.location.longitude;
                            } else if (flight.location.lat && flight.location.lon) {
                                lat = flight.location.lat;
                                lon = flight.location.lon;
                            }
                        }

                        // Skip if no location data found
                        if (!lat || !lon) {
                            console.log(`Flight ${flight.id} has no location data - need to load telemetry first`);
                            continue;
                        }

                        // Skip if no date
                        if (!flight.date && !flight.created_at) {
                            console.log(`Flight ${flight.id} has no date`);
                            continue;
                        }

                        // Get timestamp from flight date
                        const flightDate = new Date(flight.date || flight.created_at);
                        const timestamp = Math.floor(flightDate.getTime() / 1000); // Unix timestamp

                        console.log(`Fetching weather for flight ${flight.id} at ${flightDate.toISOString()}`);

                        try {
                            const response = await fetch(
                                `${state.syncSettings.workerUrl}/api/weather/historical?` +
                                `lat=${lat}&` +
                                `lon=${lon}&` +
                                `timestamp=${timestamp}&` +
                                `units=imperial`
                            );

                            const data = await response.json();

                            if (data.success && data.weather) {
                                // Add weather to flight object
                                flight.weather = data.weather;
                                weatherFetched++;
                                console.log(`‚úÖ Weather fetched for flight ${flight.id}:`, data.weather);
                            } else if (data.fallback) {
                                // Historical data not available (older than 5 days on free tier)
                                console.log(`‚ö†Ô∏è Historical weather not available for flight ${flight.id}: ${data.message}`);
                                flight.weather = {
                                    unavailable: true,
                                    message: data.message,
                                    fallback: true
                                };
                            } else {
                                console.error(`Failed to fetch weather for flight ${flight.id}:`, data.error);
                            }

                            // Small delay to avoid rate limiting (1 req/sec for free tier)
                            await new Promise(resolve => setTimeout(resolve, 1100));

                        } catch (error) {
                            console.error(`Error fetching weather for flight ${flight.id}:`, error);
                        }
                    }

                    // Save updated flights with weather data
                    if (weatherFetched > 0) {
                        saveToStorage('flights', state.flights);
                        console.log(`‚úÖ Fetched weather for ${weatherFetched} flights`);
                    }

                } catch (error) {
                    console.error('Error in fetchWeatherForFlights:', error);
                }
            }

            // View flight path on map
            async function viewFlightPath(flightId) {
                try {
                    // Show loading message
                    state.syncMessage = { type: 'info', text: 'Loading flight path...' };

                    // Fetch flight details with telemetry FIRST
                    const details = await fetchFlightDetails(flightId);

                    if (!details || !details.telemetry || !details.telemetry.track) {
                        state.syncMessage = { type: 'error', text: 'No telemetry data available for this flight' };
                        render();
                        return;
                    }

                    // CRITICAL: Save telemetry to flight object in state so it persists
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0) {
                        state.flights[flightIndex] = {
                            ...state.flights[flightIndex],
                            telemetry: details.telemetry,
                            details: details.flight
                        };
                        saveToStorage('flights', state.flights);
                        console.log('Telemetry saved for flight:', flightId, details.telemetry.stats);
                    }

                    // Display comprehensive field report in console
                    if (details.telemetry?.fieldReport) {
                        console.log('=== üìä TELEMETRY FIELD REPORT ===');
                        console.log('Available Fields:', details.telemetry.fieldReport.fields);
                        console.log('Total Field Count:', details.telemetry.fieldReport.fieldCount);
                        console.log('\n=== DETAILED FIELD ANALYSIS ===');

                        Object.entries(details.telemetry.fieldReport.analysis).forEach(([fieldName, analysis]) => {
                            console.log(`\n${fieldName}:`);
                            console.log('  ', analysis);
                        });

                        console.log('\n=== END FIELD REPORT ===\n');
                    }

                    // Switch to planner tab and render
                    state.currentTab = 'planner';
                    render();

                    // CRITICAL: Wait for tab transition and DOM to be fully ready
                    // Use requestAnimationFrame to ensure DOM is painted before creating map
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await new Promise(resolve => requestAnimationFrame(resolve));

                    // Clean up old map if exists
                    if (state.map) {
                        state.map.remove();
                        state.map = null;
                    }

                    // Get map container
                    const mapContainer = document.getElementById('mapContainer');
                    if (!mapContainer) {
                        console.error('Map container not found!');
                        return;
                    }

                    console.log('Container dimensions:', mapContainer.offsetWidth, 'x', mapContainer.offsetHeight);

                    // Convert telemetry to LatLng array - AGGRESSIVE FILTERING
                    // First pass: get all non-zero points
                    const allPoints = details.telemetry.track
                        .filter(point => point.lat !== 0 && point.lon !== 0)
                        .map(point => [point.lat, point.lon]);

                    console.log('All non-zero points:', allPoints.length);

                    // Calculate median lat/lon to find the center of the actual flight
                    const lats = allPoints.map(p => p[0]).sort((a, b) => a - b);
                    const lons = allPoints.map(p => p[1]).sort((a, b) => a - b);
                    const medianLat = lats[Math.floor(lats.length / 2)];
                    const medianLon = lons[Math.floor(lons.length / 2)];

                    console.log('Median center:', medianLat, medianLon);

                    // Second pass: keep only points within ~50 miles (~0.7 degrees) of median
                    // This removes GPS errors that place points in different states/countries
                    const pathCoords = allPoints.filter(point => {
                        const latDiff = Math.abs(point[0] - medianLat);
                        const lonDiff = Math.abs(point[1] - medianLon);
                        return latDiff < 0.7 && lonDiff < 0.7;
                    });

                    console.log('Path coordinates (filtered):', pathCoords.length, 'First:', pathCoords[0], 'Last:', pathCoords[pathCoords.length-1]);

                    if (pathCoords.length === 0) {
                        console.error('No valid GPS coordinates in telemetry!');
                        return;
                    }

                    // CRITICAL: Reduce point density if too many points (performance optimization)
                    // Too many points (1000+) can cause rendering issues and prevent tiles from loading
                    let displayCoords = pathCoords;
                    if (pathCoords.length > 200) {
                        const skipFactor = Math.ceil(pathCoords.length / 200);
                        displayCoords = pathCoords.filter((_, index) => index % skipFactor === 0);
                        // Always include last point
                        if (!displayCoords.includes(pathCoords[pathCoords.length - 1])) {
                            displayCoords.push(pathCoords[pathCoords.length - 1]);
                        }
                        console.log(`Reduced ${pathCoords.length} points to ${displayCoords.length} for display (skip factor: ${skipFactor})`);
                    }

                    // Create map - start with a default view, will adjust with fitBounds
                    const centerPoint = displayCoords[Math.floor(displayCoords.length / 2)];
                    state.map = L.map('mapContainer').setView(centerPoint, 15);

                    // Add OpenStreetMap tiles - SIMPLE approach
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(state.map);

                    console.log('Map created, drawing flight path with', displayCoords.length, 'points');

                    // Draw flight path on map (using reduced point set)
                    const flightPath = L.polyline(displayCoords, {
                        color: '#2563eb',
                        weight: 3,
                        opacity: 0.8,
                        className: 'flight-path'
                    }).addTo(state.map);

                    // Automatically fit map to show entire flight path
                    // CRITICAL: Disable animation to prevent tile request cancellation
                    state.map.fitBounds(flightPath.getBounds(), {
                        padding: [50, 50],
                        animate: false  // No zoom animation = no tile cancellation
                    });

                    console.log('Flight path added, map fitted to bounds');

                    // Force tile loading after bounds are set
                    state.map.invalidateSize();

                    console.log('Map invalidated, tiles should load now');

                    // Add markers for takeoff and landing
                    const startPoint = pathCoords[0];
                    const endPoint = pathCoords[pathCoords.length - 1];

                    L.marker(startPoint, {
                        icon: L.divIcon({
                            html: 'üõ´',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Takeoff</b><br>${details.flight.vehicleSerial}`);

                    L.marker(endPoint, {
                        icon: L.divIcon({
                            html: 'üõ¨',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Landing</b><br>${details.flight.vehicleSerial}`);

                    // Fit map to show entire flight path
                    state.map.fitBounds(flightPath.getBounds(), { padding: [50, 50] });

                    // Force another size recalculation after zoom
                    setTimeout(() => {
                        state.map.invalidateSize();
                    }, 100);

                    // SUCCESS! Don't call render() here - it would destroy the map we just created
                    // Just update the message element directly
                    state.syncMessage = { type: 'success', text: `Flight path loaded (${details.telemetry.pointCount} points)` };
                    console.log('‚úÖ Flight path rendering complete - map should be visible');
                } catch (error) {
                    console.error('Error viewing flight path:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight path: ${error.message}` };
                    render();
                }
            }

            // Load flight map inline (no tab switching)
            async function loadInlineFlightMap(flightId) {
                try {
                    const mapContainerId = `inline-map-${flightId}`;
                    const mapContainer = document.getElementById(mapContainerId);

                    if (!mapContainer) {
                        console.error('Inline map container not found:', mapContainerId);
                        return;
                    }

                    // Show loading state
                    mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #666;"><span class="spinner"></span> Loading map...</div>';

                    // Check if telemetry is already loaded
                    const flight = state.flights.find(f => f.id === flightId);
                    let telemetry = flight?.telemetry;

                    // If not loaded, fetch it
                    if (!telemetry) {
                        const details = await fetchFlightDetails(flightId);
                        if (!details || !details.telemetry || !details.telemetry.track) {
                            mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #999;">No telemetry data available</div>';
                            return;
                        }

                        // Save to state
                        const flightIndex = state.flights.findIndex(f => f.id === flightId);
                        if (flightIndex >= 0) {
                            state.flights[flightIndex] = {
                                ...state.flights[flightIndex],
                                telemetry: details.telemetry,
                                details: details.flight
                            };
                            saveToStorage('flights', state.flights);
                        }

                        telemetry = details.telemetry;
                    }

                    // Clear container for map
                    mapContainer.innerHTML = '';

                    // Process GPS coordinates (same filtering as viewFlightPath)
                    const allPoints = telemetry.track
                        .filter(point => point.lat !== 0 && point.lon !== 0)
                        .map(point => [point.lat, point.lon]);

                    const lats = allPoints.map(p => p[0]).sort((a, b) => a - b);
                    const lons = allPoints.map(p => p[1]).sort((a, b) => a - b);
                    const medianLat = lats[Math.floor(lats.length / 2)];
                    const medianLon = lons[Math.floor(lons.length / 2)];

                    const pathCoords = allPoints.filter(point => {
                        const latDiff = Math.abs(point[0] - medianLat);
                        const lonDiff = Math.abs(point[1] - medianLon);
                        return latDiff < 0.7 && lonDiff < 0.7;
                    });

                    if (pathCoords.length === 0) {
                        mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #999;">No valid GPS coordinates</div>';
                        return;
                    }

                    // Reduce points for performance
                    let displayCoords = pathCoords;
                    if (pathCoords.length > 500) {
                        const skipFactor = Math.ceil(pathCoords.length / 500);
                        displayCoords = pathCoords.filter((_, idx) => idx % skipFactor === 0);
                    }

                    // Create map
                    const map = L.map(mapContainer, {
                        scrollWheelZoom: true,
                        dragging: true,
                        touchZoom: true,
                        doubleClickZoom: true
                    }).setView([medianLat, medianLon], 15);

                    // Add tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap',
                        crossOrigin: true,
                        maxZoom: 19
                    }).addTo(map);

                    // Draw flight path
                    const flightPath = L.polyline(displayCoords, {
                        color: '#1e3c72',
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);

                    // Add start and end markers
                    L.marker(displayCoords[0], {
                        icon: L.divIcon({
                            className: 'start-marker',
                            html: '<div style="background: #22c55e; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">S</div>',
                            iconSize: [24, 24]
                        })
                    }).addTo(map).bindPopup('Start');

                    L.marker(displayCoords[displayCoords.length - 1], {
                        icon: L.divIcon({
                            className: 'end-marker',
                            html: '<div style="background: #ef4444; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">E</div>',
                            iconSize: [24, 24]
                        })
                    }).addTo(map).bindPopup('End');

                    // Fit to path
                    map.fitBounds(flightPath.getBounds(), {
                        padding: [30, 30],
                        maxZoom: 16
                    });

                    // Force size calculation
                    setTimeout(() => map.invalidateSize(), 100);

                    // Store map reference
                    if (!state.inlineMaps) state.inlineMaps = {};
                    state.inlineMaps[flightId] = map;

                    console.log('‚úÖ Inline map loaded successfully for flight:', flightId);

                    // Update telemetry display if it exists
                    const telemetryDetails = document.querySelector(`.telemetry-details[data-flight-id="${flightId}"]`);
                    if (telemetryDetails && telemetry.stats) {
                        const telemetryContent = telemetryDetails.querySelector('div[style*="padding: 12px"]');
                        if (telemetryContent) {
                            telemetryContent.innerHTML = renderAllTelemetryStats(telemetry.stats);
                        }
                    }

                    // Reverse geocode location if not already done
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0 && !state.flights[flightIndex].locationName && displayCoords.length > 0) {
                        // Use first coordinate (launch point)
                        const [lat, lon] = displayCoords[0];
                        const locationName = await reverseGeocode(lat, lon);

                        if (locationName) {
                            state.flights[flightIndex].locationName = locationName;
                            saveToStorage('flights', state.flights);

                            // Update the flight card title
                            const flightCard = document.getElementById(`flight-card-${flightId}`);
                            if (flightCard) {
                                const flightTitle = flightCard.querySelector('.flight-location');
                                if (flightTitle) {
                                    const newName = generateFlightName(state.flights[flightIndex]);
                                    // Keep the badges, just update the text
                                    const badges = flightTitle.querySelectorAll('.badge');
                                    flightTitle.innerHTML = newName;
                                    badges.forEach(badge => flightTitle.appendChild(badge));
                                }
                            }

                            console.log('üìç Location resolved:', locationName);
                        }
                    }

                } catch (error) {
                    console.error('Error loading inline map:', error);
                    const mapContainer = document.getElementById(`inline-map-${flightId}`);
                    if (mapContainer) {
                        mapContainer.innerHTML = `<div style="text-align: center; padding: 180px 20px; color: #e74c3c;">Error: ${error.message}</div>`;
                    }
                }
            }

            function formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            // Generate descriptive flight name with drone model, time of day, location, and duration
            function generateFlightName(flight) {
                const date = new Date(flight.created_at || flight.date);
                const hour = date.getHours();

                // Time of day
                let timeOfDay = '';
                if (hour >= 5 && hour < 12) timeOfDay = 'Morning';
                else if (hour >= 12 && hour < 17) timeOfDay = 'Afternoon';
                else if (hour >= 17 && hour < 21) timeOfDay = 'Evening';
                else timeOfDay = 'Night';

                // Drone model from vehicle serial or flight name
                let droneModel = '';
                if (flight.metadata?.vehicle_serial) {
                    droneModel = flight.metadata.vehicle_serial;
                } else if (flight.name && flight.name.includes('Skydio')) {
                    // Extract model from name like "SkydioX10-r6h6 Flight"
                    const match = flight.name.match(/Skydio[^\s]+/);
                    if (match) droneModel = match[0];
                }

                // Duration
                const duration = flight.duration_seconds || flight.duration || 0;
                const durationMin = Math.round(duration / 60);

                // Location from cached reverse geocode or from flight object
                const location = flight.locationName || '';

                // Build descriptive name
                if (droneModel && location) {
                    return `${droneModel} - ${timeOfDay} in ${location} (${durationMin}m)`;
                } else if (droneModel) {
                    return `${droneModel} - ${timeOfDay} Flight (${durationMin}m)`;
                } else {
                    return `${timeOfDay} Flight (${durationMin}m)`;
                }
            }

            // Reverse geocode GPS coordinates to get city, state
            async function reverseGeocode(lat, lon) {
                try {
                    // Use Nominatim (OpenStreetMap's geocoding service)
                    // Rate limit: max 1 request per second
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`,
                        {
                            headers: {
                                'User-Agent': 'DroneScout/1.0 (https://bgslab.github.io/dronescout)'
                            }
                        }
                    );

                    if (!response.ok) return null;

                    const data = await response.json();
                    const address = data.address;

                    // Build location string: City, State or Town, State
                    const city = address.city || address.town || address.village || address.county;
                    const state = address.state;

                    if (city && state) {
                        return `${city}, ${state}`;
                    } else if (city) {
                        return city;
                    } else if (state) {
                        return state;
                    }

                    return null;
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    return null;
                }
            }

            // Reverse geocode all flights that don't have location names yet
            async function reverseGeocodeAllFlights() {
                // Find flights that need geocoding
                const flightsNeedingGeocode = state.flights.filter(f =>
                    f.synced &&
                    !f.locationName &&
                    f.location?.lat &&
                    f.location?.lon
                );

                if (flightsNeedingGeocode.length === 0) {
                    console.log('No flights need geocoding');
                    state.syncMessage = { type: 'success', text: `Synced ${state.flights.filter(f => f.synced).length} flights` };
                    render();
                    return;
                }

                console.log(`Geocoding ${flightsNeedingGeocode.length} flights...`);

                // Process flights one at a time with 1 second delay (Nominatim rate limit)
                for (let i = 0; i < flightsNeedingGeocode.length; i++) {
                    const flight = flightsNeedingGeocode[i];

                    // Update progress message
                    state.syncMessage = {
                        type: 'info',
                        text: `Resolving locations... (${i + 1}/${flightsNeedingGeocode.length})`
                    };
                    render();

                    // Reverse geocode
                    const locationName = await reverseGeocode(flight.location.lat, flight.location.lon);

                    if (locationName) {
                        // Update flight in state
                        const flightIndex = state.flights.findIndex(f => f.id === flight.id);
                        if (flightIndex >= 0) {
                            state.flights[flightIndex].locationName = locationName;
                            console.log(`üìç ${flight.name} ‚Üí ${locationName}`);
                        }
                    }

                    // Wait 1 second before next request (rate limiting)
                    if (i < flightsNeedingGeocode.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                // Save and update UI
                saveToStorage('flights', state.flights);
                state.syncMessage = {
                    type: 'success',
                    text: `Synced ${state.flights.filter(f => f.synced).length} flights with locations`
                };
                render();
                console.log('‚úÖ All flights geocoded');
            }

            // Render telemetry stats - ONLY Speed, Altitude, Distance
            function renderAllTelemetryStats(stats) {
                console.log('üéØ Rendering telemetry stats:', stats);
                console.log('velocity field exists?', !!stats.velocity);
                console.log('velocity data:', stats.velocity);

                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 13px;">';

                // 1. SPEED (from velocity field)
                if (stats.velocity && stats.velocity.max != null) {
                    const maxSpeedMph = (stats.velocity.max * 2.23694).toFixed(1);
                    const maxSpeedMs = stats.velocity.max.toFixed(1);
                    const avgSpeedMph = (stats.velocity.avg * 2.23694).toFixed(1);
                    const avgSpeedMs = stats.velocity.avg.toFixed(1);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Speed</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxSpeedMph} mph</div>
                            <div style="color: #999; font-size: 11px;">${maxSpeedMs} m/s</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Avg Speed</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgSpeedMph} mph</div>
                            <div style="color: #999; font-size: 11px;">${avgSpeedMs} m/s</div>
                        </div>
                    `;
                } else {
                    console.warn('‚ö†Ô∏è Velocity field missing or invalid:', stats.velocity);
                }

                // 2. ALTITUDE (from height_above_takeoff field)
                if (stats.height_above_takeoff) {
                    const maxAltFt = (stats.height_above_takeoff.max * 3.28084).toFixed(0);
                    const maxAltM = stats.height_above_takeoff.max.toFixed(1);
                    const avgAltFt = (stats.height_above_takeoff.avg * 3.28084).toFixed(0);
                    const avgAltM = stats.height_above_takeoff.avg.toFixed(1);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Altitude</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxAltFt} ft</div>
                            <div style="color: #999; font-size: 11px;">${maxAltM} m AGL</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Avg Altitude</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgAltFt} ft</div>
                            <div style="color: #999; font-size: 11px;">${avgAltM} m AGL</div>
                        </div>
                    `;
                }

                // 3. DISTANCE METRICS (calculated from GPS track)
                if (stats._distance_traveled) {
                    const distMiles = stats._distance_traveled.miles.toFixed(2);
                    const distKm = stats._distance_traveled.kilometers.toFixed(2);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Distance Traveled</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${distMiles} mi</div>
                            <div style="color: #999; font-size: 11px;">${distKm} km</div>
                        </div>
                    `;
                }

                if (stats._max_distance_from_launch) {
                    const maxDistMiles = stats._max_distance_from_launch.miles.toFixed(2);
                    const maxDistFeet = stats._max_distance_from_launch.feet.toFixed(0);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Range from Launch</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxDistMiles} mi</div>
                            <div style="color: #999; font-size: 11px;">${maxDistFeet} ft</div>
                        </div>
                    `;
                }

                html += '</div>';
                return html;
            }

            // OLD COMPLEX FUNCTION - REMOVED
            function renderAllTelemetryStats_OLD(stats) {
                // Field display configuration with units and formatting
                // Based on actual Skydio API fields (see field report in console)
                const fieldConfig = {
                    // Speed field (Skydio calls it 'velocity')
                    velocity: { label: 'Speed', unit: 'speed', decimals: 1, showMinMax: true },

                    // Height/Altitude fields
                    height_above_takeoff: { label: 'Height AGL', unit: 'distance', decimals: 0, showMinMax: true },
                    hybrid_altitude: { label: 'Altitude', unit: 'distance', decimals: 0, showMinMax: true },
                    altitude: { label: 'Altitude (broken)', unit: 'distance', decimals: 0, showMinMax: true }, // All zeros

                    // Battery field
                    battery_percentage: { label: 'Battery', unit: 'percent', decimals: 0, showChange: true },

                    // GPS Quality fields
                    gps_num_satellites: { label: 'GPS Satellites', unit: 'count', decimals: 0, showMinMax: false },
                    horizontal_accuracy_estimate: { label: 'GPS H-Accuracy', unit: 'distance', decimals: 2, showMinMax: false },
                    vertical_accuracy_estimate: { label: 'GPS V-Accuracy', unit: 'distance', decimals: 2, showMinMax: false },
                };

                // Unit conversion and formatting functions
                function formatValue(value, unitType, decimals) {
                    if (value == null) return 'N/A';

                    switch(unitType) {
                        case 'speed':
                            // m/s to mph
                            return {
                                primary: `${(value * 2.23694).toFixed(decimals)} mph`,
                                secondary: `${value.toFixed(decimals)} m/s`
                            };
                        case 'distance':
                            // m to ft
                            return {
                                primary: `${(value * 3.28084).toFixed(decimals)} ft`,
                                secondary: `${value.toFixed(decimals)} m`
                            };
                        case 'percent':
                            return {
                                primary: `${value.toFixed(decimals)}%`,
                                secondary: null
                            };
                        case 'degrees':
                            return {
                                primary: `${value.toFixed(decimals)}¬∞`,
                                secondary: null
                            };
                        case 'count':
                            return {
                                primary: Math.round(value).toString(),
                                secondary: null
                            };
                        default:
                            return {
                                primary: value.toFixed(decimals),
                                secondary: null
                            };
                    }
                }

                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 13px;">';

                // Render each field that exists in stats
                Object.entries(stats).forEach(([fieldName, fieldStats]) => {
                    const config = fieldConfig[fieldName];
                    if (!config) {
                        // Unknown field - render with basic formatting
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${fieldName.replace(/_/g, ' ')}</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">
                                    Min: ${fieldStats.min?.toFixed(2)}<br>
                                    Max: ${fieldStats.max?.toFixed(2)}<br>
                                    Avg: ${fieldStats.avg?.toFixed(2)}
                                </div>
                                <div style="color: #999; font-size: 11px;">${fieldStats.count} points</div>
                            </div>
                        `;
                        return;
                    }

                    // Check if field has valid data (not all zeros for non-percentage fields)
                    if (!fieldStats.hasNonZero && config.unit !== 'percent') {
                        return; // Skip fields with all zeros
                    }

                    const maxFormatted = formatValue(fieldStats.max, config.unit, config.decimals);
                    const avgFormatted = formatValue(fieldStats.avg, config.unit, config.decimals);
                    const minFormatted = formatValue(fieldStats.min, config.unit, config.decimals);
                    const changeFormatted = formatValue(Math.abs(fieldStats.change), config.unit, config.decimals);

                    if (config.showMinMax) {
                        // Show min/max/avg
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label}</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">
                                    Max: ${maxFormatted.primary}
                                </div>
                                <div style="color: #999; font-size: 11px;">
                                    ${maxFormatted.secondary || ''}
                                    ${maxFormatted.secondary ? '<br>' : ''}
                                    Avg: ${avgFormatted.primary}
                                </div>
                            </div>
                        `;
                    } else if (config.showChange) {
                        // Show start/end/change (for battery)
                        const startFormatted = formatValue(fieldStats.start, config.unit, config.decimals);
                        const endFormatted = formatValue(fieldStats.end, config.unit, config.decimals);
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label} Used</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${changeFormatted.primary}</div>
                                <div style="color: #999; font-size: 11px;">${startFormatted.primary} ‚Üí ${endFormatted.primary}</div>
                            </div>
                        `;
                    } else {
                        // Show average only (for directional fields)
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label} (avg)</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgFormatted.primary}</div>
                                <div style="color: #999; font-size: 11px;">Range: ${minFormatted.primary} - ${maxFormatted.primary}</div>
                            </div>
                        `;
                    }
                });

                html += '</div>';
                return html;
            }

            // V6: Map initialization and management
            function initMap() {
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    console.error('Leaflet not loaded');
                    return;
                }

                const mapContainer = document.getElementById('mapContainer');
                if (!mapContainer) {
                    console.error('Map container not found');
                    return;
                }

                console.log('Initializing map with', state.spots.length, 'spots');

                // Remove existing map if it exists
                if (state.map) {
                    state.map.remove();
                    state.map = null;
                }

                // Clear existing markers
                state.mapMarkers = [];

                // V6.1: Remove existing route polyline if present
                if (state.routePolyline) {
                    state.routePolyline.remove();
                    state.routePolyline = null;
                }

                // Use destination coords if available, otherwise center on first spot
                let centerLat, centerLng, zoom;

                if (state.destinationCoords) {
                    centerLat = state.destinationCoords.lat;
                    centerLng = state.destinationCoords.lng;
                    zoom = 12;
                } else if (state.spots.length > 0 && state.spots[0].coordinates) {
                    // Use first spot's coordinates as fallback
                    centerLat = state.spots[0].coordinates.lat || 40.7128;
                    centerLng = state.spots[0].coordinates.lng || -74.0060;
                    zoom = 12;
                } else {
                    // Default to NYC
                    centerLat = 40.7128;
                    centerLng = -74.0060;
                    zoom = 10;
                }

                // Initialize the map
                state.map = L.map('mapContainer').setView([centerLat, centerLng], zoom);

                // Add OpenStreetMap tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19
                }).addTo(state.map);

                // Add user location marker if available
                if (state.userLocation) {
                    const userMarker = L.marker([state.userLocation.lat, state.userLocation.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-user',
                            html: '<div style="background: #4285f4; color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.3), 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">üìç</div>',
                            iconSize: [26, 26],
                            iconAnchor: [13, 13]
                        })
                    }).addTo(state.map);

                    userMarker.bindPopup('<b>üìç Your Location</b>');
                    state.mapMarkers.push(userMarker);
                }

                // Add destination marker if coords available
                if (state.destinationCoords) {
                    const destinationMarker = L.marker([state.destinationCoords.lat, state.destinationCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-destination',
                            html: '<div style="background: #00d4ff; color: white; padding: 8px 12px; border-radius: 20px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üéØ Destination</div>',
                            iconSize: [130, 40],
                            iconAnchor: [65, 40]
                        })
                    }).addTo(state.map);

                    destinationMarker.bindPopup(`<b>${state.destination}</b><br>${state.destinationCoords.displayName || ''}`);
                }

                // V6.1: Filter spots based on favorites toggle
                const spotsToShow = state.showFavoritesOnly
                    ? state.spots.filter(s => state.favorites.includes(s.id))
                    : state.spots;

                // Add markers for each spot
                let markerIndex = 0;
                spotsToShow.forEach((spot) => {
                    if (spot.coordinates && spot.coordinates.lat && spot.coordinates.lng) {
                        markerIndex++;
                        console.log(`Adding marker ${markerIndex} for ${spot.name} at [${spot.coordinates.lat}, ${spot.coordinates.lng}]`);
                        const riskScore = getAdjustedRiskScore(spot);
                        const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                        const markerColor = riskScore >= 75 ? '#28a745' : riskScore >= 50 ? '#ffc107' : '#dc3545';

                        const marker = L.marker([spot.coordinates.lat, spot.coordinates.lng], {
                            icon: L.divIcon({
                                className: 'custom-marker-spot',
                                html: `<div style="background: ${markerColor}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">${markerIndex}</div>`,
                                iconSize: [36, 36],
                                iconAnchor: [18, 18]
                            })
                        }).addTo(state.map);

                        // Create popup content
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <img src="${spot.imageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;" />
                                <h4 style="margin: 0 0 5px 0; font-size: 14px;">${spot.name}</h4>
                                <p style="margin: 0 0 5px 0; font-size: 12px; color: #666;">${spot.description}</p>
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                    <span style="font-size: 12px; color: #666;">üìç ${spot.distance}</span>
                                    <span style="background: ${markerColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">Score: ${riskScore}</span>
                                </div>
                                <button onclick="window.selectSpotFromMap('${spot.id}')" style="width: 100%; margin-top: 8px; padding: 8px; background: #1e3c72; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">View Details</button>
                            </div>
                        `;

                        marker.bindPopup(popupContent, { maxWidth: 250 });

                        // Click handler
                        marker.on('click', function() {
                            marker.openPopup();
                        });

                        state.mapMarkers.push(marker);
                    }
                });

                // V6.1: Draw route polyline if in route mode
                if (state.plannerMode === 'route' && state.routeStartCoords && state.routeEndCoords) {
                    const routePoints = [
                        [state.routeStartCoords.lat, state.routeStartCoords.lng],
                        ...spotsToShow
                            .filter(s => s.coordinates && s.coordinates.lat && s.coordinates.lng)
                            .map(s => [s.coordinates.lat, s.coordinates.lng]),
                        [state.routeEndCoords.lat, state.routeEndCoords.lng]
                    ];

                    state.routePolyline = L.polyline(routePoints, {
                        color: '#1e3c72',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(state.map);

                    // Add start/end markers
                    const startMarker = L.marker([state.routeStartCoords.lat, state.routeStartCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #28a745; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ Start</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    startMarker.bindPopup(`<b>Start</b><br>${state.routeStart}`);

                    const endMarker = L.marker([state.routeEndCoords.lat, state.routeEndCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #dc3545; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ End</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    endMarker.bindPopup(`<b>End</b><br>${state.routeEnd}`);

                    console.log('Route polyline added with', routePoints.length, 'points');
                }

                // Fit bounds to show all markers if we have spots
                if (state.spots.length > 0 && state.mapMarkers.length > 0) {
                    const group = L.featureGroup(state.mapMarkers);
                    state.map.fitBounds(group.getBounds().pad(0.1));
                    console.log(`Map initialized successfully with ${state.mapMarkers.length} markers`);
                } else {
                    console.warn('No markers added to map. Spots:', state.spots.length, 'Markers:', state.mapMarkers.length);
                }
            }

            // Global function to handle spot selection from map (called from popup button)
            window.selectSpotFromMap = function(spotId) {
                state.selectedSpot = spotId;
                render();
            };

            // V6: Get user's current location
            function getUserLocation() {
                if ('geolocation' in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            state.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                accuracy: position.coords.accuracy
                            };
                            console.log('User location obtained:', state.userLocation);

                            // If map is already initialized, update it
                            if (state.map && state.currentTab === 'planner' && state.spots.length > 0) {
                                initMap();
                            }
                        },
                        (error) => {
                            console.warn('Geolocation error:', error.message);
                            // Don't show error to user, just gracefully fail
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 5000,
                            maximumAge: 300000 // Cache for 5 minutes
                        }
                    );
                } else {
                    console.warn('Geolocation not supported');
                }
            }

            // Render functions
            function render() {
                const content = document.getElementById('content');

                if (state.selectedSpot) {
                    content.innerHTML = renderSpotDetail();
                } else if (state.currentTab === 'planner') {
                    content.innerHTML = renderTripPlanner();
                    // V6: Initialize map after rendering if spots exist
                    if (state.spots.length > 0) {
                        setTimeout(() => initMap(), 100);
                    }
                } else if (state.currentTab === 'upcoming') {
                    content.innerHTML = renderUpcoming();
                } else if (state.currentTab === 'history') {
                    content.innerHTML = renderHistory();
                } else if (state.currentTab === 'settings') {
                    content.innerHTML = renderSettings();
                } else if (state.currentTab === 'analytics') {
                    content.innerHTML = renderAnalytics();
                    setTimeout(() => initCharts(), 100);
                } else if (state.currentTab === 'help') {
                    content.innerHTML = renderHelp();
                }

                attachEventListeners();
            }

            // Helper function to render skeleton loading cards
            function renderSkeletonCards(count = 6) {
                const skeletons = [];
                for (let i = 0; i < count; i++) {
                    skeletons.push(`
                        <div class="skeleton-card">
                            <div class="skeleton-image"></div>
                            <div class="skeleton-content">
                                <div class="skeleton-title"></div>
                                <div class="skeleton-text"></div>
                                <div class="skeleton-badge"></div>
                            </div>
                        </div>
                    `);
                }
                return skeletons.join('');
            }

            function renderTripPlanner() {
                // V9.0: Calculate preference-based scores and match percentages
                const spotsWithScores = state.spots.map(spot => {
                    // Calculate preference-based score
                    const preferenceScore = calculateSpotScore(spot, state.searchCenter, state.preferences);

                    // Apply learning adjustment if user has ratings
                    const learningAdjustment = state.ratings.length > 0 ?
                        (getAdjustedRiskScore(spot) - spot.riskScore) : 0;

                    // Calculate match percentage for display
                    const matchPercentage = calculatePreferenceMatch(spot.shotTypes, state.preferences);

                    return {
                        ...spot,
                        score: preferenceScore + learningAdjustment,
                        matchPercentage: matchPercentage,
                        learningActive: state.ratings.length > 0
                    };
                }).sort((a, b) => b.score - a.score);

                const displaySpots = state.showFavoritesOnly
                    ? spotsWithScores.filter(s => state.favorites.includes(s.id))
                    : spotsWithScores;

                return `
                    <div class="x10-badge">
                        <div class="x10-title">üöÅ Skydio X10 Optimized</div>
                        <div class="x10-features">
                            <span class="feature-tag">üåô Nightsense</span>
                            <span class="feature-tag">üõ° Elite Avoidance</span>
                            <span class="feature-tag">üì° BVLOS Ready</span>
                            <span class="feature-tag">üéØ Part 107 Certified</span>
                        </div>
                    </div>

                    <div class="card">
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="toggle-btn ${state.plannerMode === 'auto' ? 'active' : ''}" data-mode="auto"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'auto' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'auto' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'auto' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Auto Recommend
                            </button>
                            <button class="toggle-btn ${state.plannerMode === 'route' ? 'active' : ''}" data-mode="route"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'route' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'route' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'route' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Route Mode
                            </button>
                        </div>

                        ${state.plannerMode === 'auto' ? `
                            <div class="input-group">
                                <label>üìç Destination</label>
                                <input type="text" id="destinationInput" placeholder="Enter city, hotel, or landmark (press Enter)" value="${state.destination}">
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="btn" id="findSpotsBtn" style="flex: 1;">Find Spots</button>
                                <button class="btn" id="findNearMeBtn" style="flex: 1; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                    üìç Near Me
                                </button>
                            </div>
                        ` : `
                            <div class="input-group">
                                <label>üè® Start Location</label>
                                <input type="text" id="routeStartInput" placeholder="Hotel, airport, etc." value="${state.routeStart}">
                            </div>
                            <div class="input-group">
                                <label>üéØ End Location</label>
                                <input type="text" id="routeEndInput" placeholder="Destination address" value="${state.routeEnd}">
                            </div>
                            <button class="btn" id="findRouteSpotsBtn">Find Spots Along Route</button>
                        `}
                    </div>

                    <div class="preferences-section">
                        <div class="preferences-header">
                            <div class="preferences-title">üéØ Shot Preferences</div>
                            <button class="preferences-toggle" id="togglePreferences">
                                ${state.showPreferences ? 'Hide' : 'Customize'}
                            </button>
                        </div>
                        ${state.showPreferences ? `
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.cityscape < 50 ? 'active' : ''}">Landscape</span>
                                    <span class="slider-label ${state.preferences.cityscape >= 50 ? 'active' : ''}">Cityscape</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.cityscape}" class="slider" id="cityscapeSlider">
                                ${state.spots.length > 0 ? `
                                    <div style="font-size: 11px; color: #666; margin-top: 4px; text-align: center;">
                                        üìä ${countSpotsByType('landscape')} landscape ¬∑ ${countSpotsByType('cityscape')} cityscape
                                    </div>
                                ` : ''}
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.nature < 50 ? 'active' : ''}">Architecture</span>
                                    <span class="slider-label ${state.preferences.nature >= 50 ? 'active' : ''}">Nature</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.nature}" class="slider" id="natureSlider">
                                ${state.spots.length > 0 ? `
                                    <div style="font-size: 11px; color: #666; margin-top: 4px; text-align: center;">
                                        üìä ${countSpotsByType('architecture')} architecture ¬∑ ${countSpotsByType('nature')} nature
                                    </div>
                                ` : ''}
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.architecture < 50 ? 'active' : ''}">Serene</span>
                                    <span class="slider-label ${state.preferences.architecture >= 50 ? 'active' : ''}">Dynamic</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.architecture}" class="slider" id="architectureSlider">
                            </div>
                        ` : ''}
                    </div>

                    <!-- Interactive Map - Always show for V7.1 flight paths -->
                    <div class="card" style="padding: 0; overflow: hidden; margin-bottom: 20px;">
                        <div id="mapContainer" class="map-container" style="height: 400px; width: 100%;"></div>
                    </div>

                    ${state.loadingSpots ? `
                        <div style="margin-bottom: 15px;">
                            <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                                üîç Finding spots...
                            </h2>
                        </div>
                        ${renderSkeletonCards(6)}
                    ` : state.spots.length > 0 ? `

                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin: 0;">
                                üìç ${state.showFavoritesOnly ? 'Favorite' : 'Recommended'} Spots
                            </h2>
                            <button class="toggle-favorites-btn ${state.showFavoritesOnly ? 'active' : ''}" id="toggleFavoritesBtn">
                                ${state.showFavoritesOnly ? '‚òÖ Favorites' : '‚òÜ All Spots'}
                            </button>
                        </div>

                        ${displaySpots.length === 0 ? `
                            <div class="card" style="text-align: center; padding: 40px 20px;">
                                <p style="color: #666;">No favorite spots yet. Star some locations to save them!</p>
                            </div>
                        ` : displaySpots.map((spot, index) => {
                            const markerNumber = index + 1; // 1-indexed marker numbers
                            const riskScore = spot.adjustedScore || spot.riskScore;
                            const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                            const riskLabel = riskScore >= 75 ? 'Clear' : riskScore >= 50 ? 'Caution' : 'Review';
                            const riskIcon = riskScore >= 75 ? '‚úì' : '‚ö†';
                            const markerColor = riskScore >= 75 ? '#28a745' : riskScore >= 50 ? '#ffc107' : '#dc3545';

                            // V9.0: Match percentage and color
                            const matchPercentage = spot.matchPercentage || 50;
                            const matchColor = getMatchColor(matchPercentage);
                            const matchLabel = getMatchLabel(matchPercentage);

                            // Photo source badge (only show for non-Foursquare sources)
                            const photoSourceBadge = spot.imageSource === 'streetview'
                                ? '<div class="photo-source-badge streetview">üì∏ Street View</div>'
                                : spot.imageSource === 'foursquare'
                                ? '' // No badge for Foursquare photos (they're real)
                                : '<div class="photo-source-badge stock">üñºÔ∏è Illustrative</div>';

                            return `
                                <div class="spot-card" data-spot-id="${spot.id}">
                                    <img src="${spot.imageUrl}" alt="${spot.name}" class="spot-image">
                                    <div class="risk-badge ${riskClass}">
                                        ${riskIcon} ${riskScore} ${riskLabel}
                                    </div>
                                    <div style="position: absolute; top: 52px; right: 12px; background: ${markerColor}; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 2px solid white; font-size: 12px; z-index: 5;">
                                        ${markerNumber}
                                    </div>
                                    ${photoSourceBadge}
                                    <button class="favorite-star ${state.favorites.includes(spot.id) ? 'active' : ''}"
                                            data-spot-id="${spot.id}" id="favBtn${spot.id}">
                                        ${state.favorites.includes(spot.id) ? '‚òÖ' : '‚òÜ'}
                                    </button>
                                    <div class="spot-info">
                                        <div class="spot-name">${spot.name}</div>
                                        <div class="spot-desc">${spot.description}</div>
                                        ${spot.imageMetadata?.address ? `
                                            <div style="color: #666; font-size: 12px; margin-top: 4px;">
                                                üìç ${spot.imageMetadata.address}
                                            </div>
                                        ` : ''}
                                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                                            <span class="spot-distance">üöÅ ${spot.distance} away</span>
                                            <span style="color: #ddd;">¬∑</span>
                                            <span style="background: ${matchColor};
                                                         color: white;
                                                         padding: 3px 10px;
                                                         border-radius: 12px;
                                                         font-size: 11px;
                                                         font-weight: 600;
                                                         white-space: nowrap;">
                                                ‚≠ê ${matchPercentage}% match
                                            </span>
                                        </div>
                                        ${renderWeatherCard(spot.weather)}
                                        ${spot.overallStatus ? `
                                            <div style="margin-top: 10px; padding: 10px; border-radius: 8px; background: ${
                                                spot.overallStatus.status === 'clear' ? '#d1fae5' :
                                                spot.overallStatus.status === 'caution' ? '#fef3c7' : '#fee2e2'
                                            }; border-left: 4px solid ${
                                                spot.overallStatus.status === 'clear' ? '#10b981' :
                                                spot.overallStatus.status === 'caution' ? '#f59e0b' : '#ef4444'
                                            };">
                                                <div style="font-size: 12px; font-weight: 700; color: ${
                                                    spot.overallStatus.status === 'clear' ? '#065f46' :
                                                    spot.overallStatus.status === 'caution' ? '#92400e' : '#991b1b'
                                                }; margin-bottom: 4px;">
                                                    ${spot.overallStatus.status === 'clear' ? '‚úÖ CLEAR TO FLY' :
                                                      spot.overallStatus.status === 'caution' ? '‚ö†Ô∏è AUTHORIZATION REQUIRED' : 'üö´ RESTRICTED'}
                                                </div>
                                                <div style="font-size: 11px; color: #666; line-height: 1.4;">
                                                    ${spot.overallStatus.message.replace(/^(‚úÖ CLEAR TO FLY|‚ö†Ô∏è AUTHORIZATION REQUIRED|üö´ DO NOT FLY): /, '')}
                                                </div>
                                            </div>
                                        ` : ''}
                                        ${spot.intelligence ? `
                                            <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px; font-size: 11px;">
                                                ${spot.intelligence.access ? `
                                                    <span style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: ${
                                                        spot.intelligence.access.status === 'accessible' ? '#d1fae5' :
                                                        spot.intelligence.access.status === 'permit_required' ? '#fef3c7' :
                                                        spot.intelligence.access.status === 'restricted' ? '#fee2e2' : '#e5e7eb'
                                                    }; color: ${
                                                        spot.intelligence.access.status === 'accessible' ? '#065f46' :
                                                        spot.intelligence.access.status === 'permit_required' ? '#92400e' :
                                                        spot.intelligence.access.status === 'restricted' ? '#991b1b' : '#1f2937'
                                                    }; font-weight: 600;">
                                                        ${
                                                            spot.intelligence.access.status === 'accessible' ? '‚úÖ' :
                                                            spot.intelligence.access.status === 'permit_required' ? '‚ö†Ô∏è' :
                                                            spot.intelligence.access.status === 'restricted' ? 'üö´' : '‚ùì'
                                                        }
                                                        ${spot.intelligence.access.type === 'public' ? 'Public' :
                                                          spot.intelligence.access.type === 'public_restricted' ? 'Permit Required' :
                                                          spot.intelligence.access.type === 'private' ? 'Private' : 'Limited'}
                                                    </span>
                                                ` : ''}
                                                ${spot.intelligence.populationDensity ? `
                                                    ${(() => {
                                                        const hasWaiver = state.userProfile.waivers.some(w => w.type === 'over_people');
                                                        const needsWaiver = spot.intelligence.populationDensity.requiresWaiver;
                                                        const isOk = !needsWaiver || hasWaiver;
                                                        return `<span style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: ${
                                                            isOk ? '#d1fae5' : '#fef3c7'
                                                        }; color: ${
                                                            isOk ? '#065f46' : '#92400e'
                                                        }; font-weight: 600;">
                                                            ${isOk ? '‚úÖ' : '‚ö†Ô∏è'} ${
                                                                spot.intelligence.populationDensity.density === 'high' ? 'Urban' :
                                                                spot.intelligence.populationDensity.density === 'medium' ? 'Suburban' : 'Rural'
                                                            }${hasWaiver && needsWaiver ? ' (Waiver ‚úì)' : ''}
                                                        </span>`;
                                                    })()}
                                                ` : ''}
                                                ${spot.intelligence.obstacles ? `
                                                    <span style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: ${
                                                        spot.intelligence.obstacles.risk === 'low' ? '#d1fae5' :
                                                        spot.intelligence.obstacles.risk === 'medium' ? '#fef3c7' : '#fee2e2'
                                                    }; color: ${
                                                        spot.intelligence.obstacles.risk === 'low' ? '#065f46' :
                                                        spot.intelligence.obstacles.risk === 'medium' ? '#92400e' : '#991b1b'
                                                    }; font-weight: 600;"
                                                    title="${spot.intelligence.obstacles.obstacles && spot.intelligence.obstacles.obstacles.length > 0 ?
                                                        `Closest: ${spot.intelligence.obstacles.obstacles[0].type}${spot.intelligence.obstacles.obstacles[0].name ? ' (' + spot.intelligence.obstacles.obstacles[0].name + ')' : ''} at ${spot.intelligence.obstacles.obstacles[0].distance} ft` :
                                                        `${spot.intelligence.obstacles.count} obstacles within 500ft`}">
                                                        ${
                                                            spot.intelligence.obstacles.risk === 'low' ? '‚úÖ' :
                                                            spot.intelligence.obstacles.risk === 'medium' ? '‚ö†Ô∏è' : 'üö´'
                                                        }
                                                        ${spot.intelligence.obstacles.count} Obstacles
                                                    </span>
                                                ` : ''}
                                                ${spot.airspace ? `
                                                    <span style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: ${
                                                        spot.airspace.status === 'clear' ? '#d1fae5' :
                                                        spot.airspace.status === 'caution' ? '#fef3c7' : '#fee2e2'
                                                    }; color: ${
                                                        spot.airspace.status === 'clear' ? '#065f46' :
                                                        spot.airspace.status === 'caution' ? '#92400e' : '#991b1b'
                                                    }; font-weight: 600;">
                                                        ${
                                                            spot.airspace.status === 'clear' ? '‚úàÔ∏è‚úÖ' :
                                                            spot.airspace.status === 'caution' ? '‚úàÔ∏è‚ö†Ô∏è' : '‚úàÔ∏èüö´'
                                                        }
                                                        ${spot.airspace.status === 'clear' ? 'Clear Airspace' :
                                                          spot.airspace.status === 'caution' ? 'Airspace Caution' : 'Aircraft Nearby'}
                                                    </span>
                                                ` : ''}
                                                ${spot.faaAirspace ? `
                                                    <span style="display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: ${
                                                        spot.faaAirspace.class === 'G' ? '#d1fae5' :
                                                        spot.faaAirspace.class === 'E' ? '#dbeafe' :
                                                        spot.faaAirspace.laancRequired ? '#fee2e2' : '#fef3c7'
                                                    }; color: ${
                                                        spot.faaAirspace.class === 'G' ? '#065f46' :
                                                        spot.faaAirspace.class === 'E' ? '#1e3a8a' :
                                                        spot.faaAirspace.laancRequired ? '#991b1b' : '#92400e'
                                                    }; font-weight: 600;">
                                                        ${spot.faaAirspace.laancRequired ? 'üèõÔ∏è‚ö†Ô∏è' : 'üèõÔ∏è‚úÖ'}
                                                        Class ${spot.faaAirspace.class}${spot.faaAirspace.laancRequired ? ' (LAANC)' : ''}
                                                    </span>
                                                ` : ''}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    ` : ''}
                `;
            }

            function renderSpotDetail() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return '';

                const riskScore = getAdjustedRiskScore(spot);
                const isFavorite = state.favorites.includes(spot.id);

                return `
                    <button class="back-button" id="backBtn">‚Üê Back</button>

                    <div class="card">
                        <div style="position: relative;">
                            <img src="${spot.imageUrl}" alt="${spot.name}" style="width: 100%; height: 200px; object-fit: cover; border-radius: 12px; margin-bottom: 20px;">
                            <button class="favorite-star ${isFavorite ? 'active' : ''}"
                                    style="top: 15px; right: 15px;" data-spot-id="${spot.id}" id="detailFavBtn">
                                ${isFavorite ? '‚òÖ' : '‚òÜ'}
                            </button>
                        </div>

                        <h2 style="font-size: 20px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            ${spot.name}
                        </h2>

                        <div style="background: #e8f4f8; border-left: 4px solid #00d4ff; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="font-size: 14px; font-weight: 700; color: #0099cc; margin-bottom: 8px;">üéØ Flight Instructions</h4>
                            <p style="font-size: 13px; color: #666;">${spot.flightInstructions}</p>
                        </div>

                        ${spot.x10Advantage ? `
                            <div style="background: #f0e8ff; border-left: 4px solid #6a11cb; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <h4 style="font-size: 14px; font-weight: 700; color: #6a11cb; margin-bottom: 8px;">‚ú® X10 Advantage</h4>
                                <p style="font-size: 13px; color: #666;">${spot.x10Advantage}</p>
                            </div>
                        ` : ''}

                        ${spot.intelligence && spot.scoreBreakdown ? `
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 15px;">
                                <h3 style="font-size: 16px; font-weight: 700; margin: 0 0 15px 0;">üõ©Ô∏è Flight Viability Score: ${Math.round(spot.scoreBreakdown.legal + spot.scoreBreakdown.accessibility + spot.scoreBreakdown.safety + spot.scoreBreakdown.photoQuality)}/100</h3>

                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 15px;">
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Legal Viability</div>
                                        <div style="font-size: 20px; font-weight: 700;">${Math.round(spot.scoreBreakdown.legal)}<span style="font-size: 12px; opacity: 0.8;">/25</span></div>
                                    </div>
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Accessibility</div>
                                        <div style="font-size: 20px; font-weight: 700;">${Math.round(spot.scoreBreakdown.accessibility)}<span style="font-size: 12px; opacity: 0.8;">/25</span></div>
                                    </div>
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Safety</div>
                                        <div style="font-size: 20px; font-weight: 700;">${Math.round(spot.scoreBreakdown.safety)}<span style="font-size: 12px; opacity: 0.8;">/20</span></div>
                                    </div>
                                    <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; backdrop-filter: blur(10px);">
                                        <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">Photo Quality</div>
                                        <div style="font-size: 20px; font-weight: 700;">${Math.round(spot.scoreBreakdown.photoQuality)}<span style="font-size: 12px; opacity: 0.8;">/30</span></div>
                                    </div>
                                </div>

                                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; font-size: 13px; line-height: 1.6;">
                                    ${spot.intelligence.access ? `
                                        <div style="margin-bottom: 10px;">
                                            <strong>${
                                                spot.intelligence.access.status === 'accessible' ? '‚úÖ' :
                                                spot.intelligence.access.status === 'permit_required' ? '‚ö†Ô∏è' :
                                                spot.intelligence.access.status === 'restricted' ? 'üö´' : '‚ùì'
                                            } Access:</strong> ${spot.intelligence.access.reason}
                                        </div>
                                    ` : ''}
                                    ${spot.intelligence.populationDensity ? `
                                        <div style="margin-bottom: 10px;">
                                            <strong>${(() => {
                                                const hasWaiver = state.userProfile.waivers.some(w => w.type === 'over_people');
                                                const needsWaiver = spot.intelligence.populationDensity.requiresWaiver;
                                                return !needsWaiver || hasWaiver ? '‚úÖ' : '‚ö†Ô∏è';
                                            })()} Population:</strong> ${spot.intelligence.populationDensity.reason}
                                        </div>
                                    ` : ''}
                                    ${spot.intelligence.obstacles ? `
                                        <div>
                                            <strong>${
                                                spot.intelligence.obstacles.risk === 'low' ? '‚úÖ' :
                                                spot.intelligence.obstacles.risk === 'medium' ? '‚ö†Ô∏è' : 'üö´'
                                            } Obstacles:</strong> ${spot.intelligence.obstacles.count} detected within 500ft${
                                                spot.intelligence.obstacles.types.length > 0 ? ` (${spot.intelligence.obstacles.types.join(', ')})` : ''
                                            }
                                            ${spot.intelligence.obstacles.obstacles && spot.intelligence.obstacles.obstacles.length > 0 ? `
                                                <div style="margin-top: 8px; padding-left: 16px; font-size: 12px; color: #666;">
                                                    ${spot.intelligence.obstacles.obstacles.slice(0, 5).map(obs => `
                                                        <div style="margin-bottom: 4px;">
                                                            ‚Ä¢ ${obs.type}${obs.name ? ` (${obs.name})` : ''} - ${obs.distance} ft away
                                                        </div>
                                                    `).join('')}
                                                    ${spot.intelligence.obstacles.obstacles.length > 5 ? `
                                                        <div style="margin-top: 4px; font-style: italic;">
                                                            +${spot.intelligence.obstacles.obstacles.length - 5} more...
                                                        </div>
                                                    ` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <button class="btn" id="savePlanBtn" style="margin-bottom: 15px;">
                            üìÖ Save Flight Plan
                        </button>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin-bottom: 12px;">‚ö†Ô∏è Risk Assessment - ${riskScore}/100</h3>
                        ${renderRiskCategories()}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">‚úàÔ∏è Airspace Status</h3>
                        ${spot.airspace ? `
                            <div class="risk-category" style="border-left: 3px solid ${
                                spot.airspace.status === 'clear' ? '#28a745' :
                                spot.airspace.status === 'caution' ? '#ffc107' : '#dc3545'
                            };">
                                <div style="margin-bottom: 10px;">
                                    <strong>Status:</strong>
                                    <span style="color: ${
                                        spot.airspace.status === 'clear' ? '#28a745' :
                                        spot.airspace.status === 'caution' ? '#f59e0b' : '#dc3545'
                                    }; font-weight: 700;">
                                        ${spot.airspace.status === 'clear' ? '‚úÖ CLEAR' :
                                          spot.airspace.status === 'caution' ? '‚ö†Ô∏è CAUTION' : 'üö´ RESTRICTED'}
                                    </span>
                                </div>
                                <div style="margin-bottom: 10px;"><strong>Details:</strong> ${spot.airspace.message}</div>
                                ${spot.airspace.aircraft && spot.airspace.aircraft.length > 0 ? `
                                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                                        <strong>Nearby Aircraft (${spot.airspace.aircraft.length}):</strong>
                                        <div style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                                            ${spot.airspace.aircraft.slice(0, 5).map(ac => `
                                                <div style="padding: 8px; margin-bottom: 8px; background: #f9fafb; border-radius: 6px; font-size: 13px;">
                                                    <div style="font-weight: 600; color: #1e3c72;">${ac.callsign}</div>
                                                    <div style="color: #666; margin-top: 4px;">
                                                        üìç ${ac.spotDistanceMiles} mi away ‚Ä¢
                                                        ‚¨ÜÔ∏è ${ac.altitudeFt.toLocaleString()} ft ‚Ä¢
                                                        ‚û°Ô∏è ${ac.velocityKnots} kt
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : `
                            <div class="risk-category">
                                <div style="margin-bottom: 10px;"><strong>Class:</strong> ${spot.airspaceDetails.class}</div>
                                <div style="margin-bottom: 10px;"><strong>Ceiling:</strong> ${spot.airspaceDetails.ceiling}</div>
                                <div style="margin-bottom: 10px;"><strong>LAANC Required:</strong> ${spot.airspaceDetails.laancRequired}</div>
                                <div><strong>Nearest Airport:</strong> ${spot.airspaceDetails.nearestAirport}</div>
                            </div>
                        `}

                        ${spot.faaAirspace ? `
                            <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üèõÔ∏è FAA Airspace Classification</h3>
                            <div class="risk-category" style="border-left: 3px solid ${
                                spot.faaAirspace.class === 'G' ? '#28a745' :
                                spot.faaAirspace.class === 'E' ? '#3b82f6' :
                                spot.faaAirspace.laancRequired ? '#dc3545' : '#f59e0b'
                            };">
                                <div style="margin-bottom: 10px;">
                                    <strong>Airspace Class:</strong>
                                    <span style="color: ${
                                        spot.faaAirspace.class === 'G' ? '#28a745' :
                                        spot.faaAirspace.class === 'E' ? '#3b82f6' :
                                        spot.faaAirspace.laancRequired ? '#dc3545' : '#f59e0b'
                                    }; font-weight: 700; font-size: 18px;">
                                        Class ${spot.faaAirspace.class}
                                    </span>
                                </div>
                                <div style="margin-bottom: 10px;"><strong>Name:</strong> ${spot.faaAirspace.name}</div>
                                ${spot.faaAirspace.airport ? `
                                    <div style="margin-bottom: 10px;"><strong>Airport:</strong> ${spot.faaAirspace.airport}</div>
                                ` : ''}
                                <div style="margin-bottom: 10px;">
                                    <strong>Altitude Range:</strong>
                                    ${spot.faaAirspace.floor} ${spot.faaAirspace.floorUnit} ${spot.faaAirspace.floorReference} to
                                    ${spot.faaAirspace.ceiling ? `${spot.faaAirspace.ceiling} ${spot.faaAirspace.ceilingUnit} ${spot.faaAirspace.ceilingReference}` : 'unlimited'}
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <strong>LAANC Authorization:</strong>
                                    <span style="color: ${spot.faaAirspace.laancRequired ? '#dc3545' : '#28a745'}; font-weight: 700;">
                                        ${spot.faaAirspace.laancRequired ? '‚ö†Ô∏è REQUIRED' : '‚úÖ NOT REQUIRED'}
                                    </span>
                                </div>
                                ${spot.faaAirspace.restrictions && spot.faaAirspace.restrictions.length > 0 ? `
                                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e5e7eb;">
                                        <strong>Requirements & Restrictions:</strong>
                                        <ul style="margin: 10px 0 0 20px; font-size: 13px; color: #666; line-height: 1.6;">
                                            ${spot.faaAirspace.restrictions.map(r => `<li>${r}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üìã Regulations</h3>
                        ${spot.regulations.map(reg => `
                            <div class="risk-category" style="border-left: 3px solid ${reg.compliant ? '#28a745' : '#dc3545'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${reg.authority}</div>
                                <div style="font-size: 13px; color: #666;">${reg.rule}</div>
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üå§ Weather Conditions</h3>
                        <div class="risk-category">
                            <div style="margin-bottom: 8px;"><strong>Conditions:</strong> ${spot.weatherConditions.conditions}</div>
                            <div style="margin-bottom: 8px;"><strong>Wind:</strong> ${spot.weatherConditions.wind}</div>
                            <div style="margin-bottom: 8px;"><strong>Visibility:</strong> ${spot.weatherConditions.visibility}</div>
                            <div><strong>Temperature:</strong> ${spot.weatherConditions.temp}</div>
                        </div>
                    </div>
                `;
            }

            function renderRiskCategories() {
                const categories = [
                    { name: 'Airspace Clearance', score: 95, desc: 'No restrictions, LAANC approved' },
                    { name: 'Weather Conditions', score: 90, desc: 'Favorable winds, clear visibility' },
                    { name: 'Regulatory Compliance', score: 100, desc: 'All permits and waivers in place' },
                    { name: 'Environmental Hazards', score: 85, desc: 'Minimal obstacles, safe terrain' }
                ];

                return categories.map(cat => {
                    const scoreClass = cat.score >= 75 ? 'score-high' : cat.score >= 50 ? 'score-medium' : 'score-low';
                    return `
                        <div class="risk-category">
                            <div class="risk-cat-header">
                                <span class="risk-cat-name">${cat.name}</span>
                                <span class="risk-cat-score ${scoreClass}">${cat.score}</span>
                            </div>
                            <div class="risk-cat-bar">
                                <div class="risk-cat-fill" style="width: ${cat.score}%"></div>
                            </div>
                            <p class="risk-cat-desc">${cat.desc}</p>
                        </div>
                    `;
                }).join('');
            }

            function renderUpcoming() {
                if (state.upcomingFlights.length === 0) {
                    return `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <p class="empty-state-text">No upcoming flights scheduled.<br>Save a flight plan from the Trip Planner!</p>
                        </div>
                    `;
                }

                const sortedFlights = [...state.upcomingFlights].sort((a, b) =>
                    new Date(a.dateTime) - new Date(b.dateTime)
                );

                return `
                    <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                        üìÖ Upcoming Flights (${sortedFlights.length})
                    </h2>
                    ${sortedFlights.map(flight => {
                        const dt = new Date(flight.dateTime);
                        const formattedDate = dt.toLocaleString('en-US', {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });

                        return `
                            <div class="flight-card">
                                <div class="flight-header">
                                    <div>
                                        <div class="flight-location">${flight.spotName}</div>
                                        <div class="flight-date">${formattedDate}</div>
                                    </div>
                                </div>
                                <div class="flight-details">
                                    ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                </div>
                                <div style="display: flex; gap: 10px; margin-top: 12px;">
                                    <button class="btn-small" data-action="viewspot" data-spot-id="${flight.spotId}">
                                        View Spot
                                    </button>
                                    <button class="btn-small secondary" data-action="markflown" data-flight-id="${flight.id}">
                                        Mark as Flown
                                    </button>
                                    <button class="btn-small danger" data-action="delete" data-flight-id="${flight.id}">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }

            function renderHistory() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü°' : 'üî¥';

                return `
                    <div class="card">
                        ${state.syncMessage ? `
                            <div class="sync-message ${state.syncMessage.type}">
                                ${state.syncMessage.type === 'info' ? '<span class="spinner"></span>' : ''}
                                ${state.syncMessage.text}
                            </div>
                        ` : ''}

                        <div class="connection-status">
                            <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                            <div class="status-text">
                                <strong>${status} ${state.syncSettings.connectionStatus === 'connected' ? 'Connected' : state.syncSettings.connectionStatus === 'checking' ? 'Checking...' : 'Not Connected'}</strong>
                                ${state.syncSettings.lastSync ? `<br>Synced: ${formatDate(state.syncSettings.lastSync)}` : ''}
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button class="btn" id="syncNowBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Syncing...' : '‚òÅÔ∏è Sync Flights'}
                            </button>
                            <button class="btn" id="clearAndResyncBtn" style="background: #e74c3c;" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                üóëÔ∏è Clear & Re-sync
                            </button>
                        </div>
                    </div>

                    ${state.flights.length > 0 ? `
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            Flight History (${state.flights.length})
                        </h2>
                        ${state.flights.slice().sort((a, b) => {
                            // Sort by date descending (newest first)
                            const dateA = new Date(a.created_at || a.date);
                            const dateB = new Date(b.created_at || b.date);
                            return dateB - dateA;
                        }).map(flight => {
                            // V7.1 Debug: Log flight sync status
                            console.log('Flight:', flight.id, 'synced:', flight.synced, 'type:', flight.type);
                            const rating = state.ratings.find(r => r.flightId === flight.id);

                            const flightName = generateFlightName(flight);

                            return `
                                <div class="flight-card" id="flight-card-${flight.id}">
                                    <div class="flight-header">
                                        <div>
                                            <div class="flight-location">
                                                ${flightName}
                                                ${rating ? '<span class="badge rated">‚òÖ Rated</span>' : '<span class="badge pending">‚è≥ Rate This</span>'}
                                            </div>
                                            <div class="flight-date">${formatDate(flight.created_at || flight.date)}</div>
                                        </div>
                                        <div class="flight-badge ${flight.type === 'manual' ? 'badge-manual' : 'badge-synced'}">
                                            ${flight.type === 'manual' ? '‚úèÔ∏è Manual' : '‚òÅÔ∏è Synced'}
                                        </div>
                                    </div>

                                    <!-- V10.2: Weather Data -->
                                    ${flight.weather && !flight.weather.unavailable ? `
                                        <div style="margin: 12px 0; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; color: white;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                                <div style="font-weight: 600; font-size: 14px;">
                                                    ‚òÅÔ∏è Flight Weather Conditions
                                                </div>
                                                <div style="background: ${flight.weather.flyingConditions?.riskColor === 'green' ? '#28a745' : flight.weather.flyingConditions?.riskColor === 'yellow' ? '#ffc107' : '#dc3545'}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                                    ${flight.weather.flyingConditions?.recommendation || 'N/A'}
                                                </div>
                                            </div>
                                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 13px;">
                                                <div>
                                                    <div style="opacity: 0.9; font-size: 11px;">Temperature</div>
                                                    <div style="font-weight: 600; font-size: 16px;">${flight.weather.temp}${flight.weather.tempUnit}</div>
                                                </div>
                                                <div>
                                                    <div style="opacity: 0.9; font-size: 11px;">Wind</div>
                                                    <div style="font-weight: 600; font-size: 16px;">${flight.weather.windSpeed} ${flight.weather.windSpeedUnit}</div>
                                                </div>
                                                <div>
                                                    <div style="opacity: 0.9; font-size: 11px;">Visibility</div>
                                                    <div style="font-weight: 600; font-size: 16px;">${flight.weather.visibility || 'N/A'} ${flight.weather.visibility ? flight.weather.visibilityUnit : ''}</div>
                                                </div>
                                                <div>
                                                    <div style="opacity: 0.9; font-size: 11px;">Conditions</div>
                                                    <div style="font-weight: 600; font-size: 14px; text-transform: capitalize;">${flight.weather.description || flight.weather.conditions}</div>
                                                </div>
                                            </div>
                                            ${flight.weather.flyingConditions?.warnings?.length > 0 ? `
                                                <div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.2); border-radius: 6px; font-size: 12px;">
                                                    ‚ö†Ô∏è ${flight.weather.flyingConditions.warnings.join(' ‚Ä¢ ')}
                                                </div>
                                            ` : ''}
                                            ${flight.weather.isHistorical ? `
                                                <div style="margin-top: 8px; font-size: 11px; opacity: 0.8; text-align: right;">
                                                    üìä Historical data from ${flight.weather.daysAgo} days ago
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : flight.weather?.unavailable ? `
                                        <div style="margin: 12px 0; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #6c757d;">
                                            <div style="font-size: 13px; color: #666;">
                                                üìä ${flight.weather.message || 'Weather data not available for this flight'}
                                            </div>
                                        </div>
                                    ` : ''}

                                    <div class="flight-details">
                                        ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                    </div>

                                    <!-- Telemetry Stats (for synced flights) -->
                                    ${flight.synced ? `
                                        <details style="margin-top: 12px;" class="telemetry-details" data-flight-id="${flight.id}">
                                            <summary style="cursor: pointer; padding: 8px 12px; background: #f0f4f8; border-radius: 6px; font-weight: 600; color: #1e3c72; user-select: none;">
                                                üìä Flight Telemetry ${flight.telemetry?.stats ? '' : '(Click to load)'}
                                            </summary>
                                            <div style="padding: 12px; background: #f8f9fa; border-radius: 6px; margin-top: 8px;">
                                                ${flight.telemetry?.stats ? renderAllTelemetryStats(flight.telemetry.stats) : `
                                                <div style="text-align: center; padding: 20px; color: #666;">
                                                    <div class="telemetry-loading-${flight.id}" style="display: none;">
                                                        <span class="spinner"></span> Loading telemetry data...
                                                    </div>
                                                    <div class="telemetry-placeholder-${flight.id}">
                                                        Click "View Flight Path" to load telemetry stats
                                                    </div>
                                                </div>
                                                `}
                                            </div>
                                        </details>

                                        <!-- Inline Flight Path Map -->
                                        <details style="margin-top: 12px;" class="map-details" data-flight-id="${flight.id}">
                                            <summary style="cursor: pointer; padding: 8px 12px; background: #f0f4f8; border-radius: 6px; font-weight: 600; color: #1e3c72; user-select: none;">
                                                üó∫Ô∏è Flight Path Map ${flight.telemetry?.track ? '' : '(Click to load)'}
                                            </summary>
                                            <div style="padding: 12px; background: #f8f9fa; border-radius: 6px; margin-top: 8px;">
                                                <div id="inline-map-${flight.id}" style="height: 400px; width: 100%; border-radius: 6px; overflow: hidden;">
                                                    <div style="text-align: center; padding: 180px 20px; color: #666;">
                                                        Click to load map...
                                                    </div>
                                                </div>
                                                ${flight.telemetry?.track ? `
                                                <div style="margin-top: 8px; text-align: center;">
                                                    <button class="btn-small" data-action="openFullMap" data-flight-id="${flight.id}">
                                                        üîç Open Full Screen Map
                                                    </button>
                                                </div>
                                                ` : ''}
                                            </div>
                                        </details>
                                    ` : ''}

                                    ${!rating ? `
                                        <div style="display: flex; gap: 10px; margin-top: 12px;">
                                            <button class="btn-small" data-action="rate" data-flight-id="${flight.id}">
                                                ‚≠ê Rate This Flight
                                            </button>
                                        </div>
                                    ` : `
                                        <div style="margin-top: 12px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                                            <div style="font-size: 13px; color: #666;">
                                                <strong>Your Rating:</strong> ${rating.descAccuracy}‚≠ê Description | ${rating.shotTypeMatch}‚≠ê Shots | ${rating.accessibility}‚≠ê Access
                                            </div>
                                        </div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    ` : `
                        <div class="empty-state">
                            <div class="empty-state-icon">‚òÅÔ∏è</div>
                            <p class="empty-state-text">No flights yet.<br>Sync your Skydio Cloud flights to see them here.</p>
                        </div>
                    `}
                `;
            }

            function renderSettings() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢ Connected' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü° Checking...' : 'üî¥ Not Connected';

                return `
                    <div class="card">
                        <div class="settings-section">
                            <div class="settings-section-title">Cloud Sync</div>
                            <div class="connection-status">
                                <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                                <div class="status-text">
                                    <strong>${status}</strong>
                                    ${state.syncSettings.lastSync ? `<br>Last synced: ${formatDate(state.syncSettings.lastSync)}` : '<br>Never synced'}
                                </div>
                            </div>
                            <button class="btn" id="syncSettingsBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Checking...' : '‚òÅÔ∏è Sync Now'}
                            </button>
                            <button class="btn" id="fetchWeatherBtn" style="margin-top: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                üå§Ô∏è Fetch Weather for Flights
                            </button>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                ${state.flights.filter(f => f.weather).length} of ${state.flights.length} flights have weather data
                                ${state.flights.filter(f => f.telemetry?.track).length > 0 ? `<br>${state.flights.filter(f => f.telemetry?.track).length} flights have GPS data loaded` : '<br>‚ö†Ô∏è Tip: Load flight telemetry first (click "View Flight Path" in History)'}
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="settings-section-title">üó∫Ô∏è Google Places Integration (V10.0)</div>
                            <div class="sync-info" style="margin-bottom: 15px;">
                                ${state.syncSettings?.workerUrl ?
                                    `<div style="background: #d4edda; padding: 12px; border-radius: 8px; border-left: 4px solid #28a745;">
                                        <strong>‚úÖ Google Places via Cloudflare Worker</strong><br>
                                        Searching comprehensive location types via your worker:<br>
                                        <small style="color: #666; display: block; margin-top: 8px;">
                                            ‚Ä¢ Nature: parks, beaches, lakes, campgrounds<br>
                                            ‚Ä¢ Urban: landmarks, stadiums, museums, universities<br>
                                            ‚Ä¢ Architecture: churches, bridges, observation towers<br>
                                            ‚Ä¢ Water: marinas, harbors, waterfronts<br>
                                            ‚Ä¢ Infrastructure: airports, train stations<br><br>
                                            Worker handles API key securely (no CORS issues)
                                        </small>
                                    </div>` :
                                    `<div style="background: #fff3cd; padding: 12px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 10px;">
                                        <strong>‚ö†Ô∏è Worker URL Required</strong><br>
                                        DroneScout uses Google Places via Cloudflare Worker to find verified drone spots.<br><br>
                                        <strong>Setup:</strong>
                                        <ol style="margin: 10px 0 10px 20px; font-size: 13px;">
                                            <li>Deploy cloudflare-worker.js to Cloudflare Workers</li>
                                            <li>Set GOOGLE_MAPS_API_KEY in worker environment</li>
                                            <li>Enter Worker URL in "Advanced Settings" below</li>
                                        </ol>
                                        <small style="color: #666;">
                                            Without worker configured, DroneScout falls back to OpenStreetMap (lower quality data).
                                        </small>
                                    </div>`
                                }
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="advanced-toggle" id="advancedToggle">
                                <span>‚öôÔ∏è Advanced Settings</span>
                                <span>‚ñ∂</span>
                            </div>
                            <div class="advanced-content" id="advancedContent">
                                <div class="input-group">
                                    <label>Worker URL</label>
                                    <input type="text" id="workerUrlInput" placeholder="https://..." value="${state.syncSettings.workerUrl}">
                                </div>
                                <div class="sync-info">
                                    Change only if you're self-hosting the Cloudflare Worker. Most users should leave this unchanged.
                                </div>
                                <button class="btn-secondary" id="updateWorkerBtn">Update URL</button>
                                <button class="btn-secondary" id="testConnectionBtn">Test Connection</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="advanced-toggle" id="profileToggle">
                                <span>üë§ Pilot Profile (V10.0)</span>
                                <span>‚ñ∂</span>
                            </div>
                            <div class="advanced-content" id="profileContent">
                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 0 0 10px 0;">Certifications</h4>
                                    <div class="checkbox-group">
                                        <label>
                                            <input type="checkbox" id="part107Checkbox" ${state.userProfile.certifications.part107 ? 'checked' : ''}>
                                            Part 107 Certified
                                        </label>
                                    </div>
                                    ${state.userProfile.certifications.part107 ? `
                                        <div class="input-group" style="margin-top: 10px;">
                                            <label>Expiry Date</label>
                                            <input type="date" id="part107ExpiryInput" value="${state.userProfile.certifications.part107Expiry || ''}">
                                        </div>
                                    ` : ''}
                                    <div class="checkbox-group" style="margin-top: 10px;">
                                        <label>
                                            <input type="checkbox" id="trustCheckbox" ${state.userProfile.certifications.trust ? 'checked' : ''}>
                                            TRUST Certified
                                        </label>
                                    </div>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Part 107 Waivers</h4>
                                    <p style="font-size: 12px; color: #666; margin-bottom: 12px;">Select waivers granted under your Part 107 certificate:</p>
                                    <div style="display: flex; flex-direction: column; gap: 8px;">
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="checkbox" id="waiverOverPeople"
                                                ${state.userProfile.waivers.some(w => w.type === 'over_people') ? 'checked' : ''}>
                                            <span>Operations Over People (Part 107.39)</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="checkbox" id="waiverNightOps"
                                                ${state.userProfile.waivers.some(w => w.type === 'night_operations') ? 'checked' : ''}>
                                            <span>Night Operations (Part 107.29)</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="checkbox" id="waiverBVLOS"
                                                ${state.userProfile.waivers.some(w => w.type === 'beyond_vlos') ? 'checked' : ''}>
                                            <span>Beyond Visual Line of Sight (Part 107.31)</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="checkbox" id="waiverMovingVehicle"
                                                ${state.userProfile.waivers.some(w => w.type === 'moving_vehicle') ? 'checked' : ''}>
                                            <span>Operations from Moving Vehicle (Part 107.25)</span>
                                        </label>
                                    </div>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Your Drones</h4>
                                    <div id="dronesList">
                                        ${state.userProfile.drones.map((drone, idx) => `
                                            <div class="drone-item" data-idx="${idx}">
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <div>
                                                        <strong>${drone.name}</strong>
                                                        <div style="font-size: 12px; color: #666;">
                                                            ${drone.weight_lbs} lbs
                                                            ${drone.hasParachute ? ' ‚Ä¢ ü™Ç Parachute' : ''}
                                                            ${drone.hasRemoteID ? ' ‚Ä¢ üì° Remote ID' : ''}
                                                        </div>
                                                    </div>
                                                    <button class="btn-secondary btn-small" onclick="removeDrone(${idx})">Remove</button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button class="btn-secondary" id="addDroneBtn" style="margin-top: 10px;">+ Add Drone</button>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Search Preferences</h4>
                                    <div class="input-group">
                                        <label>Search Radius: ${state.userProfile.preferences.searchRadius_mi} mi (~${Math.round(state.userProfile.preferences.searchRadius_mi * 2.5)} min drive)</label>
                                        <input type="range" id="searchRadiusSlider" min="5" max="25" step="5" value="${state.userProfile.preferences.searchRadius_mi}">
                                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: #888;">
                                            <span>5 mi</span>
                                            <span>15 mi</span>
                                            <span>25 mi</span>
                                        </div>
                                    </div>
                                    <div class="input-group" style="margin-top: 15px;">
                                        <label>Experience Level</label>
                                        <select id="experienceSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                                            <option value="beginner" ${state.userProfile.preferences.experience === 'beginner' ? 'selected' : ''}>Beginner</option>
                                            <option value="intermediate" ${state.userProfile.preferences.experience === 'intermediate' ? 'selected' : ''}>Intermediate</option>
                                            <option value="advanced" ${state.userProfile.preferences.experience === 'advanced' ? 'selected' : ''}>Advanced</option>
                                        </select>
                                    </div>
                                    <div class="checkbox-group" style="margin-top: 10px;">
                                        <label>
                                            <input type="checkbox" id="avoidCrowdsCheckbox" ${state.userProfile.preferences.avoidCrowds ? 'checked' : ''}>
                                            Avoid crowded areas (if no over-people waiver)
                                        </label>
                                    </div>
                                </div>

                                <button class="btn" id="saveProfileBtn" style="margin-top: 15px;">üíæ Save Profile</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="settings-section-title">About</div>
                            <p style="font-size: 14px; color: #666; line-height: 1.6;">
                                DroneScout v10.0 - Intelligent Recommendations<br>
                                Skydio X10 Optimized<br>
                                Part 107 Ready<br>
                                With Google Street View, OpenWeather & OSM
                            </p>
                        </div>
                    </div>
                `;
            }

            function renderAnalytics() {
                const totalFlights = state.flights.length;
                const totalDuration = state.flights.reduce((sum, f) => sum + (f.duration || 0), 0);
                const avgRating = state.ratings.length > 0
                    ? (state.ratings.reduce((sum, r) => sum + ((r.descAccuracy + r.shotTypeMatch + r.accessibility) / 3), 0) / state.ratings.length).toFixed(1)
                    : 'N/A';
                const favSpots = state.favorites.length;

                return `
                    <div class="card">
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            üìä Flight Statistics
                        </h2>

                        <div class="stat-grid">
                            <div class="stat-box">
                                <div class="stat-value">${totalFlights}</div>
                                <div class="stat-label">Total Flights</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${Math.round(totalDuration / 60)}m</div>
                                <div class="stat-label">Flight Time</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${avgRating}‚≠ê</div>
                                <div class="stat-label">Avg Rating</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${favSpots}</div>
                                <div class="stat-label">Favorite Spots</div>
                            </div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Flight Activity
                        </h3>
                        <div class="chart-container">
                            <canvas id="flightChart"></canvas>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Rating Breakdown
                        </h3>
                        <div class="chart-container">
                            <canvas id="ratingChart"></canvas>
                        </div>

                        <button class="export-btn" id="exportDataBtn">üì• Export Data (CSV)</button>
                    </div>
                `;
            }

            function renderHelp() {
                return `
                    <div class="card">
                        <div class="help-section">
                            <h3>üöÅ Getting Started</h3>
                            <p>DroneScout helps you plan drone flights with the Skydio X10. Here's how to use each tab:</p>
                            <ul>
                                <li><strong>Trip Planner:</strong> Enter a destination to find scenic spots with risk assessments</li>
                                <li><strong>Upcoming:</strong> View and manage scheduled flights</li>
                                <li><strong>History:</strong> Sync completed flights from Skydio Cloud</li>
                                <li><strong>Settings:</strong> Configure cloud sync and preferences</li>
                                <li><strong>Analytics:</strong> View flight statistics and trends</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚≠ê Using the Learning System</h3>
                            <p>Rate your flights to improve recommendations:</p>
                            <ul>
                                <li>After each flight, rate description accuracy, shot quality, and accessibility</li>
                                <li>The app learns your preferences over time</li>
                                <li>Spots matching your style get higher scores</li>
                                <li>Use favorites to save best locations</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚òÅÔ∏è Cloud Sync Setup</h3>
                            <p>Connect to Skydio Cloud via Cloudflare Worker:</p>
                            <ul>
                                <li>Deploy the provided Cloudflare Worker with your Skydio API token</li>
                                <li>Enter Worker URL in Settings tab</li>
                                <li>Click "Sync Now" to import flights</li>
                                <li>Synced flights show telemetry and media</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚ö†Ô∏è Risk Scoring</h3>
                            <p>Each spot shows a risk score (1-100) based on:</p>
                            <ul>
                                <li><strong>Airspace:</strong> FAA restrictions and LAANC requirements</li>
                                <li><strong>Weather:</strong> Wind, visibility, and conditions</li>
                                <li><strong>Regulations:</strong> Local, state, and federal rules</li>
                                <li><strong>Hazards:</strong> Obstacles, terrain, and population density</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üéØ X10 Optimization</h3>
                            <p>Spots are optimized for Skydio X10 capabilities:</p>
                            <ul>
                                <li><strong>Nightsense:</strong> Enables twilight/blue hour flights</li>
                                <li><strong>Obstacle Avoidance:</strong> Safe navigation in complex environments</li>
                                <li><strong>BVLOS:</strong> Extended range operations (if certified)</li>
                                <li><strong>Autonomy:</strong> Advanced tracking and cinematics</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìã Regulatory Compliance</h3>
                            <p>Always follow FAA Part 107 rules:</p>
                            <ul>
                                <li>Valid Part 107 certification required</li>
                                <li>Maximum 400 ft AGL altitude</li>
                                <li>Visual line of sight (unless waiver)</li>
                                <li>LAANC authorization in controlled airspace</li>
                                <li>Check NOTAMs before every flight</li>
                                <li>Respect local ordinances and privacy</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìû Support</h3>
                            <p>For questions or issues:</p>
                            <ul>
                                <li>GitHub: github.com/yourusername/dronescout</li>
                                <li>Email: support@dronescout.app</li>
                                <li>Documentation: docs.dronescout.app</li>
                            </ul>
                        </div>
                    </div>
                `;
            }

            // Charts initialization
            function initCharts() {
                if (typeof Chart === 'undefined') return;

                // Flight activity chart
                const flightCanvas = document.getElementById('flightChart');
                if (flightCanvas) {
                    const ctx = flightCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
                            datasets: [{
                                label: 'Flights',
                                data: [2, 3, 4, 5],
                                borderColor: '#00d4ff',
                                backgroundColor: 'rgba(0, 212, 255, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }

                // Rating breakdown chart
                const ratingCanvas = document.getElementById('ratingChart');
                if (ratingCanvas) {
                    const ctx = ratingCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Description', 'Shot Quality', 'Accessibility'],
                            datasets: [{
                                label: 'Average Rating',
                                data: [4.2, 4.5, 3.8],
                                backgroundColor: ['#00d4ff', '#0099cc', '#1e3c72']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 5
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }
            }

            // Event handlers
            function attachEventListeners() {
                // Tab switching
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        state.currentTab = e.target.dataset.tab;
                        // Clear selected spot when switching tabs
                        state.selectedSpot = null;
                        render();
                    });
                });

                // V10.0: Enter key support for destination input
                const destinationInput = document.getElementById('destinationInput');
                if (destinationInput) {
                    destinationInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            const findSpotsBtn = document.getElementById('findSpotsBtn');
                            if (findSpotsBtn) {
                                findSpotsBtn.click();
                            }
                        }
                    });
                }

                // Find spots button with real location search
                const findSpotsBtn = document.getElementById('findSpotsBtn');
                if (findSpotsBtn) {
                    findSpotsBtn.addEventListener('click', async () => {
                        const input = document.getElementById('destinationInput');
                        if (input && input.value) {
                            state.destination = input.value;

                            // V10.0: Reset preferences to default 50-50 for new search
                            state.preferences = {
                                cityscape: 50,
                                nature: 50,
                                architecture: 50
                            };

                            // Show loading state
                            state.loadingSpots = true;
                            state.spots = []; // Clear previous spots
                            findSpotsBtn.disabled = true;
                            findSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';
                            render(); // Render skeleton cards

                            try {
                                // Step 1: Geocode the location
                                const location = await geocodeLocation(state.destination);

                                if (location) {
                                    // V6: Save destination coordinates for map centering
                                    state.destinationCoords = location;

                                    // V9.0: Save search center for preference ranking
                                    state.searchCenter = {
                                        lat: location.lat,
                                        lon: location.lng
                                    };

                                    // Step 2: Search for POIs near the location (Google Places ‚Üí OSM fallback)
                                    const pois = await searchForDroneSpots(location.lat, location.lng, null, location.displayName);

                                    if (pois && pois.length > 0) {
                                        // Success: Use real POI data
                                        state.spots = pois;
                                        console.log(`‚úÖ Found ${pois.length} real locations near ${location.displayName}`);
                                    } else {
                                        // No POIs found - show empty state
                                        console.warn('‚ö†Ô∏è No drone spots found in this area');
                                        state.spots = [];
                                        alert(`No drone spots found near ${location.displayName}. Try:\n‚Ä¢ Increasing search radius in Settings\n‚Ä¢ Searching a different location\n‚Ä¢ Looking for nearby parks or lakes`);
                                    }
                                } else {
                                    // Geocoding failed - show error
                                    console.error('‚ùå Geocoding failed for:', state.destination);
                                    state.destinationCoords = null;
                                    state.searchCenter = null;
                                    state.spots = [];
                                    alert(`Could not find location: "${state.destination}". Please try a different search.`);
                                }
                            } catch (error) {
                                // Error occurred - show error
                                console.error('‚ùå Location search error:', error);
                                state.destinationCoords = null;
                                state.searchCenter = null;
                                state.spots = [];
                                alert('Search error. Please check your connection and try again.');
                            } finally {
                                // Restore button and loading state
                                state.loadingSpots = false;
                                findSpotsBtn.disabled = false;
                                findSpotsBtn.textContent = 'Find Spots';
                                render();
                            }
                        }
                    });
                }

                // V10.0: Find spots near me button
                const findNearMeBtn = document.getElementById('findNearMeBtn');
                if (findNearMeBtn) {
                    findNearMeBtn.addEventListener('click', async () => {
                        if (!state.userLocation) {
                            alert('Please allow location access to find spots near you');
                            getUserLocation();
                            return;
                        }

                        // V10.0: Reset preferences to default 50-50 for new search
                        state.preferences = {
                            cityscape: 50,
                            nature: 50,
                            architecture: 50
                        };

                        // Show loading state
                        state.loadingSpots = true;
                        state.spots = [];
                        state.destination = 'My Current Location';
                        findNearMeBtn.disabled = true;
                        findNearMeBtn.innerHTML = '<span class="spinner"></span> Finding...';
                        render();

                        try {
                            // Use current location coordinates
                            state.destinationCoords = {
                                lat: state.userLocation.lat,
                                lng: state.userLocation.lng
                            };

                            state.searchCenter = {
                                lat: state.userLocation.lat,
                                lon: state.userLocation.lng
                            };

                            // Search for POIs near current location (Google Places ‚Üí OSM fallback)
                            const pois = await searchForDroneSpots(
                                state.userLocation.lat,
                                state.userLocation.lng,
                                null, // Use user profile radius
                                'Current Location'
                            );

                            if (pois && pois.length > 0) {
                                state.spots = pois;
                                console.log(`Found ${pois.length} spots near your location`);
                            } else {
                                console.log('No POIs found near you');
                                alert('No drone spots found near your location. Try a different area.');
                                state.spots = [];
                            }
                        } catch (error) {
                            console.error('Near me search error:', error);
                            alert('Error finding spots near you. Please try again.');
                            state.spots = [];
                        } finally {
                            state.loadingSpots = false;
                            findNearMeBtn.disabled = false;
                            findNearMeBtn.innerHTML = 'üìç Near Me';
                            render();
                        }
                    });
                }

                // Toggle favorites
                const toggleFavoritesBtn = document.getElementById('toggleFavoritesBtn');
                if (toggleFavoritesBtn) {
                    toggleFavoritesBtn.addEventListener('click', () => {
                        state.showFavoritesOnly = !state.showFavoritesOnly;
                        render();
                        // V6.1: Re-initialize map to show only filtered spots
                        if (state.spots.length > 0 && state.currentTab === 'planner') {
                            setTimeout(() => initMap(), 100);
                        }
                    });
                }

                // Toggle preferences
                const togglePreferencesBtn = document.getElementById('togglePreferences');
                if (togglePreferencesBtn) {
                    togglePreferencesBtn.addEventListener('click', () => {
                        state.showPreferences = !state.showPreferences;
                        render();
                    });
                }

                // Preference sliders (V10.0: Don't persist - reset to 50-50 on page load)
                ['cityscape', 'nature', 'architecture'].forEach(pref => {
                    const slider = document.getElementById(`${pref}Slider`);
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            state.preferences[pref] = parseInt(e.target.value);
                            // Don't save to storage - preferences reset on each page load
                            render();
                        });
                    }
                });

                // Favorite star buttons
                document.querySelectorAll('.favorite-star').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const spotId = e.currentTarget.dataset.spotId; // Keep as string for Foursquare IDs
                        const index = state.favorites.indexOf(spotId);
                        if (index > -1) {
                            state.favorites.splice(index, 1);
                        } else {
                            state.favorites.push(spotId);
                        }
                        saveToStorage('favorites', state.favorites);
                        render();
                    });
                });

                // Spot cards
                document.querySelectorAll('.spot-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('favorite-star')) {
                            const spotId = e.currentTarget.dataset.spotId; // Keep as string for Foursquare IDs
                            state.selectedSpot = spotId;
                            render();
                        }
                    });
                });

                // Back button
                const backBtn = document.getElementById('backBtn');
                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        state.selectedSpot = null;
                        render();
                    });
                }

                // Save flight plan
                const savePlanBtn = document.getElementById('savePlanBtn');
                if (savePlanBtn) {
                    savePlanBtn.addEventListener('click', () => {
                        showSavePlanModal();
                    });
                }

                // Upcoming flight actions
                document.querySelectorAll('[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        const flightId = e.target.dataset.flightId;
                        const spotId = e.target.dataset.spotId;

                        if (action === 'viewspot') {
                            state.currentTab = 'planner';
                            state.selectedSpot = spotId; // Keep as string for Foursquare IDs
                            render();
                        } else if (action === 'markflown') {
                            markFlightAsFlown(flightId);
                        } else if (action === 'delete') {
                            deleteUpcomingFlight(flightId);
                        } else if (action === 'rate') {
                            showRatingModal(flightId);
                        } else if (action === 'viewPath') {
                            viewFlightPath(flightId);
                        } else if (action === 'openFullMap') {
                            // Open full screen map in Planner tab
                            viewFlightPath(flightId, true); // true = open in planner tab
                        }
                    });
                });

                // Inline map handlers - load map when <details> is opened
                const mapDetails = document.querySelectorAll('.map-details');
                mapDetails.forEach(details => {
                    // Remove existing listener if any to prevent duplicates
                    details.removeEventListener('toggle', details._toggleHandler);

                    // Create and store handler
                    details._toggleHandler = async function(e) {
                        if (this.open) {
                            const flightId = this.dataset.flightId;
                            const mapContainer = document.getElementById(`inline-map-${flightId}`);

                            console.log('Map details opened for flight:', flightId);

                            // Only load if not already loaded
                            if (mapContainer && !mapContainer.classList.contains('map-loaded')) {
                                console.log('Loading inline map...');
                                await loadInlineFlightMap(flightId);
                                mapContainer.classList.add('map-loaded');
                            } else {
                                console.log('Map already loaded');
                            }
                        }
                    };

                    details.addEventListener('toggle', details._toggleHandler);
                });

                // Sync button
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.addEventListener('click', syncFlights);
                }

                // Clear & Re-sync button
                const clearAndResyncBtn = document.getElementById('clearAndResyncBtn');
                if (clearAndResyncBtn) {
                    clearAndResyncBtn.addEventListener('click', async () => {
                        if (confirm('This will clear all flight data and ratings from local storage and re-sync from Skydio. Continue?')) {
                            // Clear flight data and ratings
                            state.flights = [];
                            state.ratings = [];
                            saveToStorage('flights', state.flights);
                            saveToStorage('ratings', state.ratings);

                            // Clear inline maps
                            if (state.inlineMaps) {
                                Object.values(state.inlineMaps).forEach(map => {
                                    if (map && map.remove) map.remove();
                                });
                                state.inlineMaps = {};
                            }

                            state.syncMessage = { type: 'info', text: 'Cleared local data. Re-syncing...' };
                            render();

                            // Re-sync from Skydio
                            await syncFlights();
                        }
                    });
                }

                // Settings buttons
                const syncSettingsBtn = document.getElementById('syncSettingsBtn');
                if (syncSettingsBtn) {
                    syncSettingsBtn.addEventListener('click', syncFlights);
                }

                // V10.2: Fetch weather button
                const fetchWeatherBtn = document.getElementById('fetchWeatherBtn');
                if (fetchWeatherBtn) {
                    fetchWeatherBtn.addEventListener('click', async () => {
                        state.syncMessage = { type: 'info', text: 'Fetching weather data...' };
                        render();
                        await fetchWeatherForFlights();
                        state.syncMessage = { type: 'success', text: `Weather fetched for ${state.flights.filter(f => f.weather && !f.weather.unavailable).length} flights` };
                        render();
                    });
                }

                const updateWorkerBtn = document.getElementById('updateWorkerBtn');
                if (updateWorkerBtn) {
                    updateWorkerBtn.addEventListener('click', () => {
                        const newUrl = document.getElementById('workerUrlInput').value;
                        if (newUrl) {
                            state.syncSettings.workerUrl = newUrl;
                            saveToStorage('syncSettings', state.syncSettings);
                            state.syncMessage = { type: 'success', text: 'Worker URL updated' };
                            setTimeout(() => {
                                state.syncMessage = null;
                                render();
                            }, 2000);
                        }
                    });
                }

                // Advanced Settings toggle
                const advancedToggle = document.getElementById('advancedToggle');
                const advancedContent = document.getElementById('advancedContent');
                if (advancedToggle && advancedContent) {
                    advancedToggle.addEventListener('click', () => {
                        advancedToggle.classList.toggle('open');
                        advancedContent.classList.toggle('open');
                        const arrow = advancedToggle.querySelector('span:last-child');
                        if (arrow) {
                            arrow.textContent = advancedContent.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                        }
                    });
                }

                // Test Connection button
                const testConnectionBtn = document.getElementById('testConnectionBtn');
                if (testConnectionBtn) {
                    testConnectionBtn.addEventListener('click', async () => {
                        await checkConnection();
                        render();
                    });
                }

                // Trip Planner mode toggle buttons
                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.dataset.mode;
                        if (mode && (mode === 'auto' || mode === 'route')) {
                            state.plannerMode = mode;
                            render();
                        }
                    });
                });

                // Route Mode search button
                const findRouteSpotsBtn = document.getElementById('findRouteSpotsBtn');
                if (findRouteSpotsBtn) {
                    findRouteSpotsBtn.addEventListener('click', async () => {
                        const startInput = document.getElementById('routeStartInput');
                        const endInput = document.getElementById('routeEndInput');
                        if (startInput && endInput && startInput.value && endInput.value) {
                            state.routeStart = startInput.value;
                            state.routeEnd = endInput.value;

                            // V6.1: Geocode start and end locations for route polyline
                            findRouteSpotsBtn.disabled = true;
                            findRouteSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';

                            try {
                                const startLocation = await geocodeLocation(state.routeStart);
                                const endLocation = await geocodeLocation(state.routeEnd);

                                if (startLocation && endLocation) {
                                    state.routeStartCoords = startLocation;
                                    state.routeEndCoords = endLocation;

                                    // Search for POIs along the route (use midpoint for now) - Google Places ‚Üí OSM fallback
                                    const midLat = (startLocation.lat + endLocation.lat) / 2;
                                    const midLng = (startLocation.lng + endLocation.lng) / 2;
                                    const pois = await searchForDroneSpots(midLat, midLng, 20, `${state.routeStart} to ${state.routeEnd}`);

                                    state.spots = pois && pois.length > 0 ? pois : [];
                                } else {
                                    state.routeStartCoords = null;
                                    state.routeEndCoords = null;
                                    state.spots = [];
                                }
                            } catch (error) {
                                console.error('Route geocoding error:', error);
                                state.routeStartCoords = null;
                                state.routeEndCoords = null;
                                state.spots = [];
                            } finally {
                                findRouteSpotsBtn.disabled = false;
                                findRouteSpotsBtn.textContent = 'Find Spots Along Route';
                                render();
                            }
                        }
                    });
                }

                // Export data
                const exportDataBtn = document.getElementById('exportDataBtn');
                if (exportDataBtn) {
                    exportDataBtn.addEventListener('click', exportData);
                }

                // V10.0: Profile toggle
                const profileToggle = document.getElementById('profileToggle');
                const profileContent = document.getElementById('profileContent');
                if (profileToggle && profileContent) {
                    profileToggle.addEventListener('click', () => {
                        profileToggle.classList.toggle('open');
                        profileContent.classList.toggle('open');
                        const arrow = profileToggle.querySelector('span:last-child');
                        if (arrow) {
                            arrow.textContent = profileContent.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                        }
                    });
                }

                // V10.0: Profile certifications
                const part107Checkbox = document.getElementById('part107Checkbox');
                if (part107Checkbox) {
                    part107Checkbox.addEventListener('change', (e) => {
                        state.userProfile.certifications.part107 = e.target.checked;
                        if (!e.target.checked) {
                            state.userProfile.certifications.part107Expiry = null;
                        }
                        render();
                    });
                }

                const trustCheckbox = document.getElementById('trustCheckbox');
                if (trustCheckbox) {
                    trustCheckbox.addEventListener('change', (e) => {
                        state.userProfile.certifications.trust = e.target.checked;
                    });
                }

                const part107ExpiryInput = document.getElementById('part107ExpiryInput');
                if (part107ExpiryInput) {
                    part107ExpiryInput.addEventListener('change', (e) => {
                        state.userProfile.certifications.part107Expiry = e.target.value;
                    });
                }

                // V10.0: Search radius slider
                const searchRadiusSlider = document.getElementById('searchRadiusSlider');
                if (searchRadiusSlider) {
                    searchRadiusSlider.addEventListener('input', (e) => {
                        state.userProfile.preferences.searchRadius_mi = parseInt(e.target.value);
                        render();
                    });
                }

                // V10.0: Experience level
                const experienceSelect = document.getElementById('experienceSelect');
                if (experienceSelect) {
                    experienceSelect.addEventListener('change', (e) => {
                        state.userProfile.preferences.experience = e.target.value;
                    });
                }

                // V10.0: Avoid crowds checkbox
                const avoidCrowdsCheckbox = document.getElementById('avoidCrowdsCheckbox');
                if (avoidCrowdsCheckbox) {
                    avoidCrowdsCheckbox.addEventListener('change', (e) => {
                        state.userProfile.preferences.avoidCrowds = e.target.checked;
                    });
                }

                // V10.0: Waiver checkboxes
                const waiverCheckboxes = [
                    { id: 'waiverOverPeople', type: 'over_people' },
                    { id: 'waiverNightOps', type: 'night_operations' },
                    { id: 'waiverBVLOS', type: 'beyond_vlos' },
                    { id: 'waiverMovingVehicle', type: 'moving_vehicle' }
                ];

                waiverCheckboxes.forEach(({ id, type }) => {
                    const checkbox = document.getElementById(id);
                    if (checkbox) {
                        checkbox.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                // Add waiver if not already present
                                if (!state.userProfile.waivers.some(w => w.type === type)) {
                                    state.userProfile.waivers.push({
                                        type: type,
                                        expiryDate: null, // Tied to Part 107 cert
                                        notes: 'Granted under Part 107 certificate'
                                    });
                                }
                            } else {
                                // Remove waiver
                                state.userProfile.waivers = state.userProfile.waivers.filter(w => w.type !== type);
                            }
                        });
                    }
                });

                // V10.0: Save profile button
                const saveProfileBtn = document.getElementById('saveProfileBtn');
                if (saveProfileBtn) {
                    saveProfileBtn.addEventListener('click', () => {
                        saveToStorage('userProfile', state.userProfile);
                        alert('Profile saved successfully!');
                    });
                }

                // V10.0: Add drone button
                const addDroneBtn = document.getElementById('addDroneBtn');
                if (addDroneBtn) {
                    addDroneBtn.addEventListener('click', () => {
                        showAddDroneModal();
                    });
                }
            }

            // Helper functions
            function showSavePlanModal() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return;

                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <div class="input-group">
                        <label>Flight Date & Time</label>
                        <input type="datetime-local" id="planDateTime">
                    </div>
                    <div class="input-group">
                        <label>Notes (optional)</label>
                        <textarea id="planNotes" rows="3" placeholder="Flight plan notes..."></textarea>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="confirmSavePlan">Save Plan</button>
                        <button class="btn btn-secondary" id="cancelSavePlan">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                document.getElementById('confirmSavePlan').addEventListener('click', () => {
                    const dateTime = document.getElementById('planDateTime').value;
                    const notes = document.getElementById('planNotes').value;

                    if (dateTime) {
                        state.upcomingFlights.push({
                            id: Date.now(),
                            spotId: spot.id,
                            spotName: spot.name,
                            spotData: spot,
                            dateTime,
                            notes
                        });
                        saveToStorage('upcomingFlights', state.upcomingFlights);
                        modal.classList.remove('active');
                        alert('Flight plan saved!');
                    } else {
                        alert('Please select a date and time');
                    }
                });

                document.getElementById('cancelSavePlan').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            function markFlightAsFlown(flightId) {
                const flightIndex = state.upcomingFlights.findIndex(f => f.id == flightId);
                if (flightIndex === -1) return;

                const flight = state.upcomingFlights[flightIndex];

                state.flights.unshift({
                    id: Date.now(),
                    type: 'manual',
                    name: flight.spotName,
                    location: flight.spotName,
                    date: new Date(flight.dateTime).toISOString(),
                    duration: 0,
                    notes: flight.notes,
                    spotData: flight.spotData
                });

                state.upcomingFlights.splice(flightIndex, 1);

                saveToStorage('upcomingFlights', state.upcomingFlights);
                saveToStorage('flights', state.flights);

                showRatingModal(state.flights[0].id);
            }

            function deleteUpcomingFlight(flightId) {
                if (confirm('Delete this flight plan?')) {
                    state.upcomingFlights = state.upcomingFlights.filter(f => f.id != flightId);
                    saveToStorage('upcomingFlights', state.upcomingFlights);
                    render();
                }
            }

            function showRatingModal(flightId) {
                const flight = state.flights.find(f => f.id == flightId);
                if (!flight) return;

                const modal = document.getElementById('ratingModal');
                const content = document.getElementById('ratingContent');

                state.currentRating = {
                    flightId: flight.id,
                    descAccuracy: 0,
                    shotTypeMatch: 0,
                    accessibility: 0,
                    wouldFlyAgain: null,
                    notes: ''
                };

                // Use the full generated flight name with location
                const flightName = generateFlightName(flight);

                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <strong>Flight:</strong> ${flightName}
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Description Accuracy</label>
                        <div class="star-rating" id="descAccuracy">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Shot Type Match</label>
                        <div class="star-rating" id="shotTypeMatch">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Accessibility</label>
                        <div class="star-rating" id="accessibility">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Additional Notes (optional)</label>
                        <textarea id="ratingNotes" rows="3" placeholder="Any additional feedback..."></textarea>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="submitRating">Submit Rating</button>
                        <button class="btn btn-secondary" id="cancelRating">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                // Star rating handlers
                document.querySelectorAll('.star-rating').forEach(group => {
                    const stars = group.querySelectorAll('.star');
                    stars.forEach(star => {
                        star.addEventListener('click', (e) => {
                            const rating = parseInt(e.target.dataset.rating);
                            const category = group.id;
                            state.currentRating[category] = rating;

                            stars.forEach((s, i) => {
                                s.classList.toggle('active', i < rating);
                            });
                        });
                    });
                });

                // Submit rating
                document.getElementById('submitRating').addEventListener('click', () => {
                    const notes = document.getElementById('ratingNotes').value;

                    if (state.currentRating.descAccuracy > 0 &&
                        state.currentRating.shotTypeMatch > 0 &&
                        state.currentRating.accessibility > 0) {

                        state.currentRating.notes = notes;
                        state.ratings.push({...state.currentRating});
                        saveToStorage('ratings', state.ratings);

                        modal.classList.remove('active');
                        state.currentRating = null;
                        render();
                    } else {
                        alert('Please complete all ratings');
                    }
                });

                document.getElementById('cancelRating').addEventListener('click', () => {
                    modal.classList.remove('active');
                    state.currentRating = null;
                });
            }

            // V6.1: Export flights data as CSV format
            function exportData() {
                let csv = 'Date,Location,Duration,Type,Notes\n';
                state.flights.forEach(flight => {
                    csv += `${formatDate(flight.date)},"${flight.name || flight.location}",${flight.duration || 0},${flight.type || 'manual'},"${flight.notes || ''}"\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'dronescout-flights.csv';
                a.click();
            }

            // V10.0: Profile helper functions
            function getWaiverLabel(type) {
                const labels = {
                    'over_people': 'Over People',
                    'night_operations': 'Night Operations',
                    'beyond_vlos': 'Beyond Visual Line of Sight',
                    'controlled_airspace': 'Controlled Airspace'
                };
                return labels[type] || type;
            }

            // V10.0: Global functions for removing items (called from inline onclick)
            window.removeWaiver = function(idx) {
                if (confirm('Remove this waiver?')) {
                    state.userProfile.waivers.splice(idx, 1);
                    render();
                }
            };

            window.removeDrone = function(idx) {
                if (confirm('Remove this drone?')) {
                    state.userProfile.drones.splice(idx, 1);
                    render();
                }
            };

            function showAddWaiverModal() {
                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">Add Waiver</h3>
                    <div class="input-group">
                        <label>Waiver Type</label>
                        <select id="waiverTypeSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="over_people">Over People</option>
                            <option value="night_operations">Night Operations</option>
                            <option value="beyond_vlos">Beyond Visual Line of Sight</option>
                            <option value="controlled_airspace">Controlled Airspace</option>
                        </select>
                    </div>
                    <div class="input-group" id="categoryGroup" style="display: none;">
                        <label>Category (for Over People)</label>
                        <select id="categorySelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="1">Category 1</option>
                            <option value="2">Category 2</option>
                            <option value="3">Category 3</option>
                            <option value="4">Category 4</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Expiry Date</label>
                        <input type="date" id="waiverExpiryInput">
                    </div>
                    <div class="input-group">
                        <label>Notes (optional)</label>
                        <textarea id="waiverNotesInput" rows="2" placeholder="e.g., Parachute system equipped"></textarea>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn" id="confirmAddWaiver">Add Waiver</button>
                        <button class="btn btn-secondary" id="cancelAddWaiver">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                // Show/hide category field based on waiver type
                const waiverTypeSelect = document.getElementById('waiverTypeSelect');
                const categoryGroup = document.getElementById('categoryGroup');
                waiverTypeSelect.addEventListener('change', () => {
                    categoryGroup.style.display = waiverTypeSelect.value === 'over_people' ? 'block' : 'none';
                });

                document.getElementById('confirmAddWaiver').addEventListener('click', () => {
                    const type = document.getElementById('waiverTypeSelect').value;
                    const expiryDate = document.getElementById('waiverExpiryInput').value;
                    const notes = document.getElementById('waiverNotesInput').value;

                    if (expiryDate) {
                        const waiver = {
                            type,
                            expiryDate,
                            notes
                        };

                        if (type === 'over_people') {
                            waiver.category = parseInt(document.getElementById('categorySelect').value);
                        }

                        state.userProfile.waivers.push(waiver);
                        modal.classList.remove('active');
                        render();
                    } else {
                        alert('Please select an expiry date');
                    }
                });

                document.getElementById('cancelAddWaiver').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            function showAddDroneModal() {
                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">Add Drone</h3>
                    <div class="input-group">
                        <label>Drone Model</label>
                        <input type="text" id="droneNameInput" placeholder="e.g., DJI Mavic 3">
                    </div>
                    <div class="input-group">
                        <label>Weight (lbs)</label>
                        <input type="number" id="droneWeightInput" step="0.1" placeholder="e.g., 1.98">
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneParachuteCheckbox">
                            Has Parachute System
                        </label>
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneRemoteIDCheckbox">
                            Has Remote ID
                        </label>
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneNightLightsCheckbox">
                            Has Night Lights
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn" id="confirmAddDrone">Add Drone</button>
                        <button class="btn btn-secondary" id="cancelAddDrone">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                document.getElementById('confirmAddDrone').addEventListener('click', () => {
                    const name = document.getElementById('droneNameInput').value;
                    const weight = parseFloat(document.getElementById('droneWeightInput').value);

                    if (name && weight) {
                        const drone = {
                            id: `drone_${Date.now()}`,
                            name,
                            weight_lbs: weight,
                            hasParachute: document.getElementById('droneParachuteCheckbox').checked,
                            hasRemoteID: document.getElementById('droneRemoteIDCheckbox').checked,
                            hasNightLights: document.getElementById('droneNightLightsCheckbox').checked
                        };

                        state.userProfile.drones.push(drone);
                        modal.classList.remove('active');
                        render();
                    } else {
                        alert('Please fill in drone name and weight');
                    }
                });

                document.getElementById('cancelAddDrone').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            // Initial render
            checkConnection();
            getUserLocation(); // V6: Request user's location for map
            render();
        }
    </script>
</body>
</html>
