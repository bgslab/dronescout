<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DroneScout V9.0 - Smart Spot Discovery</title>
    <!-- Build: 2025-10-31-23:50 UTC - FORCE RELOAD -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- V6 Fix: Proper Leaflet loading on ALL devices (no conditional loading) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <!-- V6.1: Updated to latest Chart.js version -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a2a6c 0%, #0f1b4d 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            background: #f5f7fa;
            min-height: 100vh;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 2px solid #e0e6ed;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            min-width: fit-content;
        }

        .nav-tab.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
        }

        .content {
            padding: 20px;
            padding-bottom: 80px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .preferences-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .preferences-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .preferences-title {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }
        .preferences-toggle {
            background: none;
            border: none;
            color: #00d4ff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .slider-label {
            font-size: 13px;
            font-weight: 600;
            color: #666;
        }
        .slider-label.active {
            color: #00d4ff;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e6ed;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .x10-badge {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .x10-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .x10-features {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .feature-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
        }

        .spot-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .spot-card:active {
            transform: scale(0.98);
        }

        .spot-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        /* Skeleton loading states */
        .skeleton-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
        }

        .skeleton-image {
            width: 100%;
            height: 180px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-content {
            padding: 15px;
        }

        .skeleton-title {
            height: 20px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 10px;
            width: 70%;
        }

        .skeleton-text {
            height: 14px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
            width: 90%;
        }

        .skeleton-badge {
            height: 24px;
            width: 80px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 12px;
            display: inline-block;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }

        .risk-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        .risk-badge.high {
            background: rgba(39, 174, 96, 0.9);
            color: white;
        }

        .risk-badge.medium {
            background: rgba(255, 193, 7, 0.9);
            color: white;
        }

        .risk-badge.low {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        /* Compact weather card - horizontal layout */
        .weather-card {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 10px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 13px;
        }

        .weather-compact {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .weather-temp-icon {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            color: #1e3c72;
        }

        .weather-temp-icon .temp {
            font-size: 18px;
        }

        .weather-temp-icon .icon {
            font-size: 20px;
        }

        .weather-details {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #666;
        }

        .weather-detail-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .flying-status {
            padding: 6px 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            font-size: 12px;
            display: inline-block;
        }

        .status-good {
            background: #d1f4e0;
            color: #1d7a3c;
        }

        .status-caution {
            background: #fff3cd;
            color: #856404;
        }

        .status-bad {
            background: #f8d7da;
            color: #721c24;
        }

        .warnings {
            margin-top: 8px;
            padding: 8px;
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            border-radius: 4px;
        }

        .warning-item {
            font-size: 11px;
            color: #856404;
            margin: 3px 0;
            display: flex;
            align-items: flex-start;
            gap: 4px;
            line-height: 1.3;
        }

        /* Photo source badge */
        .photo-source-badge {
            position: absolute;
            top: 12px;
            right: 50px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .photo-source-badge.streetview {
            background: rgba(66, 133, 244, 0.9);
            color: white;
        }

        .photo-source-badge.stock {
            background: rgba(128, 128, 128, 0.8);
            color: white;
        }

        .favorite-star {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s;
            backdrop-filter: blur(10px);
        }

        .favorite-star.active {
            color: #ffc107;
        }

        .spot-info {
            padding: 15px;
        }

        .spot-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 8px;
        }

        .spot-desc {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .spot-distance {
            font-size: 13px;
            color: #00d4ff;
            font-weight: 600;
        }

        .map-container {
            width: 100%;
            height: 400px;
            min-height: 400px;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            background: #e0e6ed;
        }

        .risk-category {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .risk-cat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .risk-cat-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .risk-cat-score {
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-medium {
            background: #fff3cd;
            color: #856404;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        .risk-cat-bar {
            width: 100%;
            height: 6px;
            background: #e0e6ed;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .risk-cat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            transition: width 0.3s;
        }

        .risk-cat-desc {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .flight-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e0e6ed;
        }

        .flight-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .flight-location {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }

        .flight-date {
            font-size: 13px;
            color: #666;
        }

        .flight-details {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
        }

        .flight-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge-synced {
            background: #e8f5e9;
            color: #1b5e20;
        }

        .badge-manual {
            background: #e7f3ff;
            color: #0056b3;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 6px;
        }

        .badge.rated {
            background: #d4edda;
            color: #155724;
        }

        .badge.pending {
            background: #fff3cd;
            color: #856404;
        }

        .btn-small {
            flex: 1;
            padding: 8px;
            background: #00d4ff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-small.secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn-small.danger {
            background: #dc3545;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 16px;
            color: #666;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        .status-indicator.checking {
            background: #ffc107;
        }

        .status-text {
            flex: 1;
            font-size: 13px;
            color: #666;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section-title {
            font-size: 14px;
            font-weight: 700;
            color: #1e3c72;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e6ed;
        }

        .advanced-toggle {
            background: white;
            border: 2px solid #e0e6ed;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .advanced-toggle:hover {
            border-color: #00d4ff;
        }

        .advanced-toggle.open {
            background: #f0f5fa;
            border-color: #00d4ff;
        }

        .advanced-content {
            display: none;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #00d4ff;
        }

        .advanced-content.open {
            display: block;
        }

        /* V10.0: Profile UI styles */
        .profile-subsection {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e6ed;
        }

        .profile-subsection:last-child {
            border-bottom: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .waiver-item,
        .drone-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e0e6ed;
            margin-bottom: 10px;
        }

        .waiver-item:last-child,
        .drone-item:last-child {
            margin-bottom: 0;
        }

        .sync-info {
            font-size: 13px;
            color: #666;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            border-left: 4px solid #00d4ff;
            margin: 10px 0;
        }

        .chart-container {
            width: 100%;
            height: 250px;
            margin-bottom: 20px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .help-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 12px;
        }

        .help-section p {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            list-style: none;
            padding: 0;
        }

        .help-section li {
            font-size: 14px;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            position: relative;
        }

        .help-section li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #00d4ff;
            font-weight: 700;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .star-rating {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .star {
            font-size: 32px;
            color: #e0e6ed;
            cursor: pointer;
            transition: all 0.2s;
        }

        .star.active {
            color: #ffc107;
        }

        .star:hover {
            transform: scale(1.1);
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #00d4ff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sync-message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
            font-weight: 600;
        }

        .sync-message.success {
            background: #d4edda;
            color: #155724;
        }

        .sync-message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .back-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            margin-bottom: 10px;
        }

        .toggle-favorites-btn {
            background: white;
            border: 2px solid #e0e6ed;
            color: #666;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-favorites-btn.active {
            background: #ffc107;
            color: white;
            border-color: #ffc107;
        }

        .export-btn {
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üöÅ DroneScout V9.0</h1>
            <p>Plan ‚Ä¢ Discover ‚Ä¢ Map ‚Ä¢ Assess ‚Ä¢ Fly ‚Ä¢ Sync ‚Ä¢ Analyze</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="planner">Trip Planner</button>
            <button class="nav-tab" data-tab="upcoming">Upcoming</button>
            <button class="nav-tab" data-tab="history">History</button>
            <button class="nav-tab" data-tab="settings">Settings</button>
            <button class="nav-tab" data-tab="analytics">Analytics</button>
            <button class="nav-tab" data-tab="help">Help</button>
        </div>

        <div class="content" id="content">
            <!-- Content will be dynamically rendered -->
        </div>
    </div>

    <!-- Rating Modal -->
    <div class="modal" id="ratingModal">
        <div class="modal-content">
            <div class="modal-header">Rate Your Flight</div>
            <div id="ratingContent"></div>
        </div>
    </div>

    <!-- Save Flight Plan Modal -->
    <div class="modal" id="savePlanModal">
        <div class="modal-content">
            <div class="modal-header">Save Flight Plan</div>
            <div id="savePlanContent"></div>
        </div>
    </div>

    <script>
        // Initialize app
        document.addEventListener('DOMContentLoaded', initializeApp);

        function initializeApp() {
            // App state
            const state = {
                currentTab: 'planner',
                selectedSpot: null,
                destination: '',
                plannerMode: 'auto',
                routeStart: '',
                routeEnd: '',
                spots: [],
                upcomingFlights: loadFromStorage('upcomingFlights') || [],
                flights: loadFromStorage('flights') || [],
                ratings: loadFromStorage('ratings') || [],
                preferences: loadFromStorage('preferences') || {
                    cityscape: 50,
                    nature: 50,
                    architecture: 50
                },
                // V10: User profile for intelligent recommendations
                userProfile: loadFromStorage('userProfile') || {
                    certifications: {
                        part107: false,
                        part107Expiry: null,
                        trust: false
                    },
                    waivers: [],
                    drones: [],
                    preferences: {
                        searchRadius_mi: 15,
                        maxDriveTime_min: 20,
                        experience: 'intermediate',
                        avoidCrowds: true
                    }
                },
                favorites: loadFromStorage('favorites') || [],
                showFavoritesOnly: false,
                showPreferences: false,
                currentRating: null,
                syncSettings: loadFromStorage('syncSettings') || {
                    workerUrl: 'https://dronescout-proxy.dronescout-api.workers.dev',
                    lastSync: null,
                    connectionStatus: 'checking'
                },
                syncMessage: null,
                expandedFlight: null,
                // V6: Map state
                map: null,
                mapMarkers: [],
                destinationCoords: null,
                userLocation: null,
                // V6.1: Route mode state
                routeStartCoords: null,
                routeEndCoords: null,
                routePolyline: null,
                // V9: Spot search center for preference ranking
                searchCenter: null,
                // V9.1: Loading state for spots
                loadingSpots: false
            };

            // LocalStorage helpers
            function loadFromStorage(key) {
                try {
                    const data = localStorage.getItem('dronescout_' + key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    return null;
                }
            }

            function saveToStorage(key, value) {
                try {
                    localStorage.setItem('dronescout_' + key, JSON.stringify(value));
                } catch (e) {
                    console.error('Storage error:', e);
                }
            }

            // Demo data with full v2 features
            const scenicSpots = [
                {
                    id: 1,
                    name: "Constitution Trail Overlook",
                    description: "Scenic trail with open fields and tree lines. Great for tracking shots and nature content.",
                    coordinates: { lat: 40.4842, lng: -88.9936 },
                    imageUrl: "https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80",
                    flightInstructions: "Launch from north parking area. Fly heading 180¬∞ (south) along tree line. Maintain 150 ft AGL to capture trail and surrounding farmland. Look east for sunrise golden hour shots.",
                    bestTime: "Golden hour (sunrise/sunset)",
                    x10Advantage: "X10's advanced autonomy excels at tree line tracking. Superior range enables full trail coverage. Nightsense allows twilight flights when trails are empty.",
                    distance: "2.3 mi",
                    riskScore: 88,
                    shotTypes: { landscape: 70, nature: 30, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 4.2 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "Visual line of sight waived (Part 107.31) - BVLOS certified", compliant: true },
                        { authority: "Local Parks", rule: "Drone flights permitted with Part 107 certification", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "8-12 mph SW",
                        visibility: "10+ miles",
                        temp: "72¬∞F",
                        conditions: "Clear"
                    }
                },
                {
                    id: 2,
                    name: "Downtown Skyline - Miller Park",
                    description: "Urban skyline shots with historic buildings and modern architecture blend.",
                    coordinates: { lat: 40.4781, lng: -88.9937 },
                    imageUrl: "https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80",
                    flightInstructions: "Launch from Miller Park. Fly heading 45¬∞ (northeast) toward downtown. Maintain 300 ft AGL for optimal building perspective.",
                    bestTime: "Blue hour (twilight) for city lights",
                    x10Advantage: "Nightsense capability captures stunning blue hour shots other drones miss. Elite obstacle avoidance navigates urban environment safely.",
                    distance: "3.7 mi",
                    riskScore: 72,
                    shotTypes: { cityscape: 80, architecture: 20, landscape: 0, nature: 0 },
                    airspaceDetails: {
                        class: "Class G with LAANC",
                        ceiling: "Up to 400 ft AGL with authorization",
                        laancRequired: "Yes (auto-approved up to 400 ft)",
                        nearestAirport: "Central Illinois Regional (BMI) - 3.8 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "LAANC authorization obtained", compliant: true },
                        { authority: "City of Bloomington", rule: "Municipal approval for park launches", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "6-10 mph SSW",
                        visibility: "10+ miles",
                        temp: "68¬∞F",
                        conditions: "Partly cloudy"
                    }
                },
                {
                    id: 3,
                    name: "Evergreen Lake Nature Preserve",
                    description: "Natural lake with wildlife and dense tree cover. Excellent for aerial shots of water reflections.",
                    coordinates: { lat: 40.5142, lng: -88.9687 },
                    imageUrl: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80",
                    flightInstructions: "Launch from east parking area. Fly heading 270¬∞ (west) over lake. Maintain 200 ft AGL to capture full lake and fountain.",
                    bestTime: "Early morning for calm water reflections",
                    x10Advantage: "X10 Nightsense unlocks magical twilight/blue hour shots. Advanced obstacle avoidance navigates dense canopy safely.",
                    distance: "5.1 mi",
                    riskScore: 91,
                    shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 6.1 mi S"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "BVLOS operations authorized", compliant: true },
                        { authority: "McLean County", rule: "Preserve permits drone use for photography", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "5-8 mph W",
                        visibility: "10+ miles",
                        temp: "65¬∞F",
                        conditions: "Clear"
                    }
                }
            ];

            // Unsplash API configuration
            const UNSPLASH_API_KEY = 'PWgTvrIDkfEdi93dvP2knidPZa7z8IbdhnvbZRrBIw4';

            // Fetch real images from Unsplash API (location-specific)
            async function fetchUnsplashImage(category, locationName = '', spotName = '') {
                try {
                    // Extract city/location name from full location (e.g., "San Francisco" from "San Francisco, CA, USA")
                    let cityName = locationName;
                    if (locationName.includes(',')) {
                        cityName = locationName.split(',')[0].trim();
                    }

                    // Map categories to search terms
                    const categoryTerms = {
                        viewpoint: 'cityscape skyline',
                        water: 'waterfront bay harbor',
                        park: 'park nature',
                        nature: 'nature landscape',
                        architecture: 'architecture landmark',
                        landscape: 'landscape vista'
                    };

                    const categoryTerm = categoryTerms[category] || categoryTerms.landscape;

                    // Combine location + category for location-specific images
                    // e.g., "San Francisco cityscape" or "Yosemite mountain landscape"
                    const query = cityName ? `${cityName} ${categoryTerm}` : categoryTerm;

                    const url = `https://api.unsplash.com/photos/random?query=${encodeURIComponent(query)}&orientation=landscape`;

                    console.log(`Fetching image for: "${query}"`);

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Client-ID ${UNSPLASH_API_KEY}`
                        }
                    });

                    if (!response.ok) {
                        console.warn('Unsplash API error, using fallback image');
                        return getFallbackImage(category);
                    }

                    const data = await response.json();
                    return data.urls.regular || data.urls.small;
                } catch (error) {
                    console.error('Unsplash fetch error:', error);
                    return getFallbackImage(category);
                }
            }

            // Fallback images if Unsplash fails
            function getFallbackImage(category) {
                const fallbackImages = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return fallbackImages[category] || fallbackImages.landscape;
            }

            // Google Street View API functions (via Cloudflare Worker proxy)
            /**
             * Fetch a Street View image for a location
             * Falls back to Unsplash if no Street View available
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @param {string} category - Image category for Unsplash fallback
             * @param {string} locationName - Location name for Unsplash fallback
             * @returns {Promise<{imageUrl: string, source: string, metadata: object}>}
             */
            async function fetchLocationImage(lat, lon, category = 'landscape', locationName = '') {
                try {
                    // Get worker URL from settings
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('Worker URL not configured, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }

                    // Try Google Street View first
                    const streetViewUrl = `${workerUrl}/api/streetview/image?lat=${lat}&lon=${lon}&size=600x400`;
                    const response = await fetch(streetViewUrl);

                    if (!response.ok) {
                        console.warn('Street View API error, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }

                    const data = await response.json();

                    if (data.success && data.hasStreetView) {
                        console.log('Using Street View image');
                        return {
                            imageUrl: data.imageUrl,
                            source: 'streetview',
                            metadata: data.metadata || {}
                        };
                    } else {
                        // No Street View available, fall back to Unsplash
                        console.log('No Street View available, using Unsplash fallback');
                        const imageUrl = await fetchUnsplashImage(category, locationName);
                        return {
                            imageUrl,
                            source: 'unsplash',
                            metadata: {}
                        };
                    }
                } catch (error) {
                    console.error('fetchLocationImage error:', error);
                    const imageUrl = await fetchUnsplashImage(category, locationName);
                    return {
                        imageUrl,
                        source: 'unsplash',
                        metadata: {}
                    };
                }
            }

            /**
             * Check if Street View is available at a location
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @returns {Promise<{hasStreetView: boolean, metadata: object}>}
             */
            async function checkStreetViewAvailability(lat, lon) {
                try {
                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        return { hasStreetView: false, metadata: {} };
                    }

                    const metadataUrl = `${workerUrl}/api/streetview/metadata?lat=${lat}&lon=${lon}`;
                    const response = await fetch(metadataUrl);

                    if (!response.ok) {
                        return { hasStreetView: false, metadata: {} };
                    }

                    const data = await response.json();
                    return {
                        hasStreetView: data.hasStreetView || false,
                        metadata: data.location ? {
                            location: data.location,
                            date: data.date,
                            copyright: data.copyright
                        } : {}
                    };
                } catch (error) {
                    console.error('checkStreetViewAvailability error:', error);
                    return { hasStreetView: false, metadata: {} };
                }
            }

            // OpenWeather API functions (via Cloudflare Worker proxy)
            /**
             * Fetch current weather at a location
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @param {string} units - 'imperial' or 'metric'
             * @returns {Promise<{weather: object, error: string}>}
             */
            async function fetchCurrentWeather(lat, lon, units = 'imperial') {
                try {
                    // Check cache first (15 minute TTL)
                    const cacheKey = `weather_${lat.toFixed(4)}_${lon.toFixed(4)}_${units}`;
                    const cached = localStorage.getItem(cacheKey);

                    if (cached) {
                        const { data, timestamp } = JSON.parse(cached);
                        const age = Date.now() - timestamp;
                        const TTL = 15 * 60 * 1000; // 15 minutes in milliseconds

                        if (age < TTL) {
                            console.log(`Weather cache hit (${Math.floor(age / 1000)}s old)`);
                            return data;
                        } else {
                            console.log('Weather cache expired, fetching fresh data');
                            localStorage.removeItem(cacheKey);
                        }
                    }

                    const workerUrl = state.syncSettings?.workerUrl;
                    if (!workerUrl) {
                        console.warn('Worker URL not configured, weather unavailable');
                        return { weather: null, error: 'Worker URL not configured' };
                    }

                    const weatherUrl = `${workerUrl}/api/weather/current?lat=${lat}&lon=${lon}&units=${units}`;
                    const response = await fetch(weatherUrl);

                    if (!response.ok) {
                        console.warn('Weather API error');
                        return { weather: null, error: 'Weather API error' };
                    }

                    const apiData = await response.json();

                    if (apiData.success && apiData.weather) {
                        console.log('Weather data fetched successfully');
                        const result = {
                            weather: apiData.weather,
                            error: null
                        };

                        // Cache the result
                        try {
                            localStorage.setItem(cacheKey, JSON.stringify({
                                data: result,
                                timestamp: Date.now()
                            }));
                        } catch (e) {
                            console.warn('Failed to cache weather data:', e);
                        }

                        return result;
                    } else {
                        return {
                            weather: null,
                            error: apiData.error || 'Unknown weather error'
                        };
                    }
                } catch (error) {
                    console.error('fetchCurrentWeather error:', error);
                    return {
                        weather: null,
                        error: error.message
                    };
                }
            }

            /**
             * Format weather data for display
             * @param {object} weather - Weather object from fetchCurrentWeather
             * @returns {string} Formatted weather string
             */
            function formatWeatherDisplay(weather) {
                if (!weather) return 'Weather unavailable';

                const { temp, tempUnit, conditions, windSpeed, windSpeedUnit, visibility, visibilityUnit } = weather;
                return `${temp}${tempUnit}, ${conditions}, Wind ${windSpeed}${windSpeedUnit}, Vis ${visibility}${visibilityUnit}`;
            }

            /**
             * TESTING ONLY: Simulate bad weather conditions
             * Uncomment the return statement to test bad weather display
             * @param {object} weather - Real weather object
             * @returns {object} Modified weather with bad conditions
             */
            function simulateBadWeather(weather) {
                // UNCOMMENT THIS RETURN TO TEST BAD WEATHER:
                /*
                return {
                    temp: 28,
                    tempUnit: '¬∞F',
                    conditions: 'Rain',
                    windSpeed: 32,
                    windSpeedUnit: 'mph',
                    visibility: 2.1,
                    visibilityUnit: 'mi',
                    humidity: 95,
                    flyingConditions: {
                        safe: false,
                        risk: 'high',
                        riskColor: 'red',
                        warnings: [
                            'High wind speeds - unsafe for most drones',
                            'Low visibility - may not meet FAA VLOS requirements',
                            'Precipitation detected - risk of moisture damage',
                            'Below freezing - reduced battery performance'
                        ],
                        recommendation: 'Do not fly - unsafe conditions'
                    }
                };
                */
                return weather; // Return real weather (normal operation)
            }

            /**
             * Get weather icon emoji based on conditions
             * @param {string} conditions - Weather condition string
             * @returns {string} Weather emoji
             */
            function getWeatherIcon(conditions) {
                const icons = {
                    'Clear': '‚òÄÔ∏è',
                    'Clouds': '‚òÅÔ∏è',
                    'Rain': 'üåßÔ∏è',
                    'Snow': '‚ùÑÔ∏è',
                    'Drizzle': 'üå¶Ô∏è',
                    'Thunderstorm': '‚õàÔ∏è',
                    'Mist': 'üå´Ô∏è',
                    'Fog': 'üå´Ô∏è',
                    'Haze': 'üå´Ô∏è'
                };
                return icons[conditions] || 'üå§Ô∏è';
            }

            /**
             * Render compact weather card with flying conditions
             * @param {object} weather - Weather object from API
             * @returns {string} HTML for compact weather card
             */
            function renderWeatherCard(weather) {
                if (!weather || !weather.flyingConditions) {
                    return '<div style="text-align: center; color: #999; font-size: 12px; padding: 8px; margin-top: 12px;">Weather unavailable</div>';
                }

                // Apply bad weather simulation if enabled (for testing)
                const w = simulateBadWeather(weather);
                const statusClass = w.flyingConditions.risk === 'low' ? 'status-good'
                                  : w.flyingConditions.risk === 'medium' ? 'status-caution'
                                  : 'status-bad';

                const warnings = w.flyingConditions.warnings && w.flyingConditions.warnings.length > 0
                    ? `<div class="warnings">${w.flyingConditions.warnings.map(warn => `<div class="warning-item">‚ö†Ô∏è ${warn}</div>`).join('')}</div>`
                    : '';

                return `
                    <div class="weather-card">
                        <div class="weather-compact">
                            <div class="weather-temp-icon">
                                <span class="icon">${getWeatherIcon(w.conditions)}</span>
                                <span class="temp">${w.temp}${w.tempUnit}</span>
                            </div>
                            <div class="weather-details">
                                <div class="weather-detail-item">üí® ${w.windSpeed}${w.windSpeedUnit}</div>
                                <div class="weather-detail-item">üëÅÔ∏è ${w.visibility}${w.visibilityUnit}</div>
                            </div>
                        </div>
                        <div class="flying-status ${statusClass}">
                            ${w.flyingConditions.recommendation}
                        </div>
                        ${warnings}
                    </div>
                `;
            }

            // Nominatim Geocoding API functions
            async function geocodeLocation(locationQuery) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(locationQuery)}&format=json&limit=1`,
                        {
                            headers: {
                                'User-Agent': 'DroneScout/5.3 (Flight Planning App)'
                            }
                        }
                    );

                    if (!response.ok) throw new Error('Geocoding failed');

                    const results = await response.json();
                    if (results.length === 0) return null;

                    return {
                        lat: parseFloat(results[0].lat),
                        lng: parseFloat(results[0].lon),
                        displayName: results[0].display_name
                    };
                } catch (error) {
                    console.error('Geocoding error:', error);
                    return null;
                }
            }

            // Overpass API POI search functions
            async function searchPOIsNearLocation(lat, lng, radiusKm = 10, locationName = '') {
                try {
                    // Overpass query for diverse locations: nature, cityscape, and architecture
                    const query = `
                        [out:json][timeout:25];
                        (
                          node["tourism"="viewpoint"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="peak"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="park"](around:${radiusKm * 1000},${lat},${lng});
                          way["natural"="water"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="nature_reserve"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="beach"](around:${radiusKm * 1000},${lat},${lng});
                          way["landuse"="forest"](around:${radiusKm * 1000},${lat},${lng});
                          node["man_made"="tower"]["tower:type"="observation"](around:${radiusKm * 1000},${lat},${lng});
                          way["tourism"="attraction"]["building"](around:${radiusKm * 1000},${lat},${lng});
                          way["building"="commercial"]["building:levels"](around:${radiusKm * 1000},${lat},${lng});
                          node["historic"="monument"](around:${radiusKm * 1000},${lat},${lng});
                          way["amenity"="place_of_worship"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="stadium"](around:${radiusKm * 1000},${lat},${lng});
                        );
                        out center 40;
                    `;

                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: 'data=' + encodeURIComponent(query)
                    });

                    if (!response.ok) throw new Error('Overpass API failed');

                    const data = await response.json();
                    return await processPOIs(data.elements, lat, lng, locationName);
                } catch (error) {
                    console.error('POI search error:', error);
                    return [];
                }
            }

            // Process POIs into spot format (async to fetch real images + weather)
            async function processPOIs(elements, centerLat, centerLng, locationName = '') {
                const spots = [];

                // Limit to first 15 spots to avoid excessive API calls
                const limitedElements = elements.slice(0, 15);

                // Process each element and fetch images + weather
                for (let index = 0; index < limitedElements.length; index++) {
                    const element = limitedElements[index];

                    // Get coordinates (handle nodes and ways differently)
                    let poiLat, poiLng;
                    if (element.lat && element.lon) {
                        poiLat = element.lat;
                        poiLng = element.lon;
                    } else if (element.center) {
                        poiLat = element.center.lat;
                        poiLng = element.center.lon;
                    } else {
                        continue; // Skip if no coordinates
                    }

                    // Calculate distance
                    const distance = calculateDistance(centerLat, centerLng, poiLat, poiLng);

                    // Determine spot type and generate appropriate data
                    const tags = element.tags || {};
                    const spotType = determineSpotType(tags, locationName, tags);
                    const name = tags.name || `${spotType.name} ${index + 1}`;

                    // Debug: Log OSM tags to see what data is available
                    console.log(`üìç Spot: ${name}`, 'OSM Tags:', tags);

                    // Fetch real image (Street View with Unsplash fallback) AND current weather in parallel
                    const [imageData, weatherData] = await Promise.all([
                        fetchLocationImage(poiLat, poiLng, spotType.category, locationName),
                        fetchCurrentWeather(poiLat, poiLng, 'imperial')
                    ]);

                    spots.push({
                        id: element.id || Date.now() + index,
                        name: name,
                        description: generateDescription(tags, spotType, locationName),
                        coordinates: { lat: poiLat, lng: poiLng },
                        imageUrl: imageData.imageUrl,
                        imageSource: imageData.source, // 'streetview' or 'unsplash'
                        imageMetadata: imageData.metadata || {},
                        flightInstructions: generateFlightInstructions(spotType, tags),
                        bestTime: spotType.bestTime,
                        x10Advantage: "X10's advanced autonomy and Nightsense capability enable safe navigation and stunning shots in varied lighting conditions.",
                        distance: `${distance.toFixed(1)} mi`,
                        riskScore: calculateRiskScore(tags, spotType),
                        shotTypes: spotType.shotTypes,
                        airspaceDetails: {
                            class: "Class G (Uncontrolled)",
                            ceiling: "Up to 400 ft AGL authorized",
                            laancRequired: "Check local requirements",
                            nearestAirport: "Verify on SkyVector/B4UFLY"
                        },
                        regulations: [
                            { authority: "FAA Part 107", rule: "Visual line of sight required (unless BVLOS waiver)", compliant: true },
                            { authority: "Local Authority", rule: "Verify local drone regulations before flight", compliant: true }
                        ],
                        // Real weather data from OpenWeather API
                        weather: weatherData.weather,
                        weatherError: weatherData.error,
                        // Legacy weatherConditions for backwards compatibility
                        weatherConditions: weatherData.weather ? {
                            wind: `${weatherData.weather.windSpeed} ${weatherData.weather.windSpeedUnit}`,
                            visibility: `${weatherData.weather.visibility} ${weatherData.weather.visibilityUnit}`,
                            temp: `${weatherData.weather.temp}${weatherData.weather.tempUnit}`,
                            conditions: weatherData.weather.conditions
                        } : {
                            wind: "Check current conditions",
                            visibility: "Check current conditions",
                            temp: "Check current conditions",
                            conditions: "Verify before flight"
                        }
                    });
                }

                // Sort by distance
                return spots.sort((a, b) => {
                    const distA = parseFloat(a.distance);
                    const distB = parseFloat(b.distance);
                    return distA - distB;
                });
            }

            // Helper function to calculate distance in miles
            function calculateDistance(lat1, lng1, lat2, lng2) {
                const R = 3959; // Earth's radius in miles
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng / 2) * Math.sin(dLng / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Determine spot type from OSM tags
            function determineSpotType(tags, locationName = '', osmTags = {}) {
                // Detect if location is urban (major city)
                const isUrban = locationName && (
                    /New York|NYC|Manhattan|Brooklyn|Queens|Bronx|Staten Island/i.test(locationName) ||
                    /Chicago|Los Angeles|LA|San Francisco|SF|Seattle|Boston|Philadelphia|Washington DC|DC|Miami/i.test(locationName) ||
                    /Houston|Phoenix|Dallas|Austin|Denver|Portland|Atlanta|Detroit/i.test(locationName)
                );

                // Check OSM tags for urban indicators
                const hasUrbanTags = osmTags.building || osmTags['building:levels'] ||
                                    osmTags.highway || osmTags.amenity === 'restaurant' ||
                                    osmTags.shop || osmTags.office;

                const isCity = isUrban || hasUrbanTags;

                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    return {
                        category: 'viewpoint',
                        name: 'Viewpoint',
                        bestTime: 'Golden hour (sunrise/sunset)',
                        shotTypes: isCity
                            ? { cityscape: 70, architecture: 20, landscape: 10, nature: 0 }
                            : { landscape: 80, nature: 20, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.natural === 'water' || tags.natural === 'beach') {
                    return {
                        category: 'water',
                        name: 'Water Feature',
                        bestTime: 'Early morning for calm water',
                        shotTypes: isCity
                            ? { cityscape: 40, architecture: 20, landscape: 20, nature: 20 }
                            : { nature: 60, landscape: 40, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.leisure === 'park') {
                    return {
                        category: 'park',
                        name: 'Park',
                        bestTime: 'Golden hour',
                        shotTypes: isCity
                            ? { cityscape: 40, nature: 30, architecture: 20, landscape: 10 }
                            : { nature: 50, landscape: 30, cityscape: 20, architecture: 0 }
                    };
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return {
                        category: 'nature',
                        name: 'Nature Reserve',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 70, landscape: 30, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.man_made === 'tower') {
                    return {
                        category: 'architecture',
                        name: 'Observation Tower',
                        bestTime: 'Blue hour for city lights',
                        shotTypes: { architecture: 50, cityscape: 30, landscape: 20, nature: 0 }
                    };
                } else if (tags.historic === 'monument') {
                    return {
                        category: 'architecture',
                        name: 'Monument',
                        bestTime: 'Golden hour or blue hour',
                        shotTypes: { architecture: 60, cityscape: 30, landscape: 10, nature: 0 }
                    };
                } else if (tags.tourism === 'attraction' && tags.building) {
                    return {
                        category: 'architecture',
                        name: 'Landmark',
                        bestTime: 'Golden hour or blue hour',
                        shotTypes: { architecture: 50, cityscape: 40, landscape: 10, nature: 0 }
                    };
                } else if (tags.building === 'commercial' && tags['building:levels']) {
                    return {
                        category: 'cityscape',
                        name: 'High-Rise',
                        bestTime: 'Blue hour for city lights',
                        shotTypes: { cityscape: 70, architecture: 30, landscape: 0, nature: 0 }
                    };
                } else if (tags.amenity === 'place_of_worship') {
                    return {
                        category: 'architecture',
                        name: 'Place of Worship',
                        bestTime: 'Golden hour',
                        shotTypes: { architecture: 60, cityscape: 25, landscape: 15, nature: 0 }
                    };
                } else if (tags.leisure === 'stadium') {
                    return {
                        category: 'architecture',
                        name: 'Stadium',
                        bestTime: 'Event days or blue hour',
                        shotTypes: { architecture: 50, cityscape: 40, landscape: 10, nature: 0 }
                    };
                } else {
                    return {
                        category: 'landscape',
                        name: 'Scenic Spot',
                        bestTime: 'Golden hour',
                        shotTypes: isCity
                            ? { cityscape: 40, architecture: 30, landscape: 20, nature: 10 }
                            : { landscape: 50, nature: 30, cityscape: 10, architecture: 10 }
                    };
                }
            }

            // Helper: Convert meters to feet
            function metersToFeet(meters) {
                const feet = Math.round(meters * 3.28084);
                return feet.toLocaleString(); // Add comma separators for large numbers
            }

            // Generate description based on tags
            function generateDescription(tags, spotType, locationName = '') {
                // Use real OSM description if available
                if (tags.description) {
                    return tags.description;
                }

                // Build description from available OSM tags
                let parts = [];
                let context = [];

                // Add location context early if we have it and no city tag
                if (locationName && !tags['addr:city']) {
                    context.push(`near ${locationName}`);
                }

                // Primary feature description with more detail
                if (tags.natural === 'peak') {
                    parts.push(tags.ele ? `Mountain peak at ${metersToFeet(tags.ele)} ft elevation` : 'Mountain peak');
                } else if (tags.natural === 'beach') {
                    parts.push('Beach area');
                    if (tags.surface) parts.push(`${tags.surface} surface`);
                } else if (tags.natural === 'water') {
                    const waterType = tags.water || 'water';
                    parts.push(`${waterType.charAt(0).toUpperCase() + waterType.slice(1)}`);
                } else if (tags.tourism === 'viewpoint') {
                    // More specific viewpoint descriptions
                    if (tags.man_made === 'tower' || tags.building === 'yes') {
                        parts.push('Observation deck');
                    } else {
                        parts.push('Scenic viewpoint');
                    }
                    if (tags.ele) parts.push(`at ${metersToFeet(tags.ele)} ft elevation`);
                    if (tags.direction) parts.push(`facing ${tags.direction}`);
                } else if (tags.leisure === 'park') {
                    if (tags['park:type']) {
                        parts.push(`${tags['park:type']} park`.replace(/_/g, ' '));
                    } else {
                        parts.push('Public park');
                    }
                } else if (tags.leisure === 'nature_reserve') {
                    parts.push('Nature reserve');
                } else if (tags.landuse === 'forest') {
                    parts.push(tags.leaf_type ? `${tags.leaf_type} forest` : 'Forest area');
                } else if (tags.man_made === 'tower') {
                    if (tags['tower:type'] === 'observation') {
                        parts.push('Observation tower');
                    } else {
                        parts.push('Tower');
                    }
                    if (tags.height) parts.push(`${tags.height} tall`);
                } else if (tags.tourism === 'attraction') {
                    parts.push('Tourist attraction');
                } else if (tags.building) {
                    if (tags.building === 'commercial') parts.push('Commercial building');
                    else if (tags.building !== 'yes') parts.push(tags.building);
                }

                // Add contextual information
                if (tags['addr:city']) context.push(`in ${tags['addr:city']}`);
                if (tags.operator) context.push(`operated by ${tags.operator}`);
                if (tags.wikipedia || tags.wikidata) context.push('notable landmark');
                if (tags.heritage) context.push('historic site');
                if (tags.wheelchair === 'yes') context.push('accessible');

                // Add access warnings
                if (tags.access === 'private') {
                    context.push('‚ö†Ô∏è private property');
                } else if (tags.access === 'permissive') {
                    context.push('permission required');
                } else if (tags.fee === 'yes') {
                    context.push('admission fee');
                }

                // Build final description
                let desc = '';
                if (parts.length > 0) {
                    desc = parts.join(' ');
                    if (context.length > 0) {
                        desc += ` (${context.join(', ')})`;
                    }
                    desc += '. ' + getGenericDroneAdvice(tags, spotType);
                    return desc;
                }

                // If no specific parts, at least include context
                if (context.length > 0) {
                    const firstContext = context[0].charAt(0).toUpperCase() + context[0].slice(1);
                    desc = context.length > 1 ? firstContext + ', ' + context.slice(1).join(', ') : firstContext;
                    desc += '. ' + getGenericDroneAdvice(tags, spotType);
                    return desc;
                }

                // Fallback to generic description
                return getGenericDroneAdvice(tags, spotType);
            }

            // Get contextual drone photography advice based on spot type
            function getGenericDroneAdvice(tags, spotType) {
                // More descriptive, less generic advice
                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    if (tags.man_made === 'tower' || tags.building) {
                        return 'Elevated observation point with panoramic views. Ideal for 360¬∞ aerial shots and wide-angle landscape footage.';
                    }
                    return 'Scenic overlook offering expansive views. Perfect for panoramic aerial shots and sunrise/sunset captures.';
                } else if (tags.natural === 'water') {
                    const waterType = tags.water;
                    if (waterType === 'lake' || waterType === 'reservoir') {
                        return 'Water feature with potential for reflection shots. Best for calm morning captures with mirror-like surface effects.';
                    } else if (waterType === 'river') {
                        return 'Flowing water feature. Great for dynamic footage following waterways and capturing movement.';
                    }
                    return 'Natural water area. Excellent for capturing reflections, waterscapes, and aerial perspectives of aquatic environments.';
                } else if (tags.natural === 'beach') {
                    return 'Coastal area with beach access. Perfect for shoreline tracking shots, wave patterns, and coastal landscapes.';
                } else if (tags.leisure === 'park') {
                    return 'Public park with open green space. Good for varied terrain shots, tree canopy patterns, and recreational area footage.';
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return 'Protected natural area. Excellent for wildlife habitat views, forest canopy footage, and ecological landscapes.';
                } else if (tags.tourism === 'attraction') {
                    return 'Notable point of interest. Suitable for architectural details, crowd dynamics, and tourist area perspectives.';
                } else {
                    return 'Drone-friendly location with aerial photography opportunities. Check local regulations before flying.';
                }
            }

            // Generate flight instructions
            function generateFlightInstructions(spotType, tags) {
                if (spotType.category === 'viewpoint') {
                    return 'Launch from designated area. Ascend to 200-300 ft AGL for panoramic shots. Capture 360¬∞ orbit and reveal shots.';
                } else if (spotType.category === 'water') {
                    return 'Launch from shoreline. Fly low (50-150 ft AGL) to capture reflections. Use slow tracking shots parallel to water.';
                } else if (spotType.category === 'park') {
                    return 'Launch from open area. Mix of altitudes: low for detail (100 ft), medium for context (200 ft), high for establishing (300 ft).';
                } else {
                    return 'Survey area from 200 ft AGL. Identify key features. Capture varied angles and perspectives. Maintain safe distances from obstacles.';
                }
            }

            // Get image URL based on spot type
            function getImageForSpotType(category) {
                const images = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return images[category] || images.landscape;
            }

            // Calculate risk score based on tags
            function calculateRiskScore(tags, spotType) {
                let score = 75; // Base score

                // Increase score for nature/open areas
                if (tags.natural || tags.leisure === 'park' || tags.leisure === 'nature_reserve') {
                    score += 10;
                }

                // Decrease score for urban/complex areas
                if (tags.man_made || tags.building) {
                    score -= 15;
                }

                // Adjust for accessibility
                if (tags.access === 'private') {
                    score -= 20;
                }

                return Math.max(50, Math.min(95, score));
            }

            // Calculate adjusted risk score based on learning
            function getAdjustedRiskScore(spot) {
                const baseScore = spot.riskScore;
                if (state.ratings.length === 0) return baseScore;

                const shotTypeRatings = {};
                const shotTypeCounts = {};

                state.ratings.forEach(rating => {
                    const flight = state.flights.find(f => f.id === rating.flightId);
                    if (flight && flight.spotData && flight.spotData.shotTypes) {
                        const shotTypes = flight.spotData.shotTypes;
                        const dominantType = Object.keys(shotTypes).reduce((a, b) =>
                            shotTypes[a] > shotTypes[b] ? a : b
                        );

                        if (!shotTypeRatings[dominantType]) {
                            shotTypeRatings[dominantType] = 0;
                            shotTypeCounts[dominantType] = 0;
                        }

                        const avgRating = (rating.descAccuracy + rating.shotTypeMatch + rating.accessibility) / 3;
                        shotTypeRatings[dominantType] += avgRating;
                        shotTypeCounts[dominantType]++;
                    }
                });

                Object.keys(shotTypeRatings).forEach(type => {
                    shotTypeRatings[type] = shotTypeRatings[type] / shotTypeCounts[type];
                });

                const dominantType = Object.keys(spot.shotTypes).reduce((a, b) =>
                    spot.shotTypes[a] > spot.shotTypes[b] ? a : b
                );

                if (shotTypeRatings[dominantType]) {
                    const avgRating = shotTypeRatings[dominantType];
                    const adjustedScore = baseScore * (avgRating / 3);
                    return Math.round(Math.max(1, Math.min(100, adjustedScore)));
                }

                return baseScore;
            }

            // V9.0: Calculate preference match score for spot ranking
            function calculatePreferenceMatch(shotTypes, preferences) {
                if (!shotTypes || !preferences) return 50;

                // Map slider values to shot type weights
                // Cityscape slider: 0=landscape, 100=cityscape
                const cityscapeWeight = preferences.cityscape / 100;
                const landscapeWeight = (100 - preferences.cityscape) / 100;

                // Nature slider: 0=architecture, 100=nature
                const natureWeight = preferences.nature / 100;
                const architectureWeight = (100 - preferences.nature) / 100;

                // Calculate weighted match
                const match =
                    (shotTypes.cityscape || 0) * cityscapeWeight +
                    (shotTypes.landscape || 0) * landscapeWeight +
                    (shotTypes.nature || 0) * natureWeight +
                    (shotTypes.architecture || 0) * architectureWeight;

                // Normalize (shotTypes sum to ~100)
                const totalShotTypeValue = Object.values(shotTypes).reduce((a, b) => a + b, 0);
                const preferenceScore = totalShotTypeValue > 0 ? (match / totalShotTypeValue) * 100 : 50;

                return Math.round(preferenceScore);
            }

            // V9.0: Calculate spot score combining distance and preference match
            function calculateSpotScore(spot, searchCenter, preferences) {
                if (!searchCenter) {
                    // Fallback to risk score if no search center
                    return spot.riskScore || 50;
                }

                // Distance component (0-100, closer = higher)
                const distance = parseFloat(spot.distance) || 0;
                const maxDistance = 25; // miles
                const distanceScore = Math.max(0, 100 - (distance / maxDistance * 100));

                // Preference match component (0-100)
                const preferenceScore = calculatePreferenceMatch(spot.shotTypes, preferences);

                // Combine: 40% distance + 60% preference
                const finalScore = (distanceScore * 0.4) + (preferenceScore * 0.6);

                return Math.round(finalScore);
            }

            // V9.0: Get match badge color based on percentage
            function getMatchColor(percentage) {
                if (percentage >= 90) return '#22c55e'; // Green
                if (percentage >= 70) return '#eab308'; // Yellow
                if (percentage >= 50) return '#f97316'; // Orange
                return '#94a3b8'; // Gray
            }

            // V9.0: Get match label based on percentage
            function getMatchLabel(percentage) {
                if (percentage >= 90) return 'Perfect Match';
                if (percentage >= 70) return 'Good Match';
                if (percentage >= 50) return 'Moderate Match';
                return 'Low Match';
            }

            // V9.0: Count spots by dominant shot type
            function countSpotsByType(type) {
                return state.spots.filter(spot => {
                    if (!spot.shotTypes) return false;
                    const dominant = Object.keys(spot.shotTypes).reduce((a, b) =>
                        spot.shotTypes[a] > spot.shotTypes[b] ? a : b
                    );
                    return dominant === type;
                }).length;
            }

            // Cloud sync functions
            async function checkConnection() {
                try {
                    state.syncSettings.connectionStatus = 'checking';
                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (response.ok) {
                        state.syncSettings.connectionStatus = 'connected';
                        console.log('Connection check successful:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status
                        });
                    } else {
                        state.syncSettings.connectionStatus = 'error';
                        const errorText = await response.text();
                        console.error('Connection check failed:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status,
                            statusText: response.statusText,
                            body: errorText
                        });
                    }
                } catch (error) {
                    state.syncSettings.connectionStatus = 'error';
                    console.error('Connection check error:', {
                        message: error.message,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                }
            }

            async function syncFlights() {
                try {
                    state.syncMessage = { type: 'info', text: 'Syncing...' };
                    render();

                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Sync failed');

                    const data = await response.json();

                    if (data.flights && Array.isArray(data.flights)) {
                        data.flights.forEach(flight => {
                            const existingIndex = state.flights.findIndex(f => f.id === flight.id && f.type === 'synced');
                            const processedFlight = {
                                id: flight.id,
                                type: 'synced',
                                synced: true, // V7.1: Flag for showing "View Flight Path" button
                                name: flight.name || `Flight ${new Date(flight.created_at).toLocaleDateString()}`,
                                date: flight.created_at,
                                created_at: flight.created_at,
                                duration: flight.duration_seconds,
                                duration_seconds: flight.duration_seconds,
                                location: flight.location || null,
                                notes: '',
                                mediaUrls: flight.media_urls || [],
                                syncedAt: new Date().toISOString(),
                                metadata: flight.metadata || {}
                            };

                            if (existingIndex >= 0) {
                                processedFlight.notes = state.flights[existingIndex].notes || '';
                                processedFlight.locationName = state.flights[existingIndex].locationName || null;
                                state.flights[existingIndex] = processedFlight;
                            } else {
                                state.flights.unshift(processedFlight);
                            }
                        });
                    }

                    state.syncSettings.lastSync = new Date().toISOString();
                    state.syncSettings.connectionStatus = 'connected';
                    state.syncMessage = { type: 'success', text: `Synced ${data.flights ? data.flights.length : 0} flights. Resolving locations...` };
                    saveToStorage('flights', state.flights);
                    saveToStorage('syncSettings', state.syncSettings);
                    render();

                    // Reverse geocode locations for newly synced flights (rate limited)
                    await reverseGeocodeAllFlights();
                } catch (error) {
                    console.error('Sync error:', {
                        message: error.message,
                        stack: error.stack,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                    state.syncSettings.connectionStatus = 'error';
                    state.syncMessage = {
                        type: 'error',
                        text: `Sync failed: ${error.message}. Check console for details.`
                    };
                    render();
                }
            }

            // Fetch detailed flight data including telemetry track
            async function fetchFlightDetails(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/details`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight details');

                    const data = await response.json();

                    if (data.success) {
                        return {
                            flight: data.flight,
                            telemetry: data.telemetry
                        };
                    }

                    return null;
                } catch (error) {
                    console.error('Error fetching flight details:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight details: ${error.message}` };
                    render();
                    return null;
                }
            }

            // Fetch media (photos/videos) for a flight
            async function fetchFlightMedia(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/media`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight media');

                    const data = await response.json();

                    if (data.success) {
                        return data.media;
                    }

                    return [];
                } catch (error) {
                    console.error('Error fetching flight media:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load media: ${error.message}` };
                    render();
                    return [];
                }
            }

            // Load complete flight data (details + media)
            async function loadSyncedFlightData(flightId) {
                state.syncMessage = { type: 'info', text: 'Loading flight data...' };
                render();

                const [details, media] = await Promise.all([
                    fetchFlightDetails(flightId),
                    fetchFlightMedia(flightId)
                ]);

                if (details) {
                    // Update the flight in state with detailed data
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0) {
                        state.flights[flightIndex] = {
                            ...state.flights[flightIndex],
                            details: details.flight,
                            telemetry: details.telemetry,
                            mediaUrls: media.map(m => m.downloadUrl),
                            mediaDetails: media
                        };
                        saveToStorage('flights', state.flights);
                    }

                    state.syncMessage = { type: 'success', text: 'Flight data loaded' };
                    render();
                    return { details, media };
                }

                return null;
            }

            // View flight path on map
            async function viewFlightPath(flightId) {
                try {
                    // Show loading message
                    state.syncMessage = { type: 'info', text: 'Loading flight path...' };

                    // Fetch flight details with telemetry FIRST
                    const details = await fetchFlightDetails(flightId);

                    if (!details || !details.telemetry || !details.telemetry.track) {
                        state.syncMessage = { type: 'error', text: 'No telemetry data available for this flight' };
                        render();
                        return;
                    }

                    // CRITICAL: Save telemetry to flight object in state so it persists
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0) {
                        state.flights[flightIndex] = {
                            ...state.flights[flightIndex],
                            telemetry: details.telemetry,
                            details: details.flight
                        };
                        saveToStorage('flights', state.flights);
                        console.log('Telemetry saved for flight:', flightId, details.telemetry.stats);
                    }

                    // Display comprehensive field report in console
                    if (details.telemetry?.fieldReport) {
                        console.log('=== üìä TELEMETRY FIELD REPORT ===');
                        console.log('Available Fields:', details.telemetry.fieldReport.fields);
                        console.log('Total Field Count:', details.telemetry.fieldReport.fieldCount);
                        console.log('\n=== DETAILED FIELD ANALYSIS ===');

                        Object.entries(details.telemetry.fieldReport.analysis).forEach(([fieldName, analysis]) => {
                            console.log(`\n${fieldName}:`);
                            console.log('  ', analysis);
                        });

                        console.log('\n=== END FIELD REPORT ===\n');
                    }

                    // Switch to planner tab and render
                    state.currentTab = 'planner';
                    render();

                    // CRITICAL: Wait for tab transition and DOM to be fully ready
                    // Use requestAnimationFrame to ensure DOM is painted before creating map
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await new Promise(resolve => requestAnimationFrame(resolve));

                    // Clean up old map if exists
                    if (state.map) {
                        state.map.remove();
                        state.map = null;
                    }

                    // Get map container
                    const mapContainer = document.getElementById('mapContainer');
                    if (!mapContainer) {
                        console.error('Map container not found!');
                        return;
                    }

                    console.log('Container dimensions:', mapContainer.offsetWidth, 'x', mapContainer.offsetHeight);

                    // Convert telemetry to LatLng array - AGGRESSIVE FILTERING
                    // First pass: get all non-zero points
                    const allPoints = details.telemetry.track
                        .filter(point => point.lat !== 0 && point.lon !== 0)
                        .map(point => [point.lat, point.lon]);

                    console.log('All non-zero points:', allPoints.length);

                    // Calculate median lat/lon to find the center of the actual flight
                    const lats = allPoints.map(p => p[0]).sort((a, b) => a - b);
                    const lons = allPoints.map(p => p[1]).sort((a, b) => a - b);
                    const medianLat = lats[Math.floor(lats.length / 2)];
                    const medianLon = lons[Math.floor(lons.length / 2)];

                    console.log('Median center:', medianLat, medianLon);

                    // Second pass: keep only points within ~50 miles (~0.7 degrees) of median
                    // This removes GPS errors that place points in different states/countries
                    const pathCoords = allPoints.filter(point => {
                        const latDiff = Math.abs(point[0] - medianLat);
                        const lonDiff = Math.abs(point[1] - medianLon);
                        return latDiff < 0.7 && lonDiff < 0.7;
                    });

                    console.log('Path coordinates (filtered):', pathCoords.length, 'First:', pathCoords[0], 'Last:', pathCoords[pathCoords.length-1]);

                    if (pathCoords.length === 0) {
                        console.error('No valid GPS coordinates in telemetry!');
                        return;
                    }

                    // CRITICAL: Reduce point density if too many points (performance optimization)
                    // Too many points (1000+) can cause rendering issues and prevent tiles from loading
                    let displayCoords = pathCoords;
                    if (pathCoords.length > 200) {
                        const skipFactor = Math.ceil(pathCoords.length / 200);
                        displayCoords = pathCoords.filter((_, index) => index % skipFactor === 0);
                        // Always include last point
                        if (!displayCoords.includes(pathCoords[pathCoords.length - 1])) {
                            displayCoords.push(pathCoords[pathCoords.length - 1]);
                        }
                        console.log(`Reduced ${pathCoords.length} points to ${displayCoords.length} for display (skip factor: ${skipFactor})`);
                    }

                    // Create map - start with a default view, will adjust with fitBounds
                    const centerPoint = displayCoords[Math.floor(displayCoords.length / 2)];
                    state.map = L.map('mapContainer').setView(centerPoint, 15);

                    // Add OpenStreetMap tiles - SIMPLE approach
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(state.map);

                    console.log('Map created, drawing flight path with', displayCoords.length, 'points');

                    // Draw flight path on map (using reduced point set)
                    const flightPath = L.polyline(displayCoords, {
                        color: '#2563eb',
                        weight: 3,
                        opacity: 0.8,
                        className: 'flight-path'
                    }).addTo(state.map);

                    // Automatically fit map to show entire flight path
                    // CRITICAL: Disable animation to prevent tile request cancellation
                    state.map.fitBounds(flightPath.getBounds(), {
                        padding: [50, 50],
                        animate: false  // No zoom animation = no tile cancellation
                    });

                    console.log('Flight path added, map fitted to bounds');

                    // Force tile loading after bounds are set
                    state.map.invalidateSize();

                    console.log('Map invalidated, tiles should load now');

                    // Add markers for takeoff and landing
                    const startPoint = pathCoords[0];
                    const endPoint = pathCoords[pathCoords.length - 1];

                    L.marker(startPoint, {
                        icon: L.divIcon({
                            html: 'üõ´',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Takeoff</b><br>${details.flight.vehicleSerial}`);

                    L.marker(endPoint, {
                        icon: L.divIcon({
                            html: 'üõ¨',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Landing</b><br>${details.flight.vehicleSerial}`);

                    // Fit map to show entire flight path
                    state.map.fitBounds(flightPath.getBounds(), { padding: [50, 50] });

                    // Force another size recalculation after zoom
                    setTimeout(() => {
                        state.map.invalidateSize();
                    }, 100);

                    // SUCCESS! Don't call render() here - it would destroy the map we just created
                    // Just update the message element directly
                    state.syncMessage = { type: 'success', text: `Flight path loaded (${details.telemetry.pointCount} points)` };
                    console.log('‚úÖ Flight path rendering complete - map should be visible');
                } catch (error) {
                    console.error('Error viewing flight path:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight path: ${error.message}` };
                    render();
                }
            }

            // Load flight map inline (no tab switching)
            async function loadInlineFlightMap(flightId) {
                try {
                    const mapContainerId = `inline-map-${flightId}`;
                    const mapContainer = document.getElementById(mapContainerId);

                    if (!mapContainer) {
                        console.error('Inline map container not found:', mapContainerId);
                        return;
                    }

                    // Show loading state
                    mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #666;"><span class="spinner"></span> Loading map...</div>';

                    // Check if telemetry is already loaded
                    const flight = state.flights.find(f => f.id === flightId);
                    let telemetry = flight?.telemetry;

                    // If not loaded, fetch it
                    if (!telemetry) {
                        const details = await fetchFlightDetails(flightId);
                        if (!details || !details.telemetry || !details.telemetry.track) {
                            mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #999;">No telemetry data available</div>';
                            return;
                        }

                        // Save to state
                        const flightIndex = state.flights.findIndex(f => f.id === flightId);
                        if (flightIndex >= 0) {
                            state.flights[flightIndex] = {
                                ...state.flights[flightIndex],
                                telemetry: details.telemetry,
                                details: details.flight
                            };
                            saveToStorage('flights', state.flights);
                        }

                        telemetry = details.telemetry;
                    }

                    // Clear container for map
                    mapContainer.innerHTML = '';

                    // Process GPS coordinates (same filtering as viewFlightPath)
                    const allPoints = telemetry.track
                        .filter(point => point.lat !== 0 && point.lon !== 0)
                        .map(point => [point.lat, point.lon]);

                    const lats = allPoints.map(p => p[0]).sort((a, b) => a - b);
                    const lons = allPoints.map(p => p[1]).sort((a, b) => a - b);
                    const medianLat = lats[Math.floor(lats.length / 2)];
                    const medianLon = lons[Math.floor(lons.length / 2)];

                    const pathCoords = allPoints.filter(point => {
                        const latDiff = Math.abs(point[0] - medianLat);
                        const lonDiff = Math.abs(point[1] - medianLon);
                        return latDiff < 0.7 && lonDiff < 0.7;
                    });

                    if (pathCoords.length === 0) {
                        mapContainer.innerHTML = '<div style="text-align: center; padding: 180px 20px; color: #999;">No valid GPS coordinates</div>';
                        return;
                    }

                    // Reduce points for performance
                    let displayCoords = pathCoords;
                    if (pathCoords.length > 500) {
                        const skipFactor = Math.ceil(pathCoords.length / 500);
                        displayCoords = pathCoords.filter((_, idx) => idx % skipFactor === 0);
                    }

                    // Create map
                    const map = L.map(mapContainer, {
                        scrollWheelZoom: true,
                        dragging: true,
                        touchZoom: true,
                        doubleClickZoom: true
                    }).setView([medianLat, medianLon], 15);

                    // Add tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap',
                        crossOrigin: true,
                        maxZoom: 19
                    }).addTo(map);

                    // Draw flight path
                    const flightPath = L.polyline(displayCoords, {
                        color: '#1e3c72',
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);

                    // Add start and end markers
                    L.marker(displayCoords[0], {
                        icon: L.divIcon({
                            className: 'start-marker',
                            html: '<div style="background: #22c55e; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">S</div>',
                            iconSize: [24, 24]
                        })
                    }).addTo(map).bindPopup('Start');

                    L.marker(displayCoords[displayCoords.length - 1], {
                        icon: L.divIcon({
                            className: 'end-marker',
                            html: '<div style="background: #ef4444; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">E</div>',
                            iconSize: [24, 24]
                        })
                    }).addTo(map).bindPopup('End');

                    // Fit to path
                    map.fitBounds(flightPath.getBounds(), {
                        padding: [30, 30],
                        maxZoom: 16
                    });

                    // Force size calculation
                    setTimeout(() => map.invalidateSize(), 100);

                    // Store map reference
                    if (!state.inlineMaps) state.inlineMaps = {};
                    state.inlineMaps[flightId] = map;

                    console.log('‚úÖ Inline map loaded successfully for flight:', flightId);

                    // Update telemetry display if it exists
                    const telemetryDetails = document.querySelector(`.telemetry-details[data-flight-id="${flightId}"]`);
                    if (telemetryDetails && telemetry.stats) {
                        const telemetryContent = telemetryDetails.querySelector('div[style*="padding: 12px"]');
                        if (telemetryContent) {
                            telemetryContent.innerHTML = renderAllTelemetryStats(telemetry.stats);
                        }
                    }

                    // Reverse geocode location if not already done
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0 && !state.flights[flightIndex].locationName && displayCoords.length > 0) {
                        // Use first coordinate (launch point)
                        const [lat, lon] = displayCoords[0];
                        const locationName = await reverseGeocode(lat, lon);

                        if (locationName) {
                            state.flights[flightIndex].locationName = locationName;
                            saveToStorage('flights', state.flights);

                            // Update the flight card title
                            const flightCard = document.getElementById(`flight-card-${flightId}`);
                            if (flightCard) {
                                const flightTitle = flightCard.querySelector('.flight-location');
                                if (flightTitle) {
                                    const newName = generateFlightName(state.flights[flightIndex]);
                                    // Keep the badges, just update the text
                                    const badges = flightTitle.querySelectorAll('.badge');
                                    flightTitle.innerHTML = newName;
                                    badges.forEach(badge => flightTitle.appendChild(badge));
                                }
                            }

                            console.log('üìç Location resolved:', locationName);
                        }
                    }

                } catch (error) {
                    console.error('Error loading inline map:', error);
                    const mapContainer = document.getElementById(`inline-map-${flightId}`);
                    if (mapContainer) {
                        mapContainer.innerHTML = `<div style="text-align: center; padding: 180px 20px; color: #e74c3c;">Error: ${error.message}</div>`;
                    }
                }
            }

            function formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            // Generate descriptive flight name with drone model, time of day, location, and duration
            function generateFlightName(flight) {
                const date = new Date(flight.created_at || flight.date);
                const hour = date.getHours();

                // Time of day
                let timeOfDay = '';
                if (hour >= 5 && hour < 12) timeOfDay = 'Morning';
                else if (hour >= 12 && hour < 17) timeOfDay = 'Afternoon';
                else if (hour >= 17 && hour < 21) timeOfDay = 'Evening';
                else timeOfDay = 'Night';

                // Drone model from vehicle serial or flight name
                let droneModel = '';
                if (flight.metadata?.vehicle_serial) {
                    droneModel = flight.metadata.vehicle_serial;
                } else if (flight.name && flight.name.includes('Skydio')) {
                    // Extract model from name like "SkydioX10-r6h6 Flight"
                    const match = flight.name.match(/Skydio[^\s]+/);
                    if (match) droneModel = match[0];
                }

                // Duration
                const duration = flight.duration_seconds || flight.duration || 0;
                const durationMin = Math.round(duration / 60);

                // Location from cached reverse geocode or from flight object
                const location = flight.locationName || '';

                // Build descriptive name
                if (droneModel && location) {
                    return `${droneModel} - ${timeOfDay} in ${location} (${durationMin}m)`;
                } else if (droneModel) {
                    return `${droneModel} - ${timeOfDay} Flight (${durationMin}m)`;
                } else {
                    return `${timeOfDay} Flight (${durationMin}m)`;
                }
            }

            // Reverse geocode GPS coordinates to get city, state
            async function reverseGeocode(lat, lon) {
                try {
                    // Use Nominatim (OpenStreetMap's geocoding service)
                    // Rate limit: max 1 request per second
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`,
                        {
                            headers: {
                                'User-Agent': 'DroneScout/1.0 (https://bgslab.github.io/dronescout)'
                            }
                        }
                    );

                    if (!response.ok) return null;

                    const data = await response.json();
                    const address = data.address;

                    // Build location string: City, State or Town, State
                    const city = address.city || address.town || address.village || address.county;
                    const state = address.state;

                    if (city && state) {
                        return `${city}, ${state}`;
                    } else if (city) {
                        return city;
                    } else if (state) {
                        return state;
                    }

                    return null;
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    return null;
                }
            }

            // Reverse geocode all flights that don't have location names yet
            async function reverseGeocodeAllFlights() {
                // Find flights that need geocoding
                const flightsNeedingGeocode = state.flights.filter(f =>
                    f.synced &&
                    !f.locationName &&
                    f.location?.lat &&
                    f.location?.lon
                );

                if (flightsNeedingGeocode.length === 0) {
                    console.log('No flights need geocoding');
                    state.syncMessage = { type: 'success', text: `Synced ${state.flights.filter(f => f.synced).length} flights` };
                    render();
                    return;
                }

                console.log(`Geocoding ${flightsNeedingGeocode.length} flights...`);

                // Process flights one at a time with 1 second delay (Nominatim rate limit)
                for (let i = 0; i < flightsNeedingGeocode.length; i++) {
                    const flight = flightsNeedingGeocode[i];

                    // Update progress message
                    state.syncMessage = {
                        type: 'info',
                        text: `Resolving locations... (${i + 1}/${flightsNeedingGeocode.length})`
                    };
                    render();

                    // Reverse geocode
                    const locationName = await reverseGeocode(flight.location.lat, flight.location.lon);

                    if (locationName) {
                        // Update flight in state
                        const flightIndex = state.flights.findIndex(f => f.id === flight.id);
                        if (flightIndex >= 0) {
                            state.flights[flightIndex].locationName = locationName;
                            console.log(`üìç ${flight.name} ‚Üí ${locationName}`);
                        }
                    }

                    // Wait 1 second before next request (rate limiting)
                    if (i < flightsNeedingGeocode.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                // Save and update UI
                saveToStorage('flights', state.flights);
                state.syncMessage = {
                    type: 'success',
                    text: `Synced ${state.flights.filter(f => f.synced).length} flights with locations`
                };
                render();
                console.log('‚úÖ All flights geocoded');
            }

            // Render telemetry stats - ONLY Speed, Altitude, Distance
            function renderAllTelemetryStats(stats) {
                console.log('üéØ Rendering telemetry stats:', stats);
                console.log('velocity field exists?', !!stats.velocity);
                console.log('velocity data:', stats.velocity);

                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 13px;">';

                // 1. SPEED (from velocity field)
                if (stats.velocity && stats.velocity.max != null) {
                    const maxSpeedMph = (stats.velocity.max * 2.23694).toFixed(1);
                    const maxSpeedMs = stats.velocity.max.toFixed(1);
                    const avgSpeedMph = (stats.velocity.avg * 2.23694).toFixed(1);
                    const avgSpeedMs = stats.velocity.avg.toFixed(1);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Speed</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxSpeedMph} mph</div>
                            <div style="color: #999; font-size: 11px;">${maxSpeedMs} m/s</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Avg Speed</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgSpeedMph} mph</div>
                            <div style="color: #999; font-size: 11px;">${avgSpeedMs} m/s</div>
                        </div>
                    `;
                } else {
                    console.warn('‚ö†Ô∏è Velocity field missing or invalid:', stats.velocity);
                }

                // 2. ALTITUDE (from height_above_takeoff field)
                if (stats.height_above_takeoff) {
                    const maxAltFt = (stats.height_above_takeoff.max * 3.28084).toFixed(0);
                    const maxAltM = stats.height_above_takeoff.max.toFixed(1);
                    const avgAltFt = (stats.height_above_takeoff.avg * 3.28084).toFixed(0);
                    const avgAltM = stats.height_above_takeoff.avg.toFixed(1);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Altitude</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxAltFt} ft</div>
                            <div style="color: #999; font-size: 11px;">${maxAltM} m AGL</div>
                        </div>
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Avg Altitude</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgAltFt} ft</div>
                            <div style="color: #999; font-size: 11px;">${avgAltM} m AGL</div>
                        </div>
                    `;
                }

                // 3. DISTANCE METRICS (calculated from GPS track)
                if (stats._distance_traveled) {
                    const distMiles = stats._distance_traveled.miles.toFixed(2);
                    const distKm = stats._distance_traveled.kilometers.toFixed(2);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Distance Traveled</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${distMiles} mi</div>
                            <div style="color: #999; font-size: 11px;">${distKm} km</div>
                        </div>
                    `;
                }

                if (stats._max_distance_from_launch) {
                    const maxDistMiles = stats._max_distance_from_launch.miles.toFixed(2);
                    const maxDistFeet = stats._max_distance_from_launch.feet.toFixed(0);

                    html += `
                        <div>
                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Range from Launch</div>
                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${maxDistMiles} mi</div>
                            <div style="color: #999; font-size: 11px;">${maxDistFeet} ft</div>
                        </div>
                    `;
                }

                html += '</div>';
                return html;
            }

            // OLD COMPLEX FUNCTION - REMOVED
            function renderAllTelemetryStats_OLD(stats) {
                // Field display configuration with units and formatting
                // Based on actual Skydio API fields (see field report in console)
                const fieldConfig = {
                    // Speed field (Skydio calls it 'velocity')
                    velocity: { label: 'Speed', unit: 'speed', decimals: 1, showMinMax: true },

                    // Height/Altitude fields
                    height_above_takeoff: { label: 'Height AGL', unit: 'distance', decimals: 0, showMinMax: true },
                    hybrid_altitude: { label: 'Altitude', unit: 'distance', decimals: 0, showMinMax: true },
                    altitude: { label: 'Altitude (broken)', unit: 'distance', decimals: 0, showMinMax: true }, // All zeros

                    // Battery field
                    battery_percentage: { label: 'Battery', unit: 'percent', decimals: 0, showChange: true },

                    // GPS Quality fields
                    gps_num_satellites: { label: 'GPS Satellites', unit: 'count', decimals: 0, showMinMax: false },
                    horizontal_accuracy_estimate: { label: 'GPS H-Accuracy', unit: 'distance', decimals: 2, showMinMax: false },
                    vertical_accuracy_estimate: { label: 'GPS V-Accuracy', unit: 'distance', decimals: 2, showMinMax: false },
                };

                // Unit conversion and formatting functions
                function formatValue(value, unitType, decimals) {
                    if (value == null) return 'N/A';

                    switch(unitType) {
                        case 'speed':
                            // m/s to mph
                            return {
                                primary: `${(value * 2.23694).toFixed(decimals)} mph`,
                                secondary: `${value.toFixed(decimals)} m/s`
                            };
                        case 'distance':
                            // m to ft
                            return {
                                primary: `${(value * 3.28084).toFixed(decimals)} ft`,
                                secondary: `${value.toFixed(decimals)} m`
                            };
                        case 'percent':
                            return {
                                primary: `${value.toFixed(decimals)}%`,
                                secondary: null
                            };
                        case 'degrees':
                            return {
                                primary: `${value.toFixed(decimals)}¬∞`,
                                secondary: null
                            };
                        case 'count':
                            return {
                                primary: Math.round(value).toString(),
                                secondary: null
                            };
                        default:
                            return {
                                primary: value.toFixed(decimals),
                                secondary: null
                            };
                    }
                }

                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 13px;">';

                // Render each field that exists in stats
                Object.entries(stats).forEach(([fieldName, fieldStats]) => {
                    const config = fieldConfig[fieldName];
                    if (!config) {
                        // Unknown field - render with basic formatting
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${fieldName.replace(/_/g, ' ')}</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">
                                    Min: ${fieldStats.min?.toFixed(2)}<br>
                                    Max: ${fieldStats.max?.toFixed(2)}<br>
                                    Avg: ${fieldStats.avg?.toFixed(2)}
                                </div>
                                <div style="color: #999; font-size: 11px;">${fieldStats.count} points</div>
                            </div>
                        `;
                        return;
                    }

                    // Check if field has valid data (not all zeros for non-percentage fields)
                    if (!fieldStats.hasNonZero && config.unit !== 'percent') {
                        return; // Skip fields with all zeros
                    }

                    const maxFormatted = formatValue(fieldStats.max, config.unit, config.decimals);
                    const avgFormatted = formatValue(fieldStats.avg, config.unit, config.decimals);
                    const minFormatted = formatValue(fieldStats.min, config.unit, config.decimals);
                    const changeFormatted = formatValue(Math.abs(fieldStats.change), config.unit, config.decimals);

                    if (config.showMinMax) {
                        // Show min/max/avg
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label}</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">
                                    Max: ${maxFormatted.primary}
                                </div>
                                <div style="color: #999; font-size: 11px;">
                                    ${maxFormatted.secondary || ''}
                                    ${maxFormatted.secondary ? '<br>' : ''}
                                    Avg: ${avgFormatted.primary}
                                </div>
                            </div>
                        `;
                    } else if (config.showChange) {
                        // Show start/end/change (for battery)
                        const startFormatted = formatValue(fieldStats.start, config.unit, config.decimals);
                        const endFormatted = formatValue(fieldStats.end, config.unit, config.decimals);
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label} Used</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${changeFormatted.primary}</div>
                                <div style="color: #999; font-size: 11px;">${startFormatted.primary} ‚Üí ${endFormatted.primary}</div>
                            </div>
                        `;
                    } else {
                        // Show average only (for directional fields)
                        html += `
                            <div>
                                <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">${config.label} (avg)</div>
                                <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${avgFormatted.primary}</div>
                                <div style="color: #999; font-size: 11px;">Range: ${minFormatted.primary} - ${maxFormatted.primary}</div>
                            </div>
                        `;
                    }
                });

                html += '</div>';
                return html;
            }

            // V6: Map initialization and management
            function initMap() {
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    console.error('Leaflet not loaded');
                    return;
                }

                const mapContainer = document.getElementById('mapContainer');
                if (!mapContainer) {
                    console.error('Map container not found');
                    return;
                }

                console.log('Initializing map with', state.spots.length, 'spots');

                // Remove existing map if it exists
                if (state.map) {
                    state.map.remove();
                    state.map = null;
                }

                // Clear existing markers
                state.mapMarkers = [];

                // V6.1: Remove existing route polyline if present
                if (state.routePolyline) {
                    state.routePolyline.remove();
                    state.routePolyline = null;
                }

                // Use destination coords if available, otherwise center on first spot
                let centerLat, centerLng, zoom;

                if (state.destinationCoords) {
                    centerLat = state.destinationCoords.lat;
                    centerLng = state.destinationCoords.lng;
                    zoom = 12;
                } else if (state.spots.length > 0 && state.spots[0].coordinates) {
                    // Use first spot's coordinates as fallback
                    centerLat = state.spots[0].coordinates.lat || 40.7128;
                    centerLng = state.spots[0].coordinates.lng || -74.0060;
                    zoom = 12;
                } else {
                    // Default to NYC
                    centerLat = 40.7128;
                    centerLng = -74.0060;
                    zoom = 10;
                }

                // Initialize the map
                state.map = L.map('mapContainer').setView([centerLat, centerLng], zoom);

                // Add OpenStreetMap tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19
                }).addTo(state.map);

                // Add user location marker if available
                if (state.userLocation) {
                    const userMarker = L.marker([state.userLocation.lat, state.userLocation.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-user',
                            html: '<div style="background: #4285f4; color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.3), 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">üìç</div>',
                            iconSize: [26, 26],
                            iconAnchor: [13, 13]
                        })
                    }).addTo(state.map);

                    userMarker.bindPopup('<b>üìç Your Location</b>');
                    state.mapMarkers.push(userMarker);
                }

                // Add destination marker if coords available
                if (state.destinationCoords) {
                    const destinationMarker = L.marker([state.destinationCoords.lat, state.destinationCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-destination',
                            html: '<div style="background: #00d4ff; color: white; padding: 8px 12px; border-radius: 20px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üéØ Destination</div>',
                            iconSize: [130, 40],
                            iconAnchor: [65, 40]
                        })
                    }).addTo(state.map);

                    destinationMarker.bindPopup(`<b>${state.destination}</b><br>${state.destinationCoords.displayName || ''}`);
                }

                // V6.1: Filter spots based on favorites toggle
                const spotsToShow = state.showFavoritesOnly
                    ? state.spots.filter(s => state.favorites.includes(s.id))
                    : state.spots;

                // Add markers for each spot
                let markerIndex = 0;
                spotsToShow.forEach((spot) => {
                    if (spot.coordinates && spot.coordinates.lat && spot.coordinates.lng) {
                        markerIndex++;
                        console.log(`Adding marker ${markerIndex} for ${spot.name} at [${spot.coordinates.lat}, ${spot.coordinates.lng}]`);
                        const riskScore = getAdjustedRiskScore(spot);
                        const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                        const markerColor = riskScore >= 75 ? '#28a745' : riskScore >= 50 ? '#ffc107' : '#dc3545';

                        const marker = L.marker([spot.coordinates.lat, spot.coordinates.lng], {
                            icon: L.divIcon({
                                className: 'custom-marker-spot',
                                html: `<div style="background: ${markerColor}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">${markerIndex}</div>`,
                                iconSize: [36, 36],
                                iconAnchor: [18, 18]
                            })
                        }).addTo(state.map);

                        // Create popup content
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <img src="${spot.imageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;" />
                                <h4 style="margin: 0 0 5px 0; font-size: 14px;">${spot.name}</h4>
                                <p style="margin: 0 0 5px 0; font-size: 12px; color: #666;">${spot.description}</p>
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                    <span style="font-size: 12px; color: #666;">üìç ${spot.distance}</span>
                                    <span style="background: ${markerColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">Score: ${riskScore}</span>
                                </div>
                                <button onclick="window.selectSpotFromMap('${spot.id}')" style="width: 100%; margin-top: 8px; padding: 8px; background: #1e3c72; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">View Details</button>
                            </div>
                        `;

                        marker.bindPopup(popupContent, { maxWidth: 250 });

                        // Click handler
                        marker.on('click', function() {
                            marker.openPopup();
                        });

                        state.mapMarkers.push(marker);
                    }
                });

                // V6.1: Draw route polyline if in route mode
                if (state.plannerMode === 'route' && state.routeStartCoords && state.routeEndCoords) {
                    const routePoints = [
                        [state.routeStartCoords.lat, state.routeStartCoords.lng],
                        ...spotsToShow
                            .filter(s => s.coordinates && s.coordinates.lat && s.coordinates.lng)
                            .map(s => [s.coordinates.lat, s.coordinates.lng]),
                        [state.routeEndCoords.lat, state.routeEndCoords.lng]
                    ];

                    state.routePolyline = L.polyline(routePoints, {
                        color: '#1e3c72',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(state.map);

                    // Add start/end markers
                    const startMarker = L.marker([state.routeStartCoords.lat, state.routeStartCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #28a745; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ Start</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    startMarker.bindPopup(`<b>Start</b><br>${state.routeStart}`);

                    const endMarker = L.marker([state.routeEndCoords.lat, state.routeEndCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #dc3545; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ End</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    endMarker.bindPopup(`<b>End</b><br>${state.routeEnd}`);

                    console.log('Route polyline added with', routePoints.length, 'points');
                }

                // Fit bounds to show all markers if we have spots
                if (state.spots.length > 0 && state.mapMarkers.length > 0) {
                    const group = L.featureGroup(state.mapMarkers);
                    state.map.fitBounds(group.getBounds().pad(0.1));
                    console.log(`Map initialized successfully with ${state.mapMarkers.length} markers`);
                } else {
                    console.warn('No markers added to map. Spots:', state.spots.length, 'Markers:', state.mapMarkers.length);
                }
            }

            // Global function to handle spot selection from map (called from popup button)
            window.selectSpotFromMap = function(spotId) {
                state.selectedSpot = spotId;
                render();
            };

            // V6: Get user's current location
            function getUserLocation() {
                if ('geolocation' in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            state.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                accuracy: position.coords.accuracy
                            };
                            console.log('User location obtained:', state.userLocation);

                            // If map is already initialized, update it
                            if (state.map && state.currentTab === 'planner' && state.spots.length > 0) {
                                initMap();
                            }
                        },
                        (error) => {
                            console.warn('Geolocation error:', error.message);
                            // Don't show error to user, just gracefully fail
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 5000,
                            maximumAge: 300000 // Cache for 5 minutes
                        }
                    );
                } else {
                    console.warn('Geolocation not supported');
                }
            }

            // Render functions
            function render() {
                const content = document.getElementById('content');

                if (state.selectedSpot) {
                    content.innerHTML = renderSpotDetail();
                } else if (state.currentTab === 'planner') {
                    content.innerHTML = renderTripPlanner();
                    // V6: Initialize map after rendering if spots exist
                    if (state.spots.length > 0) {
                        setTimeout(() => initMap(), 100);
                    }
                } else if (state.currentTab === 'upcoming') {
                    content.innerHTML = renderUpcoming();
                } else if (state.currentTab === 'history') {
                    content.innerHTML = renderHistory();
                } else if (state.currentTab === 'settings') {
                    content.innerHTML = renderSettings();
                } else if (state.currentTab === 'analytics') {
                    content.innerHTML = renderAnalytics();
                    setTimeout(() => initCharts(), 100);
                } else if (state.currentTab === 'help') {
                    content.innerHTML = renderHelp();
                }

                attachEventListeners();
            }

            // Helper function to render skeleton loading cards
            function renderSkeletonCards(count = 6) {
                const skeletons = [];
                for (let i = 0; i < count; i++) {
                    skeletons.push(`
                        <div class="skeleton-card">
                            <div class="skeleton-image"></div>
                            <div class="skeleton-content">
                                <div class="skeleton-title"></div>
                                <div class="skeleton-text"></div>
                                <div class="skeleton-badge"></div>
                            </div>
                        </div>
                    `);
                }
                return skeletons.join('');
            }

            function renderTripPlanner() {
                // V9.0: Calculate preference-based scores and match percentages
                const spotsWithScores = state.spots.map(spot => {
                    // Calculate preference-based score
                    const preferenceScore = calculateSpotScore(spot, state.searchCenter, state.preferences);

                    // Apply learning adjustment if user has ratings
                    const learningAdjustment = state.ratings.length > 0 ?
                        (getAdjustedRiskScore(spot) - spot.riskScore) : 0;

                    // Calculate match percentage for display
                    const matchPercentage = calculatePreferenceMatch(spot.shotTypes, state.preferences);

                    return {
                        ...spot,
                        score: preferenceScore + learningAdjustment,
                        matchPercentage: matchPercentage,
                        learningActive: state.ratings.length > 0
                    };
                }).sort((a, b) => b.score - a.score);

                const displaySpots = state.showFavoritesOnly
                    ? spotsWithScores.filter(s => state.favorites.includes(s.id))
                    : spotsWithScores;

                return `
                    <div class="x10-badge">
                        <div class="x10-title">üöÅ Skydio X10 Optimized</div>
                        <div class="x10-features">
                            <span class="feature-tag">üåô Nightsense</span>
                            <span class="feature-tag">üõ° Elite Avoidance</span>
                            <span class="feature-tag">üì° BVLOS Ready</span>
                            <span class="feature-tag">üéØ Part 107 Certified</span>
                        </div>
                    </div>

                    <div class="card">
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="toggle-btn ${state.plannerMode === 'auto' ? 'active' : ''}" data-mode="auto"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'auto' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'auto' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'auto' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Auto Recommend
                            </button>
                            <button class="toggle-btn ${state.plannerMode === 'route' ? 'active' : ''}" data-mode="route"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'route' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'route' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'route' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Route Mode
                            </button>
                        </div>

                        ${state.plannerMode === 'auto' ? `
                            <div class="input-group">
                                <label>üìç Destination</label>
                                <input type="text" id="destinationInput" placeholder="Enter city, hotel, or landmark" value="${state.destination}">
                            </div>
                            <button class="btn" id="findSpotsBtn">Find Spots</button>
                        ` : `
                            <div class="input-group">
                                <label>üè® Start Location</label>
                                <input type="text" id="routeStartInput" placeholder="Hotel, airport, etc." value="${state.routeStart}">
                            </div>
                            <div class="input-group">
                                <label>üéØ End Location</label>
                                <input type="text" id="routeEndInput" placeholder="Destination address" value="${state.routeEnd}">
                            </div>
                            <button class="btn" id="findRouteSpotsBtn">Find Spots Along Route</button>
                        `}
                    </div>

                    <div class="preferences-section">
                        <div class="preferences-header">
                            <div class="preferences-title">üéØ Shot Preferences</div>
                            <button class="preferences-toggle" id="togglePreferences">
                                ${state.showPreferences ? 'Hide' : 'Customize'}
                            </button>
                        </div>
                        ${state.showPreferences ? `
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.cityscape < 50 ? 'active' : ''}">Landscape</span>
                                    <span class="slider-label ${state.preferences.cityscape >= 50 ? 'active' : ''}">Cityscape</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.cityscape}" class="slider" id="cityscapeSlider">
                                ${state.spots.length > 0 ? `
                                    <div style="font-size: 11px; color: #666; margin-top: 4px; text-align: center;">
                                        üìä ${countSpotsByType('landscape')} landscape ¬∑ ${countSpotsByType('cityscape')} cityscape
                                    </div>
                                ` : ''}
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.nature < 50 ? 'active' : ''}">Architecture</span>
                                    <span class="slider-label ${state.preferences.nature >= 50 ? 'active' : ''}">Nature</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.nature}" class="slider" id="natureSlider">
                                ${state.spots.length > 0 ? `
                                    <div style="font-size: 11px; color: #666; margin-top: 4px; text-align: center;">
                                        üìä ${countSpotsByType('architecture')} architecture ¬∑ ${countSpotsByType('nature')} nature
                                    </div>
                                ` : ''}
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.architecture < 50 ? 'active' : ''}">Serene</span>
                                    <span class="slider-label ${state.preferences.architecture >= 50 ? 'active' : ''}">Dynamic</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.architecture}" class="slider" id="architectureSlider">
                            </div>
                        ` : ''}
                    </div>

                    <!-- Interactive Map - Always show for V7.1 flight paths -->
                    <div class="card" style="padding: 0; overflow: hidden; margin-bottom: 20px;">
                        <div id="mapContainer" class="map-container" style="height: 400px; width: 100%;"></div>
                    </div>

                    ${state.loadingSpots ? `
                        <div style="margin-bottom: 15px;">
                            <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                                üîç Finding spots...
                            </h2>
                        </div>
                        ${renderSkeletonCards(6)}
                    ` : state.spots.length > 0 ? `

                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin: 0;">
                                üìç ${state.showFavoritesOnly ? 'Favorite' : 'Recommended'} Spots
                            </h2>
                            <button class="toggle-favorites-btn ${state.showFavoritesOnly ? 'active' : ''}" id="toggleFavoritesBtn">
                                ${state.showFavoritesOnly ? '‚òÖ Favorites' : '‚òÜ All Spots'}
                            </button>
                        </div>

                        ${displaySpots.length === 0 ? `
                            <div class="card" style="text-align: center; padding: 40px 20px;">
                                <p style="color: #666;">No favorite spots yet. Star some locations to save them!</p>
                            </div>
                        ` : displaySpots.map(spot => {
                            const riskScore = spot.adjustedScore || spot.riskScore;
                            const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                            const riskLabel = riskScore >= 75 ? 'Clear' : riskScore >= 50 ? 'Caution' : 'Review';
                            const riskIcon = riskScore >= 75 ? '‚úì' : '‚ö†';

                            // V9.0: Match percentage and color
                            const matchPercentage = spot.matchPercentage || 50;
                            const matchColor = getMatchColor(matchPercentage);
                            const matchLabel = getMatchLabel(matchPercentage);

                            // Photo source badge
                            const photoSourceBadge = spot.imageSource === 'streetview'
                                ? '<div class="photo-source-badge streetview">üì∏ Street View</div>'
                                : '<div class="photo-source-badge stock">üñºÔ∏è Illustrative</div>';

                            return `
                                <div class="spot-card" data-spot-id="${spot.id}">
                                    <img src="${spot.imageUrl}" alt="${spot.name}" class="spot-image">
                                    <div class="risk-badge ${riskClass}">
                                        ${riskIcon} ${riskScore} ${riskLabel}
                                    </div>
                                    ${photoSourceBadge}
                                    <button class="favorite-star ${state.favorites.includes(spot.id) ? 'active' : ''}"
                                            data-spot-id="${spot.id}" id="favBtn${spot.id}">
                                        ${state.favorites.includes(spot.id) ? '‚òÖ' : '‚òÜ'}
                                    </button>
                                    <div class="spot-info">
                                        <div class="spot-name">${spot.name}</div>
                                        <div class="spot-desc">${spot.description}</div>
                                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                                            <span class="spot-distance">üìç ${spot.distance} away</span>
                                            <span style="color: #ddd;">¬∑</span>
                                            <span style="background: ${matchColor};
                                                         color: white;
                                                         padding: 3px 10px;
                                                         border-radius: 12px;
                                                         font-size: 11px;
                                                         font-weight: 600;
                                                         white-space: nowrap;">
                                                ‚≠ê ${matchPercentage}% match
                                            </span>
                                        </div>
                                        ${renderWeatherCard(spot.weather)}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    ` : ''}
                `;
            }

            function renderSpotDetail() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return '';

                const riskScore = getAdjustedRiskScore(spot);
                const isFavorite = state.favorites.includes(spot.id);

                return `
                    <button class="back-button" id="backBtn">‚Üê Back</button>

                    <div class="card">
                        <div style="position: relative;">
                            <img src="${spot.imageUrl}" alt="${spot.name}" style="width: 100%; height: 200px; object-fit: cover; border-radius: 12px; margin-bottom: 20px;">
                            <button class="favorite-star ${isFavorite ? 'active' : ''}"
                                    style="top: 15px; right: 15px;" data-spot-id="${spot.id}" id="detailFavBtn">
                                ${isFavorite ? '‚òÖ' : '‚òÜ'}
                            </button>
                        </div>

                        <h2 style="font-size: 20px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            ${spot.name}
                        </h2>

                        <div style="background: #e8f4f8; border-left: 4px solid #00d4ff; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="font-size: 14px; font-weight: 700; color: #0099cc; margin-bottom: 8px;">üéØ Flight Instructions</h4>
                            <p style="font-size: 13px; color: #666;">${spot.flightInstructions}</p>
                        </div>

                        ${spot.x10Advantage ? `
                            <div style="background: #f0e8ff; border-left: 4px solid #6a11cb; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <h4 style="font-size: 14px; font-weight: 700; color: #6a11cb; margin-bottom: 8px;">‚ú® X10 Advantage</h4>
                                <p style="font-size: 13px; color: #666;">${spot.x10Advantage}</p>
                            </div>
                        ` : ''}

                        <button class="btn" id="savePlanBtn" style="margin-bottom: 15px;">
                            üìÖ Save Flight Plan
                        </button>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin-bottom: 12px;">‚ö†Ô∏è Risk Assessment - ${riskScore}/100</h3>
                        ${renderRiskCategories()}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">‚úàÔ∏è Airspace Details</h3>
                        <div class="risk-category">
                            <div style="margin-bottom: 10px;"><strong>Class:</strong> ${spot.airspaceDetails.class}</div>
                            <div style="margin-bottom: 10px;"><strong>Ceiling:</strong> ${spot.airspaceDetails.ceiling}</div>
                            <div style="margin-bottom: 10px;"><strong>LAANC Required:</strong> ${spot.airspaceDetails.laancRequired}</div>
                            <div><strong>Nearest Airport:</strong> ${spot.airspaceDetails.nearestAirport}</div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üìã Regulations</h3>
                        ${spot.regulations.map(reg => `
                            <div class="risk-category" style="border-left: 3px solid ${reg.compliant ? '#28a745' : '#dc3545'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${reg.authority}</div>
                                <div style="font-size: 13px; color: #666;">${reg.rule}</div>
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üå§ Weather Conditions</h3>
                        <div class="risk-category">
                            <div style="margin-bottom: 8px;"><strong>Conditions:</strong> ${spot.weatherConditions.conditions}</div>
                            <div style="margin-bottom: 8px;"><strong>Wind:</strong> ${spot.weatherConditions.wind}</div>
                            <div style="margin-bottom: 8px;"><strong>Visibility:</strong> ${spot.weatherConditions.visibility}</div>
                            <div><strong>Temperature:</strong> ${spot.weatherConditions.temp}</div>
                        </div>
                    </div>
                `;
            }

            function renderRiskCategories() {
                const categories = [
                    { name: 'Airspace Clearance', score: 95, desc: 'No restrictions, LAANC approved' },
                    { name: 'Weather Conditions', score: 90, desc: 'Favorable winds, clear visibility' },
                    { name: 'Regulatory Compliance', score: 100, desc: 'All permits and waivers in place' },
                    { name: 'Environmental Hazards', score: 85, desc: 'Minimal obstacles, safe terrain' }
                ];

                return categories.map(cat => {
                    const scoreClass = cat.score >= 75 ? 'score-high' : cat.score >= 50 ? 'score-medium' : 'score-low';
                    return `
                        <div class="risk-category">
                            <div class="risk-cat-header">
                                <span class="risk-cat-name">${cat.name}</span>
                                <span class="risk-cat-score ${scoreClass}">${cat.score}</span>
                            </div>
                            <div class="risk-cat-bar">
                                <div class="risk-cat-fill" style="width: ${cat.score}%"></div>
                            </div>
                            <p class="risk-cat-desc">${cat.desc}</p>
                        </div>
                    `;
                }).join('');
            }

            function renderUpcoming() {
                if (state.upcomingFlights.length === 0) {
                    return `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <p class="empty-state-text">No upcoming flights scheduled.<br>Save a flight plan from the Trip Planner!</p>
                        </div>
                    `;
                }

                const sortedFlights = [...state.upcomingFlights].sort((a, b) =>
                    new Date(a.dateTime) - new Date(b.dateTime)
                );

                return `
                    <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                        üìÖ Upcoming Flights (${sortedFlights.length})
                    </h2>
                    ${sortedFlights.map(flight => {
                        const dt = new Date(flight.dateTime);
                        const formattedDate = dt.toLocaleString('en-US', {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });

                        return `
                            <div class="flight-card">
                                <div class="flight-header">
                                    <div>
                                        <div class="flight-location">${flight.spotName}</div>
                                        <div class="flight-date">${formattedDate}</div>
                                    </div>
                                </div>
                                <div class="flight-details">
                                    ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                </div>
                                <div style="display: flex; gap: 10px; margin-top: 12px;">
                                    <button class="btn-small" data-action="viewspot" data-spot-id="${flight.spotId}">
                                        View Spot
                                    </button>
                                    <button class="btn-small secondary" data-action="markflown" data-flight-id="${flight.id}">
                                        Mark as Flown
                                    </button>
                                    <button class="btn-small danger" data-action="delete" data-flight-id="${flight.id}">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }

            function renderHistory() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü°' : 'üî¥';

                return `
                    <div class="card">
                        ${state.syncMessage ? `
                            <div class="sync-message ${state.syncMessage.type}">
                                ${state.syncMessage.type === 'info' ? '<span class="spinner"></span>' : ''}
                                ${state.syncMessage.text}
                            </div>
                        ` : ''}

                        <div class="connection-status">
                            <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                            <div class="status-text">
                                <strong>${status} ${state.syncSettings.connectionStatus === 'connected' ? 'Connected' : state.syncSettings.connectionStatus === 'checking' ? 'Checking...' : 'Not Connected'}</strong>
                                ${state.syncSettings.lastSync ? `<br>Synced: ${formatDate(state.syncSettings.lastSync)}` : ''}
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button class="btn" id="syncNowBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Syncing...' : '‚òÅÔ∏è Sync Flights'}
                            </button>
                            <button class="btn" id="clearAndResyncBtn" style="background: #e74c3c;" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                üóëÔ∏è Clear & Re-sync
                            </button>
                        </div>
                    </div>

                    ${state.flights.length > 0 ? `
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            Flight History (${state.flights.length})
                        </h2>
                        ${state.flights.slice().reverse().map(flight => {
                            // V7.1 Debug: Log flight sync status
                            console.log('Flight:', flight.id, 'synced:', flight.synced, 'type:', flight.type);
                            const rating = state.ratings.find(r => r.flightId === flight.id);

                            const flightName = generateFlightName(flight);

                            return `
                                <div class="flight-card" id="flight-card-${flight.id}">
                                    <div class="flight-header">
                                        <div>
                                            <div class="flight-location">
                                                ${flightName}
                                                ${rating ? '<span class="badge rated">‚òÖ Rated</span>' : '<span class="badge pending">‚è≥ Rate This</span>'}
                                            </div>
                                            <div class="flight-date">${formatDate(flight.created_at || flight.date)}</div>
                                        </div>
                                        <div class="flight-badge ${flight.type === 'manual' ? 'badge-manual' : 'badge-synced'}">
                                            ${flight.type === 'manual' ? '‚úèÔ∏è Manual' : '‚òÅÔ∏è Synced'}
                                        </div>
                                    </div>
                                    <div class="flight-details">
                                        ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                    </div>

                                    <!-- Telemetry Stats (for synced flights) -->
                                    ${flight.synced ? `
                                        <details style="margin-top: 12px;" class="telemetry-details" data-flight-id="${flight.id}">
                                            <summary style="cursor: pointer; padding: 8px 12px; background: #f0f4f8; border-radius: 6px; font-weight: 600; color: #1e3c72; user-select: none;">
                                                üìä Flight Telemetry ${flight.telemetry?.stats ? '' : '(Click to load)'}
                                            </summary>
                                            <div style="padding: 12px; background: #f8f9fa; border-radius: 6px; margin-top: 8px;">
                                                ${flight.telemetry?.stats ? renderAllTelemetryStats(flight.telemetry.stats) : `
                                                <div style="text-align: center; padding: 20px; color: #666;">
                                                    <div class="telemetry-loading-${flight.id}" style="display: none;">
                                                        <span class="spinner"></span> Loading telemetry data...
                                                    </div>
                                                    <div class="telemetry-placeholder-${flight.id}">
                                                        Click "View Flight Path" to load telemetry stats
                                                    </div>
                                                </div>
                                                `}
                                            </div>
                                        </details>

                                        <!-- Inline Flight Path Map -->
                                        <details style="margin-top: 12px;" class="map-details" data-flight-id="${flight.id}">
                                            <summary style="cursor: pointer; padding: 8px 12px; background: #f0f4f8; border-radius: 6px; font-weight: 600; color: #1e3c72; user-select: none;">
                                                üó∫Ô∏è Flight Path Map ${flight.telemetry?.track ? '' : '(Click to load)'}
                                            </summary>
                                            <div style="padding: 12px; background: #f8f9fa; border-radius: 6px; margin-top: 8px;">
                                                <div id="inline-map-${flight.id}" style="height: 400px; width: 100%; border-radius: 6px; overflow: hidden;">
                                                    <div style="text-align: center; padding: 180px 20px; color: #666;">
                                                        Click to load map...
                                                    </div>
                                                </div>
                                                ${flight.telemetry?.track ? `
                                                <div style="margin-top: 8px; text-align: center;">
                                                    <button class="btn-small" data-action="openFullMap" data-flight-id="${flight.id}">
                                                        üîç Open Full Screen Map
                                                    </button>
                                                </div>
                                                ` : ''}
                                            </div>
                                        </details>
                                    ` : ''}

                                    ${!rating ? `
                                        <div style="display: flex; gap: 10px; margin-top: 12px;">
                                            <button class="btn-small" data-action="rate" data-flight-id="${flight.id}">
                                                ‚≠ê Rate This Flight
                                            </button>
                                        </div>
                                    ` : `
                                        <div style="margin-top: 12px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                                            <div style="font-size: 13px; color: #666;">
                                                <strong>Your Rating:</strong> ${rating.descAccuracy}‚≠ê Description | ${rating.shotTypeMatch}‚≠ê Shots | ${rating.accessibility}‚≠ê Access
                                            </div>
                                        </div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    ` : `
                        <div class="empty-state">
                            <div class="empty-state-icon">‚òÅÔ∏è</div>
                            <p class="empty-state-text">No flights yet.<br>Sync your Skydio Cloud flights to see them here.</p>
                        </div>
                    `}
                `;
            }

            function renderSettings() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢ Connected' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü° Checking...' : 'üî¥ Not Connected';

                return `
                    <div class="card">
                        <div class="settings-section">
                            <div class="settings-section-title">Cloud Sync</div>
                            <div class="connection-status">
                                <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                                <div class="status-text">
                                    <strong>${status}</strong>
                                    ${state.syncSettings.lastSync ? `<br>Last synced: ${formatDate(state.syncSettings.lastSync)}` : '<br>Never synced'}
                                </div>
                            </div>
                            <button class="btn" id="syncSettingsBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Checking...' : '‚òÅÔ∏è Sync Now'}
                            </button>
                        </div>

                        <div class="settings-section">
                            <div class="advanced-toggle" id="advancedToggle">
                                <span>‚öôÔ∏è Advanced Settings</span>
                                <span>‚ñ∂</span>
                            </div>
                            <div class="advanced-content" id="advancedContent">
                                <div class="input-group">
                                    <label>Worker URL</label>
                                    <input type="text" id="workerUrlInput" placeholder="https://..." value="${state.syncSettings.workerUrl}">
                                </div>
                                <div class="sync-info">
                                    Change only if you're self-hosting the Cloudflare Worker. Most users should leave this unchanged.
                                </div>
                                <button class="btn-secondary" id="updateWorkerBtn">Update URL</button>
                                <button class="btn-secondary" id="testConnectionBtn">Test Connection</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="advanced-toggle" id="profileToggle">
                                <span>üë§ Pilot Profile (V10.0)</span>
                                <span>‚ñ∂</span>
                            </div>
                            <div class="advanced-content" id="profileContent">
                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 0 0 10px 0;">Certifications</h4>
                                    <div class="checkbox-group">
                                        <label>
                                            <input type="checkbox" id="part107Checkbox" ${state.userProfile.certifications.part107 ? 'checked' : ''}>
                                            Part 107 Certified
                                        </label>
                                    </div>
                                    ${state.userProfile.certifications.part107 ? `
                                        <div class="input-group" style="margin-top: 10px;">
                                            <label>Expiry Date</label>
                                            <input type="date" id="part107ExpiryInput" value="${state.userProfile.certifications.part107Expiry || ''}">
                                        </div>
                                    ` : ''}
                                    <div class="checkbox-group" style="margin-top: 10px;">
                                        <label>
                                            <input type="checkbox" id="trustCheckbox" ${state.userProfile.certifications.trust ? 'checked' : ''}>
                                            TRUST Certified
                                        </label>
                                    </div>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Active Waivers</h4>
                                    <div id="waiversList">
                                        ${state.userProfile.waivers.map((waiver, idx) => `
                                            <div class="waiver-item" data-idx="${idx}">
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <div>
                                                        <strong>${getWaiverLabel(waiver.type)}</strong>
                                                        ${waiver.type === 'over_people' ? ` (Cat ${waiver.category})` : ''}
                                                        <div style="font-size: 12px; color: #666;">Expires: ${formatDate(waiver.expiryDate)}</div>
                                                        ${waiver.notes ? `<div style="font-size: 12px; color: #888;">${waiver.notes}</div>` : ''}
                                                    </div>
                                                    <button class="btn-secondary btn-small" onclick="removeWaiver(${idx})">Remove</button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button class="btn-secondary" id="addWaiverBtn" style="margin-top: 10px;">+ Add Waiver</button>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Your Drones</h4>
                                    <div id="dronesList">
                                        ${state.userProfile.drones.map((drone, idx) => `
                                            <div class="drone-item" data-idx="${idx}">
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <div>
                                                        <strong>${drone.name}</strong>
                                                        <div style="font-size: 12px; color: #666;">
                                                            ${drone.weight_lbs} lbs
                                                            ${drone.hasParachute ? ' ‚Ä¢ ü™Ç Parachute' : ''}
                                                            ${drone.hasRemoteID ? ' ‚Ä¢ üì° Remote ID' : ''}
                                                        </div>
                                                    </div>
                                                    <button class="btn-secondary btn-small" onclick="removeDrone(${idx})">Remove</button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button class="btn-secondary" id="addDroneBtn" style="margin-top: 10px;">+ Add Drone</button>
                                </div>

                                <div class="profile-subsection">
                                    <h4 style="font-size: 14px; font-weight: 700; color: #1e3c72; margin: 15px 0 10px 0;">Search Preferences</h4>
                                    <div class="input-group">
                                        <label>Search Radius: ${state.userProfile.preferences.searchRadius_mi} mi (~${Math.round(state.userProfile.preferences.searchRadius_mi * 2.5)} min drive)</label>
                                        <input type="range" id="searchRadiusSlider" min="5" max="25" step="5" value="${state.userProfile.preferences.searchRadius_mi}">
                                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: #888;">
                                            <span>5 mi</span>
                                            <span>15 mi</span>
                                            <span>25 mi</span>
                                        </div>
                                    </div>
                                    <div class="input-group" style="margin-top: 15px;">
                                        <label>Experience Level</label>
                                        <select id="experienceSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                                            <option value="beginner" ${state.userProfile.preferences.experience === 'beginner' ? 'selected' : ''}>Beginner</option>
                                            <option value="intermediate" ${state.userProfile.preferences.experience === 'intermediate' ? 'selected' : ''}>Intermediate</option>
                                            <option value="advanced" ${state.userProfile.preferences.experience === 'advanced' ? 'selected' : ''}>Advanced</option>
                                        </select>
                                    </div>
                                    <div class="checkbox-group" style="margin-top: 10px;">
                                        <label>
                                            <input type="checkbox" id="avoidCrowdsCheckbox" ${state.userProfile.preferences.avoidCrowds ? 'checked' : ''}>
                                            Avoid crowded areas (if no over-people waiver)
                                        </label>
                                    </div>
                                </div>

                                <button class="btn" id="saveProfileBtn" style="margin-top: 15px;">üíæ Save Profile</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="settings-section-title">About</div>
                            <p style="font-size: 14px; color: #666; line-height: 1.6;">
                                DroneScout v10.0 - Intelligent Recommendations<br>
                                Skydio X10 Optimized<br>
                                Part 107 Ready<br>
                                With Google Street View, OpenWeather & OSM
                            </p>
                        </div>
                    </div>
                `;
            }

            function renderAnalytics() {
                const totalFlights = state.flights.length;
                const totalDuration = state.flights.reduce((sum, f) => sum + (f.duration || 0), 0);
                const avgRating = state.ratings.length > 0
                    ? (state.ratings.reduce((sum, r) => sum + ((r.descAccuracy + r.shotTypeMatch + r.accessibility) / 3), 0) / state.ratings.length).toFixed(1)
                    : 'N/A';
                const favSpots = state.favorites.length;

                return `
                    <div class="card">
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            üìä Flight Statistics
                        </h2>

                        <div class="stat-grid">
                            <div class="stat-box">
                                <div class="stat-value">${totalFlights}</div>
                                <div class="stat-label">Total Flights</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${Math.round(totalDuration / 60)}m</div>
                                <div class="stat-label">Flight Time</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${avgRating}‚≠ê</div>
                                <div class="stat-label">Avg Rating</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${favSpots}</div>
                                <div class="stat-label">Favorite Spots</div>
                            </div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Flight Activity
                        </h3>
                        <div class="chart-container">
                            <canvas id="flightChart"></canvas>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Rating Breakdown
                        </h3>
                        <div class="chart-container">
                            <canvas id="ratingChart"></canvas>
                        </div>

                        <button class="export-btn" id="exportDataBtn">üì• Export Data (CSV)</button>
                    </div>
                `;
            }

            function renderHelp() {
                return `
                    <div class="card">
                        <div class="help-section">
                            <h3>üöÅ Getting Started</h3>
                            <p>DroneScout helps you plan drone flights with the Skydio X10. Here's how to use each tab:</p>
                            <ul>
                                <li><strong>Trip Planner:</strong> Enter a destination to find scenic spots with risk assessments</li>
                                <li><strong>Upcoming:</strong> View and manage scheduled flights</li>
                                <li><strong>History:</strong> Sync completed flights from Skydio Cloud</li>
                                <li><strong>Settings:</strong> Configure cloud sync and preferences</li>
                                <li><strong>Analytics:</strong> View flight statistics and trends</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚≠ê Using the Learning System</h3>
                            <p>Rate your flights to improve recommendations:</p>
                            <ul>
                                <li>After each flight, rate description accuracy, shot quality, and accessibility</li>
                                <li>The app learns your preferences over time</li>
                                <li>Spots matching your style get higher scores</li>
                                <li>Use favorites to save best locations</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚òÅÔ∏è Cloud Sync Setup</h3>
                            <p>Connect to Skydio Cloud via Cloudflare Worker:</p>
                            <ul>
                                <li>Deploy the provided Cloudflare Worker with your Skydio API token</li>
                                <li>Enter Worker URL in Settings tab</li>
                                <li>Click "Sync Now" to import flights</li>
                                <li>Synced flights show telemetry and media</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚ö†Ô∏è Risk Scoring</h3>
                            <p>Each spot shows a risk score (1-100) based on:</p>
                            <ul>
                                <li><strong>Airspace:</strong> FAA restrictions and LAANC requirements</li>
                                <li><strong>Weather:</strong> Wind, visibility, and conditions</li>
                                <li><strong>Regulations:</strong> Local, state, and federal rules</li>
                                <li><strong>Hazards:</strong> Obstacles, terrain, and population density</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üéØ X10 Optimization</h3>
                            <p>Spots are optimized for Skydio X10 capabilities:</p>
                            <ul>
                                <li><strong>Nightsense:</strong> Enables twilight/blue hour flights</li>
                                <li><strong>Obstacle Avoidance:</strong> Safe navigation in complex environments</li>
                                <li><strong>BVLOS:</strong> Extended range operations (if certified)</li>
                                <li><strong>Autonomy:</strong> Advanced tracking and cinematics</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìã Regulatory Compliance</h3>
                            <p>Always follow FAA Part 107 rules:</p>
                            <ul>
                                <li>Valid Part 107 certification required</li>
                                <li>Maximum 400 ft AGL altitude</li>
                                <li>Visual line of sight (unless waiver)</li>
                                <li>LAANC authorization in controlled airspace</li>
                                <li>Check NOTAMs before every flight</li>
                                <li>Respect local ordinances and privacy</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìû Support</h3>
                            <p>For questions or issues:</p>
                            <ul>
                                <li>GitHub: github.com/yourusername/dronescout</li>
                                <li>Email: support@dronescout.app</li>
                                <li>Documentation: docs.dronescout.app</li>
                            </ul>
                        </div>
                    </div>
                `;
            }

            // Charts initialization
            function initCharts() {
                if (typeof Chart === 'undefined') return;

                // Flight activity chart
                const flightCanvas = document.getElementById('flightChart');
                if (flightCanvas) {
                    const ctx = flightCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
                            datasets: [{
                                label: 'Flights',
                                data: [2, 3, 4, 5],
                                borderColor: '#00d4ff',
                                backgroundColor: 'rgba(0, 212, 255, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }

                // Rating breakdown chart
                const ratingCanvas = document.getElementById('ratingChart');
                if (ratingCanvas) {
                    const ctx = ratingCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Description', 'Shot Quality', 'Accessibility'],
                            datasets: [{
                                label: 'Average Rating',
                                data: [4.2, 4.5, 3.8],
                                backgroundColor: ['#00d4ff', '#0099cc', '#1e3c72']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 5
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }
            }

            // Event handlers
            function attachEventListeners() {
                // Tab switching
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        state.currentTab = e.target.dataset.tab;
                        render();
                    });
                });

                // Find spots button with real location search
                const findSpotsBtn = document.getElementById('findSpotsBtn');
                if (findSpotsBtn) {
                    findSpotsBtn.addEventListener('click', async () => {
                        const input = document.getElementById('destinationInput');
                        if (input && input.value) {
                            state.destination = input.value;

                            // Show loading state
                            state.loadingSpots = true;
                            state.spots = []; // Clear previous spots
                            findSpotsBtn.disabled = true;
                            findSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';
                            render(); // Render skeleton cards

                            try {
                                // Step 1: Geocode the location
                                const location = await geocodeLocation(state.destination);

                                if (location) {
                                    // V6: Save destination coordinates for map centering
                                    state.destinationCoords = location;

                                    // V9.0: Save search center for preference ranking
                                    state.searchCenter = {
                                        lat: location.lat,
                                        lon: location.lng
                                    };

                                    // Step 2: Search for POIs near the location
                                    const pois = await searchPOIsNearLocation(location.lat, location.lng, 10, location.displayName);

                                    if (pois && pois.length > 0) {
                                        // Success: Use real POI data
                                        state.spots = pois;
                                        console.log(`Found ${pois.length} real locations near ${location.displayName}`);
                                    } else {
                                        // Fallback: No POIs found, use hardcoded spots
                                        console.log('No POIs found, using fallback spots');
                                        state.spots = scenicSpots;
                                    }
                                } else {
                                    // Fallback: Geocoding failed, use hardcoded spots
                                    console.log('Geocoding failed, using fallback spots');
                                    state.destinationCoords = null;
                                    state.searchCenter = null;
                                    state.spots = scenicSpots;
                                }
                            } catch (error) {
                                // Fallback: Error occurred, use hardcoded spots
                                console.error('Location search error:', error);
                                state.destinationCoords = null;
                                state.searchCenter = null;
                                state.spots = scenicSpots;
                            } finally {
                                // Restore button and loading state
                                state.loadingSpots = false;
                                findSpotsBtn.disabled = false;
                                findSpotsBtn.textContent = 'Find Spots';
                                render();
                            }
                        }
                    });
                }

                // Toggle favorites
                const toggleFavoritesBtn = document.getElementById('toggleFavoritesBtn');
                if (toggleFavoritesBtn) {
                    toggleFavoritesBtn.addEventListener('click', () => {
                        state.showFavoritesOnly = !state.showFavoritesOnly;
                        render();
                        // V6.1: Re-initialize map to show only filtered spots
                        if (state.spots.length > 0 && state.currentTab === 'planner') {
                            setTimeout(() => initMap(), 100);
                        }
                    });
                }

                // Toggle preferences
                const togglePreferencesBtn = document.getElementById('togglePreferences');
                if (togglePreferencesBtn) {
                    togglePreferencesBtn.addEventListener('click', () => {
                        state.showPreferences = !state.showPreferences;
                        render();
                    });
                }

                // Preference sliders
                ['cityscape', 'nature', 'architecture'].forEach(pref => {
                    const slider = document.getElementById(`${pref}Slider`);
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            state.preferences[pref] = parseInt(e.target.value);
                            saveToStorage('preferences', state.preferences);
                            render();
                        });
                    }
                });

                // Favorite star buttons
                document.querySelectorAll('.favorite-star').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const spotId = parseInt(e.currentTarget.dataset.spotId);
                        const index = state.favorites.indexOf(spotId);
                        if (index > -1) {
                            state.favorites.splice(index, 1);
                        } else {
                            state.favorites.push(spotId);
                        }
                        saveToStorage('favorites', state.favorites);
                        render();
                    });
                });

                // Spot cards
                document.querySelectorAll('.spot-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('favorite-star')) {
                            const spotId = parseInt(e.currentTarget.dataset.spotId);
                            state.selectedSpot = spotId;
                            render();
                        }
                    });
                });

                // Back button
                const backBtn = document.getElementById('backBtn');
                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        state.selectedSpot = null;
                        render();
                    });
                }

                // Save flight plan
                const savePlanBtn = document.getElementById('savePlanBtn');
                if (savePlanBtn) {
                    savePlanBtn.addEventListener('click', () => {
                        showSavePlanModal();
                    });
                }

                // Upcoming flight actions
                document.querySelectorAll('[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        const flightId = e.target.dataset.flightId;
                        const spotId = e.target.dataset.spotId;

                        if (action === 'viewspot') {
                            state.currentTab = 'planner';
                            state.selectedSpot = parseInt(spotId);
                            render();
                        } else if (action === 'markflown') {
                            markFlightAsFlown(flightId);
                        } else if (action === 'delete') {
                            deleteUpcomingFlight(flightId);
                        } else if (action === 'rate') {
                            showRatingModal(flightId);
                        } else if (action === 'viewPath') {
                            viewFlightPath(flightId);
                        } else if (action === 'openFullMap') {
                            // Open full screen map in Planner tab
                            viewFlightPath(flightId, true); // true = open in planner tab
                        }
                    });
                });

                // Inline map handlers - load map when <details> is opened
                const mapDetails = document.querySelectorAll('.map-details');
                mapDetails.forEach(details => {
                    // Remove existing listener if any to prevent duplicates
                    details.removeEventListener('toggle', details._toggleHandler);

                    // Create and store handler
                    details._toggleHandler = async function(e) {
                        if (this.open) {
                            const flightId = this.dataset.flightId;
                            const mapContainer = document.getElementById(`inline-map-${flightId}`);

                            console.log('Map details opened for flight:', flightId);

                            // Only load if not already loaded
                            if (mapContainer && !mapContainer.classList.contains('map-loaded')) {
                                console.log('Loading inline map...');
                                await loadInlineFlightMap(flightId);
                                mapContainer.classList.add('map-loaded');
                            } else {
                                console.log('Map already loaded');
                            }
                        }
                    };

                    details.addEventListener('toggle', details._toggleHandler);
                });

                // Sync button
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.addEventListener('click', syncFlights);
                }

                // Clear & Re-sync button
                const clearAndResyncBtn = document.getElementById('clearAndResyncBtn');
                if (clearAndResyncBtn) {
                    clearAndResyncBtn.addEventListener('click', async () => {
                        if (confirm('This will clear all flight data and ratings from local storage and re-sync from Skydio. Continue?')) {
                            // Clear flight data and ratings
                            state.flights = [];
                            state.ratings = [];
                            saveToStorage('flights', state.flights);
                            saveToStorage('ratings', state.ratings);

                            // Clear inline maps
                            if (state.inlineMaps) {
                                Object.values(state.inlineMaps).forEach(map => {
                                    if (map && map.remove) map.remove();
                                });
                                state.inlineMaps = {};
                            }

                            state.syncMessage = { type: 'info', text: 'Cleared local data. Re-syncing...' };
                            render();

                            // Re-sync from Skydio
                            await syncFlights();
                        }
                    });
                }

                // Settings buttons
                const syncSettingsBtn = document.getElementById('syncSettingsBtn');
                if (syncSettingsBtn) {
                    syncSettingsBtn.addEventListener('click', syncFlights);
                }

                const updateWorkerBtn = document.getElementById('updateWorkerBtn');
                if (updateWorkerBtn) {
                    updateWorkerBtn.addEventListener('click', () => {
                        const newUrl = document.getElementById('workerUrlInput').value;
                        if (newUrl) {
                            state.syncSettings.workerUrl = newUrl;
                            saveToStorage('syncSettings', state.syncSettings);
                            state.syncMessage = { type: 'success', text: 'Worker URL updated' };
                            setTimeout(() => {
                                state.syncMessage = null;
                                render();
                            }, 2000);
                        }
                    });
                }

                // Advanced Settings toggle
                const advancedToggle = document.getElementById('advancedToggle');
                const advancedContent = document.getElementById('advancedContent');
                if (advancedToggle && advancedContent) {
                    advancedToggle.addEventListener('click', () => {
                        advancedToggle.classList.toggle('open');
                        advancedContent.classList.toggle('open');
                        const arrow = advancedToggle.querySelector('span:last-child');
                        if (arrow) {
                            arrow.textContent = advancedContent.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                        }
                    });
                }

                // Test Connection button
                const testConnectionBtn = document.getElementById('testConnectionBtn');
                if (testConnectionBtn) {
                    testConnectionBtn.addEventListener('click', async () => {
                        await checkConnection();
                        render();
                    });
                }

                // Trip Planner mode toggle buttons
                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.dataset.mode;
                        if (mode && (mode === 'auto' || mode === 'route')) {
                            state.plannerMode = mode;
                            render();
                        }
                    });
                });

                // Route Mode search button
                const findRouteSpotsBtn = document.getElementById('findRouteSpotsBtn');
                if (findRouteSpotsBtn) {
                    findRouteSpotsBtn.addEventListener('click', async () => {
                        const startInput = document.getElementById('routeStartInput');
                        const endInput = document.getElementById('routeEndInput');
                        if (startInput && endInput && startInput.value && endInput.value) {
                            state.routeStart = startInput.value;
                            state.routeEnd = endInput.value;

                            // V6.1: Geocode start and end locations for route polyline
                            findRouteSpotsBtn.disabled = true;
                            findRouteSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';

                            try {
                                const startLocation = await geocodeLocation(state.routeStart);
                                const endLocation = await geocodeLocation(state.routeEnd);

                                if (startLocation && endLocation) {
                                    state.routeStartCoords = startLocation;
                                    state.routeEndCoords = endLocation;

                                    // Search for POIs along the route (use midpoint for now)
                                    const midLat = (startLocation.lat + endLocation.lat) / 2;
                                    const midLng = (startLocation.lng + endLocation.lng) / 2;
                                    const pois = await searchPOIsNearLocation(midLat, midLng, 20, `${state.routeStart} to ${state.routeEnd}`);

                                    state.spots = pois && pois.length > 0 ? pois : scenicSpots;
                                } else {
                                    state.routeStartCoords = null;
                                    state.routeEndCoords = null;
                                    state.spots = scenicSpots;
                                }
                            } catch (error) {
                                console.error('Route geocoding error:', error);
                                state.routeStartCoords = null;
                                state.routeEndCoords = null;
                                state.spots = scenicSpots;
                            } finally {
                                findRouteSpotsBtn.disabled = false;
                                findRouteSpotsBtn.textContent = 'Find Spots Along Route';
                                render();
                            }
                        }
                    });
                }

                // Export data
                const exportDataBtn = document.getElementById('exportDataBtn');
                if (exportDataBtn) {
                    exportDataBtn.addEventListener('click', exportData);
                }

                // V10.0: Profile toggle
                const profileToggle = document.getElementById('profileToggle');
                const profileContent = document.getElementById('profileContent');
                if (profileToggle && profileContent) {
                    profileToggle.addEventListener('click', () => {
                        profileToggle.classList.toggle('open');
                        profileContent.classList.toggle('open');
                        const arrow = profileToggle.querySelector('span:last-child');
                        if (arrow) {
                            arrow.textContent = profileContent.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                        }
                    });
                }

                // V10.0: Profile certifications
                const part107Checkbox = document.getElementById('part107Checkbox');
                if (part107Checkbox) {
                    part107Checkbox.addEventListener('change', (e) => {
                        state.userProfile.certifications.part107 = e.target.checked;
                        if (!e.target.checked) {
                            state.userProfile.certifications.part107Expiry = null;
                        }
                        render();
                    });
                }

                const trustCheckbox = document.getElementById('trustCheckbox');
                if (trustCheckbox) {
                    trustCheckbox.addEventListener('change', (e) => {
                        state.userProfile.certifications.trust = e.target.checked;
                    });
                }

                const part107ExpiryInput = document.getElementById('part107ExpiryInput');
                if (part107ExpiryInput) {
                    part107ExpiryInput.addEventListener('change', (e) => {
                        state.userProfile.certifications.part107Expiry = e.target.value;
                    });
                }

                // V10.0: Search radius slider
                const searchRadiusSlider = document.getElementById('searchRadiusSlider');
                if (searchRadiusSlider) {
                    searchRadiusSlider.addEventListener('input', (e) => {
                        state.userProfile.preferences.searchRadius_mi = parseInt(e.target.value);
                        render();
                    });
                }

                // V10.0: Experience level
                const experienceSelect = document.getElementById('experienceSelect');
                if (experienceSelect) {
                    experienceSelect.addEventListener('change', (e) => {
                        state.userProfile.preferences.experience = e.target.value;
                    });
                }

                // V10.0: Avoid crowds checkbox
                const avoidCrowdsCheckbox = document.getElementById('avoidCrowdsCheckbox');
                if (avoidCrowdsCheckbox) {
                    avoidCrowdsCheckbox.addEventListener('change', (e) => {
                        state.userProfile.preferences.avoidCrowds = e.target.checked;
                    });
                }

                // V10.0: Save profile button
                const saveProfileBtn = document.getElementById('saveProfileBtn');
                if (saveProfileBtn) {
                    saveProfileBtn.addEventListener('click', () => {
                        saveToStorage('userProfile', state.userProfile);
                        alert('Profile saved successfully!');
                    });
                }

                // V10.0: Add waiver button
                const addWaiverBtn = document.getElementById('addWaiverBtn');
                if (addWaiverBtn) {
                    addWaiverBtn.addEventListener('click', () => {
                        showAddWaiverModal();
                    });
                }

                // V10.0: Add drone button
                const addDroneBtn = document.getElementById('addDroneBtn');
                if (addDroneBtn) {
                    addDroneBtn.addEventListener('click', () => {
                        showAddDroneModal();
                    });
                }
            }

            // Helper functions
            function showSavePlanModal() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return;

                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <div class="input-group">
                        <label>Flight Date & Time</label>
                        <input type="datetime-local" id="planDateTime">
                    </div>
                    <div class="input-group">
                        <label>Notes (optional)</label>
                        <textarea id="planNotes" rows="3" placeholder="Flight plan notes..."></textarea>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="confirmSavePlan">Save Plan</button>
                        <button class="btn btn-secondary" id="cancelSavePlan">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                document.getElementById('confirmSavePlan').addEventListener('click', () => {
                    const dateTime = document.getElementById('planDateTime').value;
                    const notes = document.getElementById('planNotes').value;

                    if (dateTime) {
                        state.upcomingFlights.push({
                            id: Date.now(),
                            spotId: spot.id,
                            spotName: spot.name,
                            spotData: spot,
                            dateTime,
                            notes
                        });
                        saveToStorage('upcomingFlights', state.upcomingFlights);
                        modal.classList.remove('active');
                        alert('Flight plan saved!');
                    } else {
                        alert('Please select a date and time');
                    }
                });

                document.getElementById('cancelSavePlan').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            function markFlightAsFlown(flightId) {
                const flightIndex = state.upcomingFlights.findIndex(f => f.id == flightId);
                if (flightIndex === -1) return;

                const flight = state.upcomingFlights[flightIndex];

                state.flights.unshift({
                    id: Date.now(),
                    type: 'manual',
                    name: flight.spotName,
                    location: flight.spotName,
                    date: new Date(flight.dateTime).toISOString(),
                    duration: 0,
                    notes: flight.notes,
                    spotData: flight.spotData
                });

                state.upcomingFlights.splice(flightIndex, 1);

                saveToStorage('upcomingFlights', state.upcomingFlights);
                saveToStorage('flights', state.flights);

                showRatingModal(state.flights[0].id);
            }

            function deleteUpcomingFlight(flightId) {
                if (confirm('Delete this flight plan?')) {
                    state.upcomingFlights = state.upcomingFlights.filter(f => f.id != flightId);
                    saveToStorage('upcomingFlights', state.upcomingFlights);
                    render();
                }
            }

            function showRatingModal(flightId) {
                const flight = state.flights.find(f => f.id == flightId);
                if (!flight) return;

                const modal = document.getElementById('ratingModal');
                const content = document.getElementById('ratingContent');

                state.currentRating = {
                    flightId: flight.id,
                    descAccuracy: 0,
                    shotTypeMatch: 0,
                    accessibility: 0,
                    wouldFlyAgain: null,
                    notes: ''
                };

                // Use the full generated flight name with location
                const flightName = generateFlightName(flight);

                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <strong>Flight:</strong> ${flightName}
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Description Accuracy</label>
                        <div class="star-rating" id="descAccuracy">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Shot Type Match</label>
                        <div class="star-rating" id="shotTypeMatch">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Accessibility</label>
                        <div class="star-rating" id="accessibility">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Additional Notes (optional)</label>
                        <textarea id="ratingNotes" rows="3" placeholder="Any additional feedback..."></textarea>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="submitRating">Submit Rating</button>
                        <button class="btn btn-secondary" id="cancelRating">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                // Star rating handlers
                document.querySelectorAll('.star-rating').forEach(group => {
                    const stars = group.querySelectorAll('.star');
                    stars.forEach(star => {
                        star.addEventListener('click', (e) => {
                            const rating = parseInt(e.target.dataset.rating);
                            const category = group.id;
                            state.currentRating[category] = rating;

                            stars.forEach((s, i) => {
                                s.classList.toggle('active', i < rating);
                            });
                        });
                    });
                });

                // Submit rating
                document.getElementById('submitRating').addEventListener('click', () => {
                    const notes = document.getElementById('ratingNotes').value;

                    if (state.currentRating.descAccuracy > 0 &&
                        state.currentRating.shotTypeMatch > 0 &&
                        state.currentRating.accessibility > 0) {

                        state.currentRating.notes = notes;
                        state.ratings.push({...state.currentRating});
                        saveToStorage('ratings', state.ratings);

                        modal.classList.remove('active');
                        state.currentRating = null;
                        render();
                    } else {
                        alert('Please complete all ratings');
                    }
                });

                document.getElementById('cancelRating').addEventListener('click', () => {
                    modal.classList.remove('active');
                    state.currentRating = null;
                });
            }

            // V6.1: Export flights data as CSV format
            function exportData() {
                let csv = 'Date,Location,Duration,Type,Notes\n';
                state.flights.forEach(flight => {
                    csv += `${formatDate(flight.date)},"${flight.name || flight.location}",${flight.duration || 0},${flight.type || 'manual'},"${flight.notes || ''}"\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'dronescout-flights.csv';
                a.click();
            }

            // V10.0: Profile helper functions
            function getWaiverLabel(type) {
                const labels = {
                    'over_people': 'Over People',
                    'night_operations': 'Night Operations',
                    'beyond_vlos': 'Beyond Visual Line of Sight',
                    'controlled_airspace': 'Controlled Airspace'
                };
                return labels[type] || type;
            }

            // V10.0: Global functions for removing items (called from inline onclick)
            window.removeWaiver = function(idx) {
                if (confirm('Remove this waiver?')) {
                    state.userProfile.waivers.splice(idx, 1);
                    render();
                }
            };

            window.removeDrone = function(idx) {
                if (confirm('Remove this drone?')) {
                    state.userProfile.drones.splice(idx, 1);
                    render();
                }
            };

            function showAddWaiverModal() {
                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">Add Waiver</h3>
                    <div class="input-group">
                        <label>Waiver Type</label>
                        <select id="waiverTypeSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="over_people">Over People</option>
                            <option value="night_operations">Night Operations</option>
                            <option value="beyond_vlos">Beyond Visual Line of Sight</option>
                            <option value="controlled_airspace">Controlled Airspace</option>
                        </select>
                    </div>
                    <div class="input-group" id="categoryGroup" style="display: none;">
                        <label>Category (for Over People)</label>
                        <select id="categorySelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="1">Category 1</option>
                            <option value="2">Category 2</option>
                            <option value="3">Category 3</option>
                            <option value="4">Category 4</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Expiry Date</label>
                        <input type="date" id="waiverExpiryInput">
                    </div>
                    <div class="input-group">
                        <label>Notes (optional)</label>
                        <textarea id="waiverNotesInput" rows="2" placeholder="e.g., Parachute system equipped"></textarea>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn" id="confirmAddWaiver">Add Waiver</button>
                        <button class="btn btn-secondary" id="cancelAddWaiver">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                // Show/hide category field based on waiver type
                const waiverTypeSelect = document.getElementById('waiverTypeSelect');
                const categoryGroup = document.getElementById('categoryGroup');
                waiverTypeSelect.addEventListener('change', () => {
                    categoryGroup.style.display = waiverTypeSelect.value === 'over_people' ? 'block' : 'none';
                });

                document.getElementById('confirmAddWaiver').addEventListener('click', () => {
                    const type = document.getElementById('waiverTypeSelect').value;
                    const expiryDate = document.getElementById('waiverExpiryInput').value;
                    const notes = document.getElementById('waiverNotesInput').value;

                    if (expiryDate) {
                        const waiver = {
                            type,
                            expiryDate,
                            notes
                        };

                        if (type === 'over_people') {
                            waiver.category = parseInt(document.getElementById('categorySelect').value);
                        }

                        state.userProfile.waivers.push(waiver);
                        modal.classList.remove('active');
                        render();
                    } else {
                        alert('Please select an expiry date');
                    }
                });

                document.getElementById('cancelAddWaiver').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            function showAddDroneModal() {
                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">Add Drone</h3>
                    <div class="input-group">
                        <label>Drone Model</label>
                        <input type="text" id="droneNameInput" placeholder="e.g., DJI Mavic 3">
                    </div>
                    <div class="input-group">
                        <label>Weight (lbs)</label>
                        <input type="number" id="droneWeightInput" step="0.1" placeholder="e.g., 1.98">
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneParachuteCheckbox">
                            Has Parachute System
                        </label>
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneRemoteIDCheckbox">
                            Has Remote ID
                        </label>
                    </div>
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="droneNightLightsCheckbox">
                            Has Night Lights
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn" id="confirmAddDrone">Add Drone</button>
                        <button class="btn btn-secondary" id="cancelAddDrone">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                document.getElementById('confirmAddDrone').addEventListener('click', () => {
                    const name = document.getElementById('droneNameInput').value;
                    const weight = parseFloat(document.getElementById('droneWeightInput').value);

                    if (name && weight) {
                        const drone = {
                            id: `drone_${Date.now()}`,
                            name,
                            weight_lbs: weight,
                            hasParachute: document.getElementById('droneParachuteCheckbox').checked,
                            hasRemoteID: document.getElementById('droneRemoteIDCheckbox').checked,
                            hasNightLights: document.getElementById('droneNightLightsCheckbox').checked
                        };

                        state.userProfile.drones.push(drone);
                        modal.classList.remove('active');
                        render();
                    } else {
                        alert('Please fill in drone name and weight');
                    }
                });

                document.getElementById('cancelAddDrone').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            // Initial render
            checkConnection();
            getUserLocation(); // V6: Request user's location for map
            render();
        }
    </script>
</body>
</html>
