<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DroneScout v7.1 - Flight Path Visualization</title>
    <!-- Build: 2025-10-31-23:50 UTC - FORCE RELOAD -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- V6 Fix: Proper Leaflet loading on ALL devices (no conditional loading) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <!-- V6.1: Updated to latest Chart.js version -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a2a6c 0%, #0f1b4d 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            background: #f5f7fa;
            min-height: 100vh;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 2px solid #e0e6ed;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            min-width: fit-content;
        }

        .nav-tab.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
        }

        .content {
            padding: 20px;
            padding-bottom: 80px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .preferences-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .preferences-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .preferences-title {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }
        .preferences-toggle {
            background: none;
            border: none;
            color: #00d4ff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group:last-child {
            margin-bottom: 0;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .slider-label {
            font-size: 13px;
            font-weight: 600;
            color: #666;
        }
        .slider-label.active {
            color: #00d4ff;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e6ed;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 212, 255, 0.4);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: inherit;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .x10-badge {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .x10-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .x10-features {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .feature-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
        }

        .spot-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .spot-card:active {
            transform: scale(0.98);
        }

        .spot-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        .risk-badge {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            backdrop-filter: blur(10px);
        }

        .risk-badge.high {
            background: rgba(39, 174, 96, 0.9);
            color: white;
        }

        .risk-badge.medium {
            background: rgba(255, 193, 7, 0.9);
            color: white;
        }

        .risk-badge.low {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        .favorite-star {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s;
            backdrop-filter: blur(10px);
        }

        .favorite-star.active {
            color: #ffc107;
        }

        .spot-info {
            padding: 15px;
        }

        .spot-name {
            font-size: 18px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 8px;
        }

        .spot-desc {
            font-size: 14px;
            color: #666;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .spot-distance {
            font-size: 13px;
            color: #00d4ff;
            font-weight: 600;
        }

        .map-container {
            width: 100%;
            height: 400px;
            min-height: 400px;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            background: #e0e6ed;
        }

        .risk-category {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .risk-cat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .risk-cat-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .risk-cat-score {
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-medium {
            background: #fff3cd;
            color: #856404;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        .risk-cat-bar {
            width: 100%;
            height: 6px;
            background: #e0e6ed;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .risk-cat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            transition: width 0.3s;
        }

        .risk-cat-desc {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }

        .flight-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e0e6ed;
        }

        .flight-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 10px;
        }

        .flight-location {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
        }

        .flight-date {
            font-size: 13px;
            color: #666;
        }

        .flight-details {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
        }

        .flight-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .badge-synced {
            background: #e8f5e9;
            color: #1b5e20;
        }

        .badge-manual {
            background: #e7f3ff;
            color: #0056b3;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 6px;
        }

        .badge.rated {
            background: #d4edda;
            color: #155724;
        }

        .badge.pending {
            background: #fff3cd;
            color: #856404;
        }

        .btn-small {
            flex: 1;
            padding: 8px;
            background: #00d4ff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-small.secondary {
            background: #e0e6ed;
            color: #666;
        }

        .btn-small.danger {
            background: #dc3545;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 16px;
            color: #666;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .status-indicator.error {
            background: #dc3545;
        }

        .status-indicator.checking {
            background: #ffc107;
        }

        .status-text {
            flex: 1;
            font-size: 13px;
            color: #666;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section-title {
            font-size: 14px;
            font-weight: 700;
            color: #1e3c72;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e6ed;
        }

        .advanced-toggle {
            background: white;
            border: 2px solid #e0e6ed;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .advanced-toggle:hover {
            border-color: #00d4ff;
        }

        .advanced-toggle.open {
            background: #f0f5fa;
            border-color: #00d4ff;
        }

        .advanced-content {
            display: none;
            padding: 15px;
            background: #f9fafb;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #00d4ff;
        }

        .advanced-content.open {
            display: block;
        }

        .sync-info {
            font-size: 13px;
            color: #666;
            padding: 12px;
            background: #f0f5fa;
            border-radius: 8px;
            border-left: 4px solid #00d4ff;
            margin: 10px 0;
        }

        .chart-container {
            width: 100%;
            height: 250px;
            margin-bottom: 20px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .help-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 12px;
        }

        .help-section p {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            list-style: none;
            padding: 0;
        }

        .help-section li {
            font-size: 14px;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            position: relative;
        }

        .help-section li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #00d4ff;
            font-weight: 700;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 20px;
        }

        .star-rating {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .star {
            font-size: 32px;
            color: #e0e6ed;
            cursor: pointer;
            transition: all 0.2s;
        }

        .star.active {
            color: #ffc107;
        }

        .star:hover {
            transform: scale(1.1);
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #00d4ff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sync-message {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
            font-weight: 600;
        }

        .sync-message.success {
            background: #d4edda;
            color: #155724;
        }

        .sync-message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .back-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            margin-bottom: 10px;
        }

        .toggle-favorites-btn {
            background: white;
            border: 2px solid #e0e6ed;
            color: #666;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-favorites-btn.active {
            background: #ffc107;
            color: white;
            border-color: #ffc107;
        }

        .export-btn {
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üöÅ DroneScout v7.1</h1>
            <p>Plan ‚Ä¢ Map ‚Ä¢ Route ‚Ä¢ Assess ‚Ä¢ Fly ‚Ä¢ Sync ‚Ä¢ Analyze</p>
            <div style="background: #ffeb3b; color: #000; padding: 5px 10px; border-radius: 4px; font-size: 12px; margin-top: 10px; font-weight: bold;">
                ‚ö†Ô∏è BUILD: 2025-10-31 23:50 UTC - If you see this, cache cleared! If not, you're viewing old version.
            </div>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="planner">Trip Planner</button>
            <button class="nav-tab" data-tab="upcoming">Upcoming</button>
            <button class="nav-tab" data-tab="history">History</button>
            <button class="nav-tab" data-tab="settings">Settings</button>
            <button class="nav-tab" data-tab="analytics">Analytics</button>
            <button class="nav-tab" data-tab="help">Help</button>
        </div>

        <div class="content" id="content">
            <!-- Content will be dynamically rendered -->
        </div>
    </div>

    <!-- Rating Modal -->
    <div class="modal" id="ratingModal">
        <div class="modal-content">
            <div class="modal-header">Rate Your Flight</div>
            <div id="ratingContent"></div>
        </div>
    </div>

    <!-- Save Flight Plan Modal -->
    <div class="modal" id="savePlanModal">
        <div class="modal-content">
            <div class="modal-header">Save Flight Plan</div>
            <div id="savePlanContent"></div>
        </div>
    </div>

    <script>
        // Initialize app
        document.addEventListener('DOMContentLoaded', initializeApp);

        function initializeApp() {
            // App state
            const state = {
                currentTab: 'planner',
                selectedSpot: null,
                destination: '',
                plannerMode: 'auto',
                routeStart: '',
                routeEnd: '',
                spots: [],
                upcomingFlights: loadFromStorage('upcomingFlights') || [],
                flights: loadFromStorage('flights') || [],
                ratings: loadFromStorage('ratings') || [],
                preferences: loadFromStorage('preferences') || {
                    cityscape: 50,
                    nature: 50,
                    architecture: 50
                },
                favorites: loadFromStorage('favorites') || [],
                showFavoritesOnly: false,
                showPreferences: false,
                currentRating: null,
                syncSettings: loadFromStorage('syncSettings') || {
                    workerUrl: 'https://dronescout-proxy.dronescout-api.workers.dev',
                    lastSync: null,
                    connectionStatus: 'checking'
                },
                syncMessage: null,
                expandedFlight: null,
                // V6: Map state
                map: null,
                mapMarkers: [],
                destinationCoords: null,
                userLocation: null,
                // V6.1: Route mode state
                routeStartCoords: null,
                routeEndCoords: null,
                routePolyline: null
            };

            // LocalStorage helpers
            function loadFromStorage(key) {
                try {
                    const data = localStorage.getItem('dronescout_' + key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    return null;
                }
            }

            function saveToStorage(key, value) {
                try {
                    localStorage.setItem('dronescout_' + key, JSON.stringify(value));
                } catch (e) {
                    console.error('Storage error:', e);
                }
            }

            // Demo data with full v2 features
            const scenicSpots = [
                {
                    id: 1,
                    name: "Constitution Trail Overlook",
                    description: "Scenic trail with open fields and tree lines. Great for tracking shots and nature content.",
                    coordinates: { lat: 40.4842, lng: -88.9936 },
                    imageUrl: "https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80",
                    flightInstructions: "Launch from north parking area. Fly heading 180¬∞ (south) along tree line. Maintain 150 ft AGL to capture trail and surrounding farmland. Look east for sunrise golden hour shots.",
                    bestTime: "Golden hour (sunrise/sunset)",
                    x10Advantage: "X10's advanced autonomy excels at tree line tracking. Superior range enables full trail coverage. Nightsense allows twilight flights when trails are empty.",
                    distance: "2.3 mi",
                    riskScore: 88,
                    shotTypes: { landscape: 70, nature: 30, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 4.2 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "Visual line of sight waived (Part 107.31) - BVLOS certified", compliant: true },
                        { authority: "Local Parks", rule: "Drone flights permitted with Part 107 certification", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "8-12 mph SW",
                        visibility: "10+ miles",
                        temp: "72¬∞F",
                        conditions: "Clear"
                    }
                },
                {
                    id: 2,
                    name: "Downtown Skyline - Miller Park",
                    description: "Urban skyline shots with historic buildings and modern architecture blend.",
                    coordinates: { lat: 40.4781, lng: -88.9937 },
                    imageUrl: "https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80",
                    flightInstructions: "Launch from Miller Park. Fly heading 45¬∞ (northeast) toward downtown. Maintain 300 ft AGL for optimal building perspective.",
                    bestTime: "Blue hour (twilight) for city lights",
                    x10Advantage: "Nightsense capability captures stunning blue hour shots other drones miss. Elite obstacle avoidance navigates urban environment safely.",
                    distance: "3.7 mi",
                    riskScore: 72,
                    shotTypes: { cityscape: 80, architecture: 20, landscape: 0, nature: 0 },
                    airspaceDetails: {
                        class: "Class G with LAANC",
                        ceiling: "Up to 400 ft AGL with authorization",
                        laancRequired: "Yes (auto-approved up to 400 ft)",
                        nearestAirport: "Central Illinois Regional (BMI) - 3.8 mi SE"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "LAANC authorization obtained", compliant: true },
                        { authority: "City of Bloomington", rule: "Municipal approval for park launches", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "6-10 mph SSW",
                        visibility: "10+ miles",
                        temp: "68¬∞F",
                        conditions: "Partly cloudy"
                    }
                },
                {
                    id: 3,
                    name: "Evergreen Lake Nature Preserve",
                    description: "Natural lake with wildlife and dense tree cover. Excellent for aerial shots of water reflections.",
                    coordinates: { lat: 40.5142, lng: -88.9687 },
                    imageUrl: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80",
                    flightInstructions: "Launch from east parking area. Fly heading 270¬∞ (west) over lake. Maintain 200 ft AGL to capture full lake and fountain.",
                    bestTime: "Early morning for calm water reflections",
                    x10Advantage: "X10 Nightsense unlocks magical twilight/blue hour shots. Advanced obstacle avoidance navigates dense canopy safely.",
                    distance: "5.1 mi",
                    riskScore: 91,
                    shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 },
                    airspaceDetails: {
                        class: "Class G (Uncontrolled)",
                        ceiling: "Up to 400 ft AGL authorized",
                        laancRequired: "No",
                        nearestAirport: "Central Illinois Regional (BMI) - 6.1 mi S"
                    },
                    regulations: [
                        { authority: "FAA Part 107", rule: "BVLOS operations authorized", compliant: true },
                        { authority: "McLean County", rule: "Preserve permits drone use for photography", compliant: true }
                    ],
                    weatherConditions: {
                        wind: "5-8 mph W",
                        visibility: "10+ miles",
                        temp: "65¬∞F",
                        conditions: "Clear"
                    }
                }
            ];

            // Unsplash API configuration
            const UNSPLASH_API_KEY = 'PWgTvrIDkfEdi93dvP2knidPZa7z8IbdhnvbZRrBIw4';

            // Fetch real images from Unsplash API (location-specific)
            async function fetchUnsplashImage(category, locationName = '', spotName = '') {
                try {
                    // Extract city/location name from full location (e.g., "San Francisco" from "San Francisco, CA, USA")
                    let cityName = locationName;
                    if (locationName.includes(',')) {
                        cityName = locationName.split(',')[0].trim();
                    }

                    // Map categories to search terms
                    const categoryTerms = {
                        viewpoint: 'cityscape skyline',
                        water: 'waterfront bay harbor',
                        park: 'park nature',
                        nature: 'nature landscape',
                        architecture: 'architecture landmark',
                        landscape: 'landscape vista'
                    };

                    const categoryTerm = categoryTerms[category] || categoryTerms.landscape;

                    // Combine location + category for location-specific images
                    // e.g., "San Francisco cityscape" or "Yosemite mountain landscape"
                    const query = cityName ? `${cityName} ${categoryTerm}` : categoryTerm;

                    const url = `https://api.unsplash.com/photos/random?query=${encodeURIComponent(query)}&orientation=landscape`;

                    console.log(`Fetching image for: "${query}"`);

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Client-ID ${UNSPLASH_API_KEY}`
                        }
                    });

                    if (!response.ok) {
                        console.warn('Unsplash API error, using fallback image');
                        return getFallbackImage(category);
                    }

                    const data = await response.json();
                    return data.urls.regular || data.urls.small;
                } catch (error) {
                    console.error('Unsplash fetch error:', error);
                    return getFallbackImage(category);
                }
            }

            // Fallback images if Unsplash fails
            function getFallbackImage(category) {
                const fallbackImages = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return fallbackImages[category] || fallbackImages.landscape;
            }

            // Nominatim Geocoding API functions
            async function geocodeLocation(locationQuery) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(locationQuery)}&format=json&limit=1`,
                        {
                            headers: {
                                'User-Agent': 'DroneScout/5.3 (Flight Planning App)'
                            }
                        }
                    );

                    if (!response.ok) throw new Error('Geocoding failed');

                    const results = await response.json();
                    if (results.length === 0) return null;

                    return {
                        lat: parseFloat(results[0].lat),
                        lng: parseFloat(results[0].lon),
                        displayName: results[0].display_name
                    };
                } catch (error) {
                    console.error('Geocoding error:', error);
                    return null;
                }
            }

            // Overpass API POI search functions
            async function searchPOIsNearLocation(lat, lng, radiusKm = 10, locationName = '') {
                try {
                    // Overpass query for scenic locations: parks, viewpoints, peaks, lakes, nature reserves
                    const query = `
                        [out:json][timeout:25];
                        (
                          node["tourism"="viewpoint"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="peak"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="park"](around:${radiusKm * 1000},${lat},${lng});
                          way["natural"="water"](around:${radiusKm * 1000},${lat},${lng});
                          way["leisure"="nature_reserve"](around:${radiusKm * 1000},${lat},${lng});
                          node["natural"="beach"](around:${radiusKm * 1000},${lat},${lng});
                          way["landuse"="forest"](around:${radiusKm * 1000},${lat},${lng});
                          node["man_made"="tower"]["tower:type"="observation"](around:${radiusKm * 1000},${lat},${lng});
                        );
                        out center 30;
                    `;

                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: 'data=' + encodeURIComponent(query)
                    });

                    if (!response.ok) throw new Error('Overpass API failed');

                    const data = await response.json();
                    return await processPOIs(data.elements, lat, lng, locationName);
                } catch (error) {
                    console.error('POI search error:', error);
                    return [];
                }
            }

            // Process POIs into spot format (async to fetch real images)
            async function processPOIs(elements, centerLat, centerLng, locationName = '') {
                const spots = [];

                // Process each element and fetch images
                for (let index = 0; index < elements.length; index++) {
                    const element = elements[index];

                    // Get coordinates (handle nodes and ways differently)
                    let poiLat, poiLng;
                    if (element.lat && element.lon) {
                        poiLat = element.lat;
                        poiLng = element.lon;
                    } else if (element.center) {
                        poiLat = element.center.lat;
                        poiLng = element.center.lon;
                    } else {
                        continue; // Skip if no coordinates
                    }

                    // Calculate distance
                    const distance = calculateDistance(centerLat, centerLng, poiLat, poiLng);

                    // Determine spot type and generate appropriate data
                    const tags = element.tags || {};
                    const spotType = determineSpotType(tags);
                    const name = tags.name || `${spotType.name} ${index + 1}`;

                    // Fetch real image from Unsplash with location context
                    const imageUrl = await fetchUnsplashImage(spotType.category, locationName, name);

                    spots.push({
                        id: element.id || Date.now() + index,
                        name: name,
                        description: generateDescription(tags, spotType),
                        coordinates: { lat: poiLat, lng: poiLng },
                        imageUrl: imageUrl,
                        flightInstructions: generateFlightInstructions(spotType, tags),
                        bestTime: spotType.bestTime,
                        x10Advantage: "X10's advanced autonomy and Nightsense capability enable safe navigation and stunning shots in varied lighting conditions.",
                        distance: `${distance.toFixed(1)} mi`,
                        riskScore: calculateRiskScore(tags, spotType),
                        shotTypes: spotType.shotTypes,
                        airspaceDetails: {
                            class: "Class G (Uncontrolled)",
                            ceiling: "Up to 400 ft AGL authorized",
                            laancRequired: "Check local requirements",
                            nearestAirport: "Verify on SkyVector/B4UFLY"
                        },
                        regulations: [
                            { authority: "FAA Part 107", rule: "Visual line of sight required (unless BVLOS waiver)", compliant: true },
                            { authority: "Local Authority", rule: "Verify local drone regulations before flight", compliant: true }
                        ],
                        weatherConditions: {
                            wind: "Check current conditions",
                            visibility: "Check current conditions",
                            temp: "Check current conditions",
                            conditions: "Verify before flight"
                        }
                    });
                }

                // Sort by distance
                return spots.sort((a, b) => {
                    const distA = parseFloat(a.distance);
                    const distB = parseFloat(b.distance);
                    return distA - distB;
                });
            }

            // Helper function to calculate distance in miles
            function calculateDistance(lat1, lng1, lat2, lng2) {
                const R = 3959; // Earth's radius in miles
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                         Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                         Math.sin(dLng / 2) * Math.sin(dLng / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Determine spot type from OSM tags
            function determineSpotType(tags) {
                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    return {
                        category: 'viewpoint',
                        name: 'Viewpoint',
                        bestTime: 'Golden hour (sunrise/sunset)',
                        shotTypes: { landscape: 80, nature: 20, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.natural === 'water' || tags.natural === 'beach') {
                    return {
                        category: 'water',
                        name: 'Water Feature',
                        bestTime: 'Early morning for calm water',
                        shotTypes: { nature: 60, landscape: 40, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.leisure === 'park') {
                    return {
                        category: 'park',
                        name: 'Park',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 50, landscape: 30, cityscape: 20, architecture: 0 }
                    };
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return {
                        category: 'nature',
                        name: 'Nature Reserve',
                        bestTime: 'Golden hour',
                        shotTypes: { nature: 70, landscape: 30, cityscape: 0, architecture: 0 }
                    };
                } else if (tags.man_made === 'tower') {
                    return {
                        category: 'architecture',
                        name: 'Observation Tower',
                        bestTime: 'Blue hour for city lights',
                        shotTypes: { architecture: 50, cityscape: 30, landscape: 20, nature: 0 }
                    };
                } else {
                    return {
                        category: 'landscape',
                        name: 'Scenic Spot',
                        bestTime: 'Golden hour',
                        shotTypes: { landscape: 50, nature: 30, cityscape: 10, architecture: 10 }
                    };
                }
            }

            // Generate description based on tags
            function generateDescription(tags, spotType) {
                const name = tags.name || spotType.name;
                if (tags.tourism === 'viewpoint' || tags.natural === 'peak') {
                    return `Elevated viewpoint offering panoramic aerial perspectives. Ideal for wide-angle landscape shots and tracking footage.`;
                } else if (tags.natural === 'water') {
                    return `Water feature with reflective surfaces. Perfect for sunrise/sunset shots with mirror-like reflections.`;
                } else if (tags.leisure === 'park') {
                    return `Open park area with varied terrain. Good for cinematic tracking shots and nature content.`;
                } else if (tags.leisure === 'nature_reserve' || tags.landuse === 'forest') {
                    return `Natural area with diverse ecosystems. Excellent for wildlife and forest canopy footage.`;
                } else {
                    return `Scenic location suitable for aerial photography and drone cinematography.`;
                }
            }

            // Generate flight instructions
            function generateFlightInstructions(spotType, tags) {
                if (spotType.category === 'viewpoint') {
                    return 'Launch from designated area. Ascend to 200-300 ft AGL for panoramic shots. Capture 360¬∞ orbit and reveal shots.';
                } else if (spotType.category === 'water') {
                    return 'Launch from shoreline. Fly low (50-150 ft AGL) to capture reflections. Use slow tracking shots parallel to water.';
                } else if (spotType.category === 'park') {
                    return 'Launch from open area. Mix of altitudes: low for detail (100 ft), medium for context (200 ft), high for establishing (300 ft).';
                } else {
                    return 'Survey area from 200 ft AGL. Identify key features. Capture varied angles and perspectives. Maintain safe distances from obstacles.';
                }
            }

            // Get image URL based on spot type
            function getImageForSpotType(category) {
                const images = {
                    viewpoint: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80',
                    water: 'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=800&q=80',
                    park: 'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=800&q=80',
                    nature: 'https://images.unsplash.com/photo-1448375240586-882707db888b?w=800&q=80',
                    architecture: 'https://images.unsplash.com/photo-1480714378408-67cf0d13bc1b?w=800&q=80',
                    landscape: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&q=80'
                };
                return images[category] || images.landscape;
            }

            // Calculate risk score based on tags
            function calculateRiskScore(tags, spotType) {
                let score = 75; // Base score

                // Increase score for nature/open areas
                if (tags.natural || tags.leisure === 'park' || tags.leisure === 'nature_reserve') {
                    score += 10;
                }

                // Decrease score for urban/complex areas
                if (tags.man_made || tags.building) {
                    score -= 15;
                }

                // Adjust for accessibility
                if (tags.access === 'private') {
                    score -= 20;
                }

                return Math.max(50, Math.min(95, score));
            }

            // Calculate adjusted risk score based on learning
            function getAdjustedRiskScore(spot) {
                const baseScore = spot.riskScore;
                if (state.ratings.length === 0) return baseScore;

                const shotTypeRatings = {};
                const shotTypeCounts = {};

                state.ratings.forEach(rating => {
                    const flight = state.flights.find(f => f.id === rating.flightId);
                    if (flight && flight.spotData && flight.spotData.shotTypes) {
                        const shotTypes = flight.spotData.shotTypes;
                        const dominantType = Object.keys(shotTypes).reduce((a, b) =>
                            shotTypes[a] > shotTypes[b] ? a : b
                        );

                        if (!shotTypeRatings[dominantType]) {
                            shotTypeRatings[dominantType] = 0;
                            shotTypeCounts[dominantType] = 0;
                        }

                        const avgRating = (rating.descAccuracy + rating.shotTypeMatch + rating.accessibility) / 3;
                        shotTypeRatings[dominantType] += avgRating;
                        shotTypeCounts[dominantType]++;
                    }
                });

                Object.keys(shotTypeRatings).forEach(type => {
                    shotTypeRatings[type] = shotTypeRatings[type] / shotTypeCounts[type];
                });

                const dominantType = Object.keys(spot.shotTypes).reduce((a, b) =>
                    spot.shotTypes[a] > spot.shotTypes[b] ? a : b
                );

                if (shotTypeRatings[dominantType]) {
                    const avgRating = shotTypeRatings[dominantType];
                    const adjustedScore = baseScore * (avgRating / 3);
                    return Math.round(Math.max(1, Math.min(100, adjustedScore)));
                }

                return baseScore;
            }

            // Cloud sync functions
            async function checkConnection() {
                try {
                    state.syncSettings.connectionStatus = 'checking';
                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (response.ok) {
                        state.syncSettings.connectionStatus = 'connected';
                        console.log('Connection check successful:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status
                        });
                    } else {
                        state.syncSettings.connectionStatus = 'error';
                        const errorText = await response.text();
                        console.error('Connection check failed:', {
                            workerUrl: state.syncSettings.workerUrl,
                            status: response.status,
                            statusText: response.statusText,
                            body: errorText
                        });
                    }
                } catch (error) {
                    state.syncSettings.connectionStatus = 'error';
                    console.error('Connection check error:', {
                        message: error.message,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                }
            }

            async function syncFlights() {
                try {
                    state.syncMessage = { type: 'info', text: 'Syncing...' };
                    render();

                    const response = await fetch(state.syncSettings.workerUrl + '/sync-flights', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Sync failed');

                    const data = await response.json();

                    if (data.flights && Array.isArray(data.flights)) {
                        data.flights.forEach(flight => {
                            const existingIndex = state.flights.findIndex(f => f.id === flight.id && f.type === 'synced');
                            const processedFlight = {
                                id: flight.id,
                                type: 'synced',
                                synced: true, // V7.1: Flag for showing "View Flight Path" button
                                name: flight.name || `Flight ${new Date(flight.created_at).toLocaleDateString()}`,
                                date: flight.created_at,
                                duration: flight.duration_seconds,
                                location: flight.location || null,
                                notes: '',
                                mediaUrls: flight.media_urls || [],
                                syncedAt: new Date().toISOString()
                            };

                            if (existingIndex >= 0) {
                                processedFlight.notes = state.flights[existingIndex].notes || '';
                                state.flights[existingIndex] = processedFlight;
                            } else {
                                state.flights.unshift(processedFlight);
                            }
                        });
                    }

                    state.syncSettings.lastSync = new Date().toISOString();
                    state.syncSettings.connectionStatus = 'connected';
                    state.syncMessage = { type: 'success', text: `Synced ${data.flights ? data.flights.length : 0} flights` };
                    saveToStorage('flights', state.flights);
                    saveToStorage('syncSettings', state.syncSettings);
                    render();
                } catch (error) {
                    console.error('Sync error:', {
                        message: error.message,
                        stack: error.stack,
                        workerUrl: state.syncSettings.workerUrl,
                        timestamp: new Date().toISOString()
                    });
                    state.syncSettings.connectionStatus = 'error';
                    state.syncMessage = {
                        type: 'error',
                        text: `Sync failed: ${error.message}. Check console for details.`
                    };
                    render();
                }
            }

            // Fetch detailed flight data including telemetry track
            async function fetchFlightDetails(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/details`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight details');

                    const data = await response.json();

                    if (data.success) {
                        return {
                            flight: data.flight,
                            telemetry: data.telemetry
                        };
                    }

                    return null;
                } catch (error) {
                    console.error('Error fetching flight details:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight details: ${error.message}` };
                    render();
                    return null;
                }
            }

            // Fetch media (photos/videos) for a flight
            async function fetchFlightMedia(flightId) {
                try {
                    const response = await fetch(`${state.syncSettings.workerUrl}/flight/${flightId}/media`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) throw new Error('Failed to fetch flight media');

                    const data = await response.json();

                    if (data.success) {
                        return data.media;
                    }

                    return [];
                } catch (error) {
                    console.error('Error fetching flight media:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load media: ${error.message}` };
                    render();
                    return [];
                }
            }

            // Load complete flight data (details + media)
            async function loadSyncedFlightData(flightId) {
                state.syncMessage = { type: 'info', text: 'Loading flight data...' };
                render();

                const [details, media] = await Promise.all([
                    fetchFlightDetails(flightId),
                    fetchFlightMedia(flightId)
                ]);

                if (details) {
                    // Update the flight in state with detailed data
                    const flightIndex = state.flights.findIndex(f => f.id === flightId);
                    if (flightIndex >= 0) {
                        state.flights[flightIndex] = {
                            ...state.flights[flightIndex],
                            details: details.flight,
                            telemetry: details.telemetry,
                            mediaUrls: media.map(m => m.downloadUrl),
                            mediaDetails: media
                        };
                        saveToStorage('flights', state.flights);
                    }

                    state.syncMessage = { type: 'success', text: 'Flight data loaded' };
                    render();
                    return { details, media };
                }

                return null;
            }

            // View flight path on map
            async function viewFlightPath(flightId) {
                try {
                    // Show loading message
                    state.syncMessage = { type: 'info', text: 'Loading flight path...' };

                    // Fetch flight details with telemetry FIRST
                    const details = await fetchFlightDetails(flightId);

                    if (!details || !details.telemetry || !details.telemetry.track) {
                        state.syncMessage = { type: 'error', text: 'No telemetry data available for this flight' };
                        render();
                        return;
                    }

                    // Switch to planner tab and render
                    state.currentTab = 'planner';
                    render();

                    // CRITICAL: Wait for tab transition and DOM to be fully ready
                    // Use requestAnimationFrame to ensure DOM is painted before creating map
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await new Promise(resolve => requestAnimationFrame(resolve));

                    // Clean up old map if exists
                    if (state.map) {
                        state.map.remove();
                        state.map = null;
                    }

                    // Get map container
                    const mapContainer = document.getElementById('mapContainer');
                    if (!mapContainer) {
                        console.error('Map container not found!');
                        return;
                    }

                    console.log('Container dimensions:', mapContainer.offsetWidth, 'x', mapContainer.offsetHeight);

                    // Convert telemetry to LatLng array - AGGRESSIVE FILTERING
                    // First pass: get all non-zero points
                    const allPoints = details.telemetry.track
                        .filter(point => point.lat !== 0 && point.lon !== 0)
                        .map(point => [point.lat, point.lon]);

                    console.log('All non-zero points:', allPoints.length);

                    // Calculate median lat/lon to find the center of the actual flight
                    const lats = allPoints.map(p => p[0]).sort((a, b) => a - b);
                    const lons = allPoints.map(p => p[1]).sort((a, b) => a - b);
                    const medianLat = lats[Math.floor(lats.length / 2)];
                    const medianLon = lons[Math.floor(lons.length / 2)];

                    console.log('Median center:', medianLat, medianLon);

                    // Second pass: keep only points within ~50 miles (~0.7 degrees) of median
                    // This removes GPS errors that place points in different states/countries
                    const pathCoords = allPoints.filter(point => {
                        const latDiff = Math.abs(point[0] - medianLat);
                        const lonDiff = Math.abs(point[1] - medianLon);
                        return latDiff < 0.7 && lonDiff < 0.7;
                    });

                    console.log('Path coordinates (filtered):', pathCoords.length, 'First:', pathCoords[0], 'Last:', pathCoords[pathCoords.length-1]);

                    if (pathCoords.length === 0) {
                        console.error('No valid GPS coordinates in telemetry!');
                        return;
                    }

                    // CRITICAL: Reduce point density if too many points (performance optimization)
                    // Too many points (1000+) can cause rendering issues and prevent tiles from loading
                    let displayCoords = pathCoords;
                    if (pathCoords.length > 200) {
                        const skipFactor = Math.ceil(pathCoords.length / 200);
                        displayCoords = pathCoords.filter((_, index) => index % skipFactor === 0);
                        // Always include last point
                        if (!displayCoords.includes(pathCoords[pathCoords.length - 1])) {
                            displayCoords.push(pathCoords[pathCoords.length - 1]);
                        }
                        console.log(`Reduced ${pathCoords.length} points to ${displayCoords.length} for display (skip factor: ${skipFactor})`);
                    }

                    // Create map - start with a default view, will adjust with fitBounds
                    const centerPoint = displayCoords[Math.floor(displayCoords.length / 2)];
                    state.map = L.map('mapContainer').setView(centerPoint, 15);

                    // Add OpenStreetMap tiles - SIMPLE approach
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(state.map);

                    console.log('Map created, drawing flight path with', displayCoords.length, 'points');

                    // Draw flight path on map (using reduced point set)
                    const flightPath = L.polyline(displayCoords, {
                        color: '#2563eb',
                        weight: 3,
                        opacity: 0.8,
                        className: 'flight-path'
                    }).addTo(state.map);

                    // Automatically fit map to show entire flight path
                    // CRITICAL: Disable animation to prevent tile request cancellation
                    state.map.fitBounds(flightPath.getBounds(), {
                        padding: [50, 50],
                        animate: false  // No zoom animation = no tile cancellation
                    });

                    console.log('Flight path added, map fitted to bounds');

                    // Force tile loading after bounds are set
                    state.map.invalidateSize();

                    console.log('Map invalidated, tiles should load now');

                    // Add markers for takeoff and landing
                    const startPoint = pathCoords[0];
                    const endPoint = pathCoords[pathCoords.length - 1];

                    L.marker(startPoint, {
                        icon: L.divIcon({
                            html: 'üõ´',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Takeoff</b><br>${details.flight.vehicleSerial}`);

                    L.marker(endPoint, {
                        icon: L.divIcon({
                            html: 'üõ¨',
                            className: 'flight-marker',
                            iconSize: [30, 30]
                        })
                    }).addTo(state.map).bindPopup(`<b>Landing</b><br>${details.flight.vehicleSerial}`);

                    // Fit map to show entire flight path
                    state.map.fitBounds(flightPath.getBounds(), { padding: [50, 50] });

                    // Force another size recalculation after zoom
                    setTimeout(() => {
                        state.map.invalidateSize();
                    }, 100);

                    // SUCCESS! Don't call render() here - it would destroy the map we just created
                    // Just update the message element directly
                    state.syncMessage = { type: 'success', text: `Flight path loaded (${details.telemetry.pointCount} points)` };
                    console.log('‚úÖ Flight path rendering complete - map should be visible');
                } catch (error) {
                    console.error('Error viewing flight path:', error);
                    state.syncMessage = { type: 'error', text: `Failed to load flight path: ${error.message}` };
                    render();
                }
            }

            function formatDate(dateString) {
                const date = new Date(dateString);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            // TEST FUNCTION: Load map with known-good coordinates
            window.testMapWithGoodData = function() {
                console.log('üß™ Testing map with known-good Chicago coordinates...');

                // Clean up old map if exists
                if (state.map) {
                    state.map.remove();
                    state.map = null;
                }

                // Create map centered on Chicago
                state.map = L.map('mapContainer').setView([41.8781, -87.6298], 13);

                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap'
                }).addTo(state.map);

                // Create a test flight path around Chicago Loop
                const testPath = [
                    [41.8781, -87.6298],  // Start: Chicago
                    [41.8800, -87.6250],
                    [41.8850, -87.6200],
                    [41.8900, -87.6250],
                    [41.8900, -87.6350],
                    [41.8850, -87.6400],
                    [41.8800, -87.6350],
                    [41.8781, -87.6298]   // End: Back to start
                ];

                const flightPath = L.polyline(testPath, {
                    color: '#2563eb',
                    weight: 3,
                    opacity: 0.8
                }).addTo(state.map);

                state.map.fitBounds(flightPath.getBounds(), { padding: [50, 50] });

                console.log('‚úÖ TEST FLIGHT LOADED - Chicago Loop with known-good coordinates');
                console.log('Map center:', state.map.getCenter());
                console.log('Map zoom:', state.map.getZoom());
                alert('üß™ Test flight loaded!\n\nIf you see map tiles, the code works.\nIf still gray, there\'s a code issue.');
            };

            // V6: Map initialization and management
            function initMap() {
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    console.error('Leaflet not loaded');
                    return;
                }

                const mapContainer = document.getElementById('mapContainer');
                if (!mapContainer) {
                    console.error('Map container not found');
                    return;
                }

                console.log('Initializing map with', state.spots.length, 'spots');

                // Remove existing map if it exists
                if (state.map) {
                    state.map.remove();
                    state.map = null;
                }

                // Clear existing markers
                state.mapMarkers = [];

                // V6.1: Remove existing route polyline if present
                if (state.routePolyline) {
                    state.routePolyline.remove();
                    state.routePolyline = null;
                }

                // Use destination coords if available, otherwise center on first spot
                let centerLat, centerLng, zoom;

                if (state.destinationCoords) {
                    centerLat = state.destinationCoords.lat;
                    centerLng = state.destinationCoords.lng;
                    zoom = 12;
                } else if (state.spots.length > 0 && state.spots[0].coordinates) {
                    // Use first spot's coordinates as fallback
                    centerLat = state.spots[0].coordinates.lat || 40.7128;
                    centerLng = state.spots[0].coordinates.lng || -74.0060;
                    zoom = 12;
                } else {
                    // Default to NYC
                    centerLat = 40.7128;
                    centerLng = -74.0060;
                    zoom = 10;
                }

                // Initialize the map
                state.map = L.map('mapContainer').setView([centerLat, centerLng], zoom);

                // Add OpenStreetMap tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19
                }).addTo(state.map);

                // Add user location marker if available
                if (state.userLocation) {
                    const userMarker = L.marker([state.userLocation.lat, state.userLocation.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-user',
                            html: '<div style="background: #4285f4; color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.3), 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">üìç</div>',
                            iconSize: [26, 26],
                            iconAnchor: [13, 13]
                        })
                    }).addTo(state.map);

                    userMarker.bindPopup('<b>üìç Your Location</b>');
                    state.mapMarkers.push(userMarker);
                }

                // Add destination marker if coords available
                if (state.destinationCoords) {
                    const destinationMarker = L.marker([state.destinationCoords.lat, state.destinationCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-destination',
                            html: '<div style="background: #00d4ff; color: white; padding: 8px 12px; border-radius: 20px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üéØ Destination</div>',
                            iconSize: [130, 40],
                            iconAnchor: [65, 40]
                        })
                    }).addTo(state.map);

                    destinationMarker.bindPopup(`<b>${state.destination}</b><br>${state.destinationCoords.displayName || ''}`);
                }

                // V6.1: Filter spots based on favorites toggle
                const spotsToShow = state.showFavoritesOnly
                    ? state.spots.filter(s => state.favorites.includes(s.id))
                    : state.spots;

                // Add markers for each spot
                let markerIndex = 0;
                spotsToShow.forEach((spot) => {
                    if (spot.coordinates && spot.coordinates.lat && spot.coordinates.lng) {
                        markerIndex++;
                        console.log(`Adding marker ${markerIndex} for ${spot.name} at [${spot.coordinates.lat}, ${spot.coordinates.lng}]`);
                        const riskScore = getAdjustedRiskScore(spot);
                        const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                        const markerColor = riskScore >= 75 ? '#28a745' : riskScore >= 50 ? '#ffc107' : '#dc3545';

                        const marker = L.marker([spot.coordinates.lat, spot.coordinates.lng], {
                            icon: L.divIcon({
                                className: 'custom-marker-spot',
                                html: `<div style="background: ${markerColor}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 3px solid white;">${markerIndex}</div>`,
                                iconSize: [36, 36],
                                iconAnchor: [18, 18]
                            })
                        }).addTo(state.map);

                        // Create popup content
                        const popupContent = `
                            <div style="min-width: 200px;">
                                <img src="${spot.imageUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;" />
                                <h4 style="margin: 0 0 5px 0; font-size: 14px;">${spot.name}</h4>
                                <p style="margin: 0 0 5px 0; font-size: 12px; color: #666;">${spot.description}</p>
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                    <span style="font-size: 12px; color: #666;">üìç ${spot.distance}</span>
                                    <span style="background: ${markerColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">Score: ${riskScore}</span>
                                </div>
                                <button onclick="window.selectSpotFromMap('${spot.id}')" style="width: 100%; margin-top: 8px; padding: 8px; background: #1e3c72; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">View Details</button>
                            </div>
                        `;

                        marker.bindPopup(popupContent, { maxWidth: 250 });

                        // Click handler
                        marker.on('click', function() {
                            marker.openPopup();
                        });

                        state.mapMarkers.push(marker);
                    }
                });

                // V6.1: Draw route polyline if in route mode
                if (state.plannerMode === 'route' && state.routeStartCoords && state.routeEndCoords) {
                    const routePoints = [
                        [state.routeStartCoords.lat, state.routeStartCoords.lng],
                        ...spotsToShow
                            .filter(s => s.coordinates && s.coordinates.lat && s.coordinates.lng)
                            .map(s => [s.coordinates.lat, s.coordinates.lng]),
                        [state.routeEndCoords.lat, state.routeEndCoords.lng]
                    ];

                    state.routePolyline = L.polyline(routePoints, {
                        color: '#1e3c72',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(state.map);

                    // Add start/end markers
                    const startMarker = L.marker([state.routeStartCoords.lat, state.routeStartCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #28a745; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ Start</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    startMarker.bindPopup(`<b>Start</b><br>${state.routeStart}`);

                    const endMarker = L.marker([state.routeEndCoords.lat, state.routeEndCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker-route',
                            html: '<div style="background: #dc3545; color: white; padding: 6px 10px; border-radius: 15px; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 12px;">üèÅ End</div>',
                            iconSize: [70, 30],
                            iconAnchor: [35, 30]
                        })
                    }).addTo(state.map);
                    endMarker.bindPopup(`<b>End</b><br>${state.routeEnd}`);

                    console.log('Route polyline added with', routePoints.length, 'points');
                }

                // Fit bounds to show all markers if we have spots
                if (state.spots.length > 0 && state.mapMarkers.length > 0) {
                    const group = L.featureGroup(state.mapMarkers);
                    state.map.fitBounds(group.getBounds().pad(0.1));
                    console.log(`Map initialized successfully with ${state.mapMarkers.length} markers`);
                } else {
                    console.warn('No markers added to map. Spots:', state.spots.length, 'Markers:', state.mapMarkers.length);
                }
            }

            // Global function to handle spot selection from map (called from popup button)
            window.selectSpotFromMap = function(spotId) {
                state.selectedSpot = spotId;
                render();
            };

            // V6: Get user's current location
            function getUserLocation() {
                if ('geolocation' in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            state.userLocation = {
                                lat: position.coords.latitude,
                                lng: position.coords.longitude,
                                accuracy: position.coords.accuracy
                            };
                            console.log('User location obtained:', state.userLocation);

                            // If map is already initialized, update it
                            if (state.map && state.currentTab === 'planner' && state.spots.length > 0) {
                                initMap();
                            }
                        },
                        (error) => {
                            console.warn('Geolocation error:', error.message);
                            // Don't show error to user, just gracefully fail
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 5000,
                            maximumAge: 300000 // Cache for 5 minutes
                        }
                    );
                } else {
                    console.warn('Geolocation not supported');
                }
            }

            // Render functions
            function render() {
                const content = document.getElementById('content');

                if (state.selectedSpot) {
                    content.innerHTML = renderSpotDetail();
                } else if (state.currentTab === 'planner') {
                    content.innerHTML = renderTripPlanner();
                    // V6: Initialize map after rendering if spots exist
                    if (state.spots.length > 0) {
                        setTimeout(() => initMap(), 100);
                    }
                } else if (state.currentTab === 'upcoming') {
                    content.innerHTML = renderUpcoming();
                } else if (state.currentTab === 'history') {
                    content.innerHTML = renderHistory();
                } else if (state.currentTab === 'settings') {
                    content.innerHTML = renderSettings();
                } else if (state.currentTab === 'analytics') {
                    content.innerHTML = renderAnalytics();
                    setTimeout(() => initCharts(), 100);
                } else if (state.currentTab === 'help') {
                    content.innerHTML = renderHelp();
                }

                attachEventListeners();
            }

            function renderTripPlanner() {
                const spotsWithAdjustedScores = state.spots.map(spot => ({
                    ...spot,
                    adjustedScore: getAdjustedRiskScore(spot)
                })).sort((a, b) => b.adjustedScore - a.adjustedScore);

                const displaySpots = state.showFavoritesOnly
                    ? spotsWithAdjustedScores.filter(s => state.favorites.includes(s.id))
                    : spotsWithAdjustedScores;

                return `
                    <div class="x10-badge">
                        <div class="x10-title">üöÅ Skydio X10 Optimized</div>
                        <div class="x10-features">
                            <span class="feature-tag">üåô Nightsense</span>
                            <span class="feature-tag">üõ° Elite Avoidance</span>
                            <span class="feature-tag">üì° BVLOS Ready</span>
                            <span class="feature-tag">üéØ Part 107 Certified</span>
                        </div>
                    </div>

                    <div class="card">
                        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                            <button class="toggle-btn ${state.plannerMode === 'auto' ? 'active' : ''}" data-mode="auto"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'auto' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'auto' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'auto' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Auto Recommend
                            </button>
                            <button class="toggle-btn ${state.plannerMode === 'route' ? 'active' : ''}" data-mode="route"
                                style="flex: 1; padding: 10px; background: ${state.plannerMode === 'route' ? '#00d4ff' : 'white'};
                                color: ${state.plannerMode === 'route' ? 'white' : '#666'}; border: 2px solid ${state.plannerMode === 'route' ? '#00d4ff' : '#e0e6ed'};
                                border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                Route Mode
                            </button>
                        </div>

                        ${state.plannerMode === 'auto' ? `
                            <div class="input-group">
                                <label>üìç Destination</label>
                                <input type="text" id="destinationInput" placeholder="Enter city, hotel, or landmark" value="${state.destination}">
                            </div>
                            <button class="btn" id="findSpotsBtn">Find Spots</button>
                        ` : `
                            <div class="input-group">
                                <label>üè® Start Location</label>
                                <input type="text" id="routeStartInput" placeholder="Hotel, airport, etc." value="${state.routeStart}">
                            </div>
                            <div class="input-group">
                                <label>üéØ End Location</label>
                                <input type="text" id="routeEndInput" placeholder="Destination address" value="${state.routeEnd}">
                            </div>
                            <button class="btn" id="findRouteSpotsBtn">Find Spots Along Route</button>
                        `}
                    </div>

                    <div class="preferences-section">
                        <div class="preferences-header">
                            <div class="preferences-title">üéØ Shot Preferences</div>
                            <button class="preferences-toggle" id="togglePreferences">
                                ${state.showPreferences ? 'Hide' : 'Customize'}
                            </button>
                        </div>
                        ${state.showPreferences ? `
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.cityscape < 50 ? 'active' : ''}">Landscape</span>
                                    <span class="slider-label ${state.preferences.cityscape >= 50 ? 'active' : ''}">Cityscape</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.cityscape}" class="slider" id="cityscapeSlider">
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.nature < 50 ? 'active' : ''}">Architecture</span>
                                    <span class="slider-label ${state.preferences.nature >= 50 ? 'active' : ''}">Nature</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.nature}" class="slider" id="natureSlider">
                            </div>
                            <div class="slider-group">
                                <div class="slider-labels">
                                    <span class="slider-label ${state.preferences.architecture < 50 ? 'active' : ''}">Serene</span>
                                    <span class="slider-label ${state.preferences.architecture >= 50 ? 'active' : ''}">Dynamic</span>
                                </div>
                                <input type="range" min="0" max="100" value="${state.preferences.architecture}" class="slider" id="architectureSlider">
                            </div>
                        ` : ''}
                    </div>

                    <!-- Interactive Map - Always show for V7.1 flight paths -->
                    <div class="card" style="padding: 0; overflow: hidden; margin-bottom: 20px;">
                        <div id="mapContainer" class="map-container" style="height: 400px; width: 100%;"></div>
                    </div>

                    <!-- Debug buttons for map diagnostics and testing -->
                    <div style="margin-bottom: 20px; text-align: center; display: flex; gap: 10px; justify-content: center;">
                        <button onclick="testMapWithGoodData()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                            üß™ Test with Good Data
                        </button>

                        <button onclick="
                            if (window.mapDiagnostics) {
                                const text = JSON.stringify(window.mapDiagnostics, null, 2);
                                navigator.clipboard.writeText(text);
                                alert('üìã Diagnostics copied to clipboard!\\n\\nPaste into chat to share with support.');
                                console.log('=== COPIED DIAGNOSTICS ===');
                                console.log(text);
                            } else {
                                alert('No diagnostics available yet. Click \"View Flight Path\" first.');
                            }
                        " style="padding: 8px 16px; background: #6366f1; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500;">
                            üìã Copy Map Diagnostics
                        </button>
                    </div>

                    ${state.spots.length > 0 ? `

                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin: 0;">
                                üìç ${state.showFavoritesOnly ? 'Favorite' : 'Recommended'} Spots
                            </h2>
                            <button class="toggle-favorites-btn ${state.showFavoritesOnly ? 'active' : ''}" id="toggleFavoritesBtn">
                                ${state.showFavoritesOnly ? '‚òÖ Favorites' : '‚òÜ All Spots'}
                            </button>
                        </div>

                        ${displaySpots.length === 0 ? `
                            <div class="card" style="text-align: center; padding: 40px 20px;">
                                <p style="color: #666;">No favorite spots yet. Star some locations to save them!</p>
                            </div>
                        ` : displaySpots.map(spot => {
                            const riskScore = spot.adjustedScore;
                            const riskClass = riskScore >= 75 ? 'high' : riskScore >= 50 ? 'medium' : 'low';
                            const riskLabel = riskScore >= 75 ? 'Clear' : riskScore >= 50 ? 'Caution' : 'Review';
                            const riskIcon = riskScore >= 75 ? '‚úì' : '‚ö†';

                            return `
                                <div class="spot-card" data-spot-id="${spot.id}">
                                    <img src="${spot.imageUrl}" alt="${spot.name}" class="spot-image">
                                    <div class="risk-badge ${riskClass}">
                                        ${riskIcon} ${riskScore} ${riskLabel}
                                    </div>
                                    <button class="favorite-star ${state.favorites.includes(spot.id) ? 'active' : ''}"
                                            data-spot-id="${spot.id}" id="favBtn${spot.id}">
                                        ${state.favorites.includes(spot.id) ? '‚òÖ' : '‚òÜ'}
                                    </button>
                                    <div class="spot-info">
                                        <div class="spot-name">${spot.name}</div>
                                        <div class="spot-desc">${spot.description}</div>
                                        <div class="spot-distance">üìç ${spot.distance} away</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    ` : ''}
                `;
            }

            function renderSpotDetail() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return '';

                const riskScore = getAdjustedRiskScore(spot);
                const isFavorite = state.favorites.includes(spot.id);

                return `
                    <button class="back-button" id="backBtn">‚Üê Back</button>

                    <div class="card">
                        <div style="position: relative;">
                            <img src="${spot.imageUrl}" alt="${spot.name}" style="width: 100%; height: 200px; object-fit: cover; border-radius: 12px; margin-bottom: 20px;">
                            <button class="favorite-star ${isFavorite ? 'active' : ''}"
                                    style="top: 15px; right: 15px;" data-spot-id="${spot.id}" id="detailFavBtn">
                                ${isFavorite ? '‚òÖ' : '‚òÜ'}
                            </button>
                        </div>

                        <h2 style="font-size: 20px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            ${spot.name}
                        </h2>

                        <div style="background: #e8f4f8; border-left: 4px solid #00d4ff; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="font-size: 14px; font-weight: 700; color: #0099cc; margin-bottom: 8px;">üéØ Flight Instructions</h4>
                            <p style="font-size: 13px; color: #666;">${spot.flightInstructions}</p>
                        </div>

                        ${spot.x10Advantage ? `
                            <div style="background: #f0e8ff; border-left: 4px solid #6a11cb; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <h4 style="font-size: 14px; font-weight: 700; color: #6a11cb; margin-bottom: 8px;">‚ú® X10 Advantage</h4>
                                <p style="font-size: 13px; color: #666;">${spot.x10Advantage}</p>
                            </div>
                        ` : ''}

                        <button class="btn" id="savePlanBtn" style="margin-bottom: 15px;">
                            üìÖ Save Flight Plan
                        </button>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin-bottom: 12px;">‚ö†Ô∏è Risk Assessment - ${riskScore}/100</h3>
                        ${renderRiskCategories()}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">‚úàÔ∏è Airspace Details</h3>
                        <div class="risk-category">
                            <div style="margin-bottom: 10px;"><strong>Class:</strong> ${spot.airspaceDetails.class}</div>
                            <div style="margin-bottom: 10px;"><strong>Ceiling:</strong> ${spot.airspaceDetails.ceiling}</div>
                            <div style="margin-bottom: 10px;"><strong>LAANC Required:</strong> ${spot.airspaceDetails.laancRequired}</div>
                            <div><strong>Nearest Airport:</strong> ${spot.airspaceDetails.nearestAirport}</div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üìã Regulations</h3>
                        ${spot.regulations.map(reg => `
                            <div class="risk-category" style="border-left: 3px solid ${reg.compliant ? '#28a745' : '#dc3545'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${reg.authority}</div>
                                <div style="font-size: 13px; color: #666;">${reg.rule}</div>
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">üå§ Weather Conditions</h3>
                        <div class="risk-category">
                            <div style="margin-bottom: 8px;"><strong>Conditions:</strong> ${spot.weatherConditions.conditions}</div>
                            <div style="margin-bottom: 8px;"><strong>Wind:</strong> ${spot.weatherConditions.wind}</div>
                            <div style="margin-bottom: 8px;"><strong>Visibility:</strong> ${spot.weatherConditions.visibility}</div>
                            <div><strong>Temperature:</strong> ${spot.weatherConditions.temp}</div>
                        </div>
                    </div>
                `;
            }

            function renderRiskCategories() {
                const categories = [
                    { name: 'Airspace Clearance', score: 95, desc: 'No restrictions, LAANC approved' },
                    { name: 'Weather Conditions', score: 90, desc: 'Favorable winds, clear visibility' },
                    { name: 'Regulatory Compliance', score: 100, desc: 'All permits and waivers in place' },
                    { name: 'Environmental Hazards', score: 85, desc: 'Minimal obstacles, safe terrain' }
                ];

                return categories.map(cat => {
                    const scoreClass = cat.score >= 75 ? 'score-high' : cat.score >= 50 ? 'score-medium' : 'score-low';
                    return `
                        <div class="risk-category">
                            <div class="risk-cat-header">
                                <span class="risk-cat-name">${cat.name}</span>
                                <span class="risk-cat-score ${scoreClass}">${cat.score}</span>
                            </div>
                            <div class="risk-cat-bar">
                                <div class="risk-cat-fill" style="width: ${cat.score}%"></div>
                            </div>
                            <p class="risk-cat-desc">${cat.desc}</p>
                        </div>
                    `;
                }).join('');
            }

            function renderUpcoming() {
                if (state.upcomingFlights.length === 0) {
                    return `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <p class="empty-state-text">No upcoming flights scheduled.<br>Save a flight plan from the Trip Planner!</p>
                        </div>
                    `;
                }

                const sortedFlights = [...state.upcomingFlights].sort((a, b) =>
                    new Date(a.dateTime) - new Date(b.dateTime)
                );

                return `
                    <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                        üìÖ Upcoming Flights (${sortedFlights.length})
                    </h2>
                    ${sortedFlights.map(flight => {
                        const dt = new Date(flight.dateTime);
                        const formattedDate = dt.toLocaleString('en-US', {
                            weekday: 'short',
                            month: 'short',
                            day: 'numeric',
                            hour: 'numeric',
                            minute: '2-digit'
                        });

                        return `
                            <div class="flight-card">
                                <div class="flight-header">
                                    <div>
                                        <div class="flight-location">${flight.spotName}</div>
                                        <div class="flight-date">${formattedDate}</div>
                                    </div>
                                </div>
                                <div class="flight-details">
                                    ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                </div>
                                <div style="display: flex; gap: 10px; margin-top: 12px;">
                                    <button class="btn-small" data-action="viewspot" data-spot-id="${flight.spotId}">
                                        View Spot
                                    </button>
                                    <button class="btn-small secondary" data-action="markflown" data-flight-id="${flight.id}">
                                        Mark as Flown
                                    </button>
                                    <button class="btn-small danger" data-action="delete" data-flight-id="${flight.id}">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }

            function renderHistory() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü°' : 'üî¥';

                return `
                    <div class="card">
                        ${state.syncMessage ? `
                            <div class="sync-message ${state.syncMessage.type}">
                                ${state.syncMessage.type === 'info' ? '<span class="spinner"></span>' : ''}
                                ${state.syncMessage.text}
                            </div>
                        ` : ''}

                        <div class="connection-status">
                            <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                            <div class="status-text">
                                <strong>${status} ${state.syncSettings.connectionStatus === 'connected' ? 'Connected' : state.syncSettings.connectionStatus === 'checking' ? 'Checking...' : 'Not Connected'}</strong>
                                ${state.syncSettings.lastSync ? `<br>Synced: ${formatDate(state.syncSettings.lastSync)}` : ''}
                            </div>
                        </div>

                        <button class="btn" id="syncNowBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                            ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Syncing...' : '‚òÅÔ∏è Sync Flights'}
                        </button>
                    </div>

                    ${state.flights.length > 0 ? `
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            Flight History (${state.flights.length})
                        </h2>
                        ${state.flights.slice().reverse().map(flight => {
                            // V7.1 Debug: Log flight sync status
                            console.log('Flight:', flight.id, 'synced:', flight.synced, 'type:', flight.type);
                            const rating = state.ratings.find(r => r.flightId === flight.id);

                            return `
                                <div class="flight-card">
                                    <div class="flight-header">
                                        <div>
                                            <div class="flight-location">
                                                ${flight.name || flight.location}
                                                ${rating ? '<span class="badge rated">‚òÖ Rated</span>' : '<span class="badge pending">‚è≥ Rate This</span>'}
                                            </div>
                                            <div class="flight-date">${formatDate(flight.date)}</div>
                                        </div>
                                        <div class="flight-badge ${flight.type === 'manual' ? 'badge-manual' : 'badge-synced'}">
                                            ${flight.type === 'manual' ? '‚úèÔ∏è Manual' : '‚òÅÔ∏è Synced'}
                                        </div>
                                    </div>
                                    <div class="flight-details">
                                        ${flight.duration ? `<p><strong>Duration:</strong> ${Math.round(flight.duration / 60)}m</p>` : ''}
                                        ${flight.notes ? `<p><strong>Notes:</strong> ${flight.notes}</p>` : ''}
                                    </div>

                                    <!-- Telemetry Stats (for synced flights) -->
                                    ${flight.synced ? `
                                        <details style="margin-top: 12px;" class="telemetry-details" data-flight-id="${flight.id}">
                                            <summary style="cursor: pointer; padding: 8px 12px; background: #f0f4f8; border-radius: 6px; font-weight: 600; color: #1e3c72; user-select: none;">
                                                üìä Flight Telemetry ${flight.telemetry?.stats ? '' : '(Click to load)'}
                                            </summary>
                                            <div style="padding: 12px; background: #f8f9fa; border-radius: 6px; margin-top: 8px;">
                                                ${flight.telemetry?.stats ? `
                                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 13px;">
                                                    ${flight.telemetry.stats.maxSpeed != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Speed</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${(flight.telemetry.stats.maxSpeed * 2.23694).toFixed(1)} mph</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.maxSpeed.toFixed(1)} m/s</div>
                                                        </div>
                                                    ` : ''}
                                                    ${flight.telemetry.stats.avgSpeed != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Avg Speed</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${(flight.telemetry.stats.avgSpeed * 2.23694).toFixed(1)} mph</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.avgSpeed.toFixed(1)} m/s</div>
                                                        </div>
                                                    ` : ''}
                                                    ${flight.telemetry.stats.maxAltitude != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Altitude</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${(flight.telemetry.stats.maxAltitude * 3.28084).toFixed(0)} ft</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.maxAltitude.toFixed(1)} m</div>
                                                        </div>
                                                    ` : ''}
                                                    ${flight.telemetry.stats.maxHeight != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Height AGL</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${(flight.telemetry.stats.maxHeight * 3.28084).toFixed(0)} ft</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.maxHeight.toFixed(1)} m</div>
                                                        </div>
                                                    ` : ''}
                                                    ${flight.telemetry.stats.maxWindSpeed != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Max Wind</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${(flight.telemetry.stats.maxWindSpeed * 2.23694).toFixed(1)} mph</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.maxWindSpeed.toFixed(1)} m/s</div>
                                                        </div>
                                                    ` : ''}
                                                    ${flight.telemetry.stats.batteryUsed != null ? `
                                                        <div>
                                                            <div style="color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;">Battery Used</div>
                                                            <div style="font-weight: 700; color: #1e3c72; font-size: 16px;">${flight.telemetry.stats.batteryUsed.toFixed(0)}%</div>
                                                            <div style="color: #999; font-size: 11px;">${flight.telemetry.stats.startBattery?.toFixed(0)}% ‚Üí ${flight.telemetry.stats.endBattery?.toFixed(0)}%</div>
                                                        </div>
                                                    ` : ''}
                                                </div>
                                                ` : `
                                                <div style="text-align: center; padding: 20px; color: #666;">
                                                    <div class="telemetry-loading-${flight.id}" style="display: none;">
                                                        <span class="spinner"></span> Loading telemetry data...
                                                    </div>
                                                    <div class="telemetry-placeholder-${flight.id}">
                                                        Click "View Flight Path" to load telemetry stats
                                                    </div>
                                                </div>
                                                `}
                                            </div>
                                        </details>
                                    ` : ''}

                                    ${!rating ? `
                                        <div style="display: flex; gap: 10px; margin-top: 12px;">
                                            <button class="btn-small" data-action="rate" data-flight-id="${flight.id}">
                                                ‚≠ê Rate This Flight
                                            </button>
                                            ${flight.synced ? `
                                            <button class="btn-small" data-action="viewPath" data-flight-id="${flight.id}">
                                                üó∫Ô∏è View Flight Path
                                            </button>
                                            ` : ''}
                                        </div>
                                    ` : `
                                        <div style="margin-top: 12px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                                            <div style="font-size: 13px; color: #666;">
                                                <strong>Your Rating:</strong> ${rating.descAccuracy}‚≠ê Description | ${rating.shotTypeMatch}‚≠ê Shots | ${rating.accessibility}‚≠ê Access
                                            </div>
                                        </div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                    ` : `
                        <div class="empty-state">
                            <div class="empty-state-icon">‚òÅÔ∏è</div>
                            <p class="empty-state-text">No flights yet.<br>Sync your Skydio Cloud flights to see them here.</p>
                        </div>
                    `}
                `;
            }

            function renderSettings() {
                const status = state.syncSettings.connectionStatus === 'connected' ? 'üü¢ Connected' :
                              state.syncSettings.connectionStatus === 'checking' ? 'üü° Checking...' : 'üî¥ Not Connected';

                return `
                    <div class="card">
                        <div class="settings-section">
                            <div class="settings-section-title">Cloud Sync</div>
                            <div class="connection-status">
                                <div class="status-indicator ${state.syncSettings.connectionStatus}"></div>
                                <div class="status-text">
                                    <strong>${status}</strong>
                                    ${state.syncSettings.lastSync ? `<br>Last synced: ${formatDate(state.syncSettings.lastSync)}` : '<br>Never synced'}
                                </div>
                            </div>
                            <button class="btn" id="syncSettingsBtn" ${state.syncSettings.connectionStatus === 'checking' ? 'disabled' : ''}>
                                ${state.syncSettings.connectionStatus === 'checking' ? '<span class="spinner"></span> Checking...' : '‚òÅÔ∏è Sync Now'}
                            </button>
                        </div>

                        <div class="settings-section">
                            <div class="advanced-toggle" id="advancedToggle">
                                <span>‚öôÔ∏è Advanced Settings</span>
                                <span>‚ñ∂</span>
                            </div>
                            <div class="advanced-content" id="advancedContent">
                                <div class="input-group">
                                    <label>Worker URL</label>
                                    <input type="text" id="workerUrlInput" placeholder="https://..." value="${state.syncSettings.workerUrl}">
                                </div>
                                <div class="sync-info">
                                    Change only if you're self-hosting the Cloudflare Worker. Most users should leave this unchanged.
                                </div>
                                <button class="btn-secondary" id="updateWorkerBtn">Update URL</button>
                                <button class="btn-secondary" id="testConnectionBtn">Test Connection</button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <div class="settings-section-title">About</div>
                            <p style="font-size: 14px; color: #666; line-height: 1.6;">
                                DroneScout v5.4 - Real Images<br>
                                Skydio X10 Optimized<br>
                                Part 107 Certified<br>
                                With Unsplash API & Real Location Search
                            </p>
                        </div>
                    </div>
                `;
            }

            function renderAnalytics() {
                const totalFlights = state.flights.length;
                const totalDuration = state.flights.reduce((sum, f) => sum + (f.duration || 0), 0);
                const avgRating = state.ratings.length > 0
                    ? (state.ratings.reduce((sum, r) => sum + ((r.descAccuracy + r.shotTypeMatch + r.accessibility) / 3), 0) / state.ratings.length).toFixed(1)
                    : 'N/A';
                const favSpots = state.favorites.length;

                return `
                    <div class="card">
                        <h2 style="font-size: 18px; font-weight: 700; color: #1e3c72; margin-bottom: 15px;">
                            üìä Flight Statistics
                        </h2>

                        <div class="stat-grid">
                            <div class="stat-box">
                                <div class="stat-value">${totalFlights}</div>
                                <div class="stat-label">Total Flights</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${Math.round(totalDuration / 60)}m</div>
                                <div class="stat-label">Flight Time</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${avgRating}‚≠ê</div>
                                <div class="stat-label">Avg Rating</div>
                            </div>
                            <div class="stat-box">
                                <div class="stat-value">${favSpots}</div>
                                <div class="stat-label">Favorite Spots</div>
                            </div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Flight Activity
                        </h3>
                        <div class="chart-container">
                            <canvas id="flightChart"></canvas>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 700; color: #1e3c72; margin: 20px 0 12px 0;">
                            Rating Breakdown
                        </h3>
                        <div class="chart-container">
                            <canvas id="ratingChart"></canvas>
                        </div>

                        <button class="export-btn" id="exportDataBtn">üì• Export Data (CSV)</button>
                    </div>
                `;
            }

            function renderHelp() {
                return `
                    <div class="card">
                        <div class="help-section">
                            <h3>üöÅ Getting Started</h3>
                            <p>DroneScout helps you plan drone flights with the Skydio X10. Here's how to use each tab:</p>
                            <ul>
                                <li><strong>Trip Planner:</strong> Enter a destination to find scenic spots with risk assessments</li>
                                <li><strong>Upcoming:</strong> View and manage scheduled flights</li>
                                <li><strong>History:</strong> Sync completed flights from Skydio Cloud</li>
                                <li><strong>Settings:</strong> Configure cloud sync and preferences</li>
                                <li><strong>Analytics:</strong> View flight statistics and trends</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚≠ê Using the Learning System</h3>
                            <p>Rate your flights to improve recommendations:</p>
                            <ul>
                                <li>After each flight, rate description accuracy, shot quality, and accessibility</li>
                                <li>The app learns your preferences over time</li>
                                <li>Spots matching your style get higher scores</li>
                                <li>Use favorites to save best locations</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚òÅÔ∏è Cloud Sync Setup</h3>
                            <p>Connect to Skydio Cloud via Cloudflare Worker:</p>
                            <ul>
                                <li>Deploy the provided Cloudflare Worker with your Skydio API token</li>
                                <li>Enter Worker URL in Settings tab</li>
                                <li>Click "Sync Now" to import flights</li>
                                <li>Synced flights show telemetry and media</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>‚ö†Ô∏è Risk Scoring</h3>
                            <p>Each spot shows a risk score (1-100) based on:</p>
                            <ul>
                                <li><strong>Airspace:</strong> FAA restrictions and LAANC requirements</li>
                                <li><strong>Weather:</strong> Wind, visibility, and conditions</li>
                                <li><strong>Regulations:</strong> Local, state, and federal rules</li>
                                <li><strong>Hazards:</strong> Obstacles, terrain, and population density</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üéØ X10 Optimization</h3>
                            <p>Spots are optimized for Skydio X10 capabilities:</p>
                            <ul>
                                <li><strong>Nightsense:</strong> Enables twilight/blue hour flights</li>
                                <li><strong>Obstacle Avoidance:</strong> Safe navigation in complex environments</li>
                                <li><strong>BVLOS:</strong> Extended range operations (if certified)</li>
                                <li><strong>Autonomy:</strong> Advanced tracking and cinematics</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìã Regulatory Compliance</h3>
                            <p>Always follow FAA Part 107 rules:</p>
                            <ul>
                                <li>Valid Part 107 certification required</li>
                                <li>Maximum 400 ft AGL altitude</li>
                                <li>Visual line of sight (unless waiver)</li>
                                <li>LAANC authorization in controlled airspace</li>
                                <li>Check NOTAMs before every flight</li>
                                <li>Respect local ordinances and privacy</li>
                            </ul>
                        </div>

                        <div class="help-section">
                            <h3>üìû Support</h3>
                            <p>For questions or issues:</p>
                            <ul>
                                <li>GitHub: github.com/yourusername/dronescout</li>
                                <li>Email: support@dronescout.app</li>
                                <li>Documentation: docs.dronescout.app</li>
                            </ul>
                        </div>
                    </div>
                `;
            }

            // Charts initialization
            function initCharts() {
                if (typeof Chart === 'undefined') return;

                // Flight activity chart
                const flightCanvas = document.getElementById('flightChart');
                if (flightCanvas) {
                    const ctx = flightCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
                            datasets: [{
                                label: 'Flights',
                                data: [2, 3, 4, 5],
                                borderColor: '#00d4ff',
                                backgroundColor: 'rgba(0, 212, 255, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }

                // Rating breakdown chart
                const ratingCanvas = document.getElementById('ratingChart');
                if (ratingCanvas) {
                    const ctx = ratingCanvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Description', 'Shot Quality', 'Accessibility'],
                            datasets: [{
                                label: 'Average Rating',
                                data: [4.2, 4.5, 3.8],
                                backgroundColor: ['#00d4ff', '#0099cc', '#1e3c72']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 5
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                }
            }

            // Event handlers
            function attachEventListeners() {
                // Tab switching
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        state.currentTab = e.target.dataset.tab;
                        render();
                    });
                });

                // Find spots button with real location search
                const findSpotsBtn = document.getElementById('findSpotsBtn');
                if (findSpotsBtn) {
                    findSpotsBtn.addEventListener('click', async () => {
                        const input = document.getElementById('destinationInput');
                        if (input && input.value) {
                            state.destination = input.value;

                            // Show loading state
                            findSpotsBtn.disabled = true;
                            findSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';

                            try {
                                // Step 1: Geocode the location
                                const location = await geocodeLocation(state.destination);

                                if (location) {
                                    // V6: Save destination coordinates for map centering
                                    state.destinationCoords = location;

                                    // Step 2: Search for POIs near the location
                                    const pois = await searchPOIsNearLocation(location.lat, location.lng, 10, location.displayName);

                                    if (pois && pois.length > 0) {
                                        // Success: Use real POI data
                                        state.spots = pois;
                                        console.log(`Found ${pois.length} real locations near ${location.displayName}`);
                                    } else {
                                        // Fallback: No POIs found, use hardcoded spots
                                        console.log('No POIs found, using fallback spots');
                                        state.spots = scenicSpots;
                                    }
                                } else {
                                    // Fallback: Geocoding failed, use hardcoded spots
                                    console.log('Geocoding failed, using fallback spots');
                                    state.destinationCoords = null;
                                    state.spots = scenicSpots;
                                }
                            } catch (error) {
                                // Fallback: Error occurred, use hardcoded spots
                                console.error('Location search error:', error);
                                state.destinationCoords = null;
                                state.spots = scenicSpots;
                            } finally {
                                // Restore button state
                                findSpotsBtn.disabled = false;
                                findSpotsBtn.textContent = 'Find Spots';
                                render();
                            }
                        }
                    });
                }

                // Toggle favorites
                const toggleFavoritesBtn = document.getElementById('toggleFavoritesBtn');
                if (toggleFavoritesBtn) {
                    toggleFavoritesBtn.addEventListener('click', () => {
                        state.showFavoritesOnly = !state.showFavoritesOnly;
                        render();
                        // V6.1: Re-initialize map to show only filtered spots
                        if (state.spots.length > 0 && state.currentTab === 'planner') {
                            setTimeout(() => initMap(), 100);
                        }
                    });
                }

                // Toggle preferences
                const togglePreferencesBtn = document.getElementById('togglePreferences');
                if (togglePreferencesBtn) {
                    togglePreferencesBtn.addEventListener('click', () => {
                        state.showPreferences = !state.showPreferences;
                        render();
                    });
                }

                // Preference sliders
                ['cityscape', 'nature', 'architecture'].forEach(pref => {
                    const slider = document.getElementById(`${pref}Slider`);
                    if (slider) {
                        slider.addEventListener('input', (e) => {
                            state.preferences[pref] = parseInt(e.target.value);
                            saveToStorage('preferences', state.preferences);
                            render();
                        });
                    }
                });

                // Favorite star buttons
                document.querySelectorAll('.favorite-star').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const spotId = parseInt(e.currentTarget.dataset.spotId);
                        const index = state.favorites.indexOf(spotId);
                        if (index > -1) {
                            state.favorites.splice(index, 1);
                        } else {
                            state.favorites.push(spotId);
                        }
                        saveToStorage('favorites', state.favorites);
                        render();
                    });
                });

                // Spot cards
                document.querySelectorAll('.spot-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('favorite-star')) {
                            const spotId = parseInt(e.currentTarget.dataset.spotId);
                            state.selectedSpot = spotId;
                            render();
                        }
                    });
                });

                // Back button
                const backBtn = document.getElementById('backBtn');
                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        state.selectedSpot = null;
                        render();
                    });
                }

                // Save flight plan
                const savePlanBtn = document.getElementById('savePlanBtn');
                if (savePlanBtn) {
                    savePlanBtn.addEventListener('click', () => {
                        showSavePlanModal();
                    });
                }

                // Upcoming flight actions
                document.querySelectorAll('[data-action]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        const flightId = e.target.dataset.flightId;
                        const spotId = e.target.dataset.spotId;

                        if (action === 'viewspot') {
                            state.currentTab = 'planner';
                            state.selectedSpot = parseInt(spotId);
                            render();
                        } else if (action === 'markflown') {
                            markFlightAsFlown(flightId);
                        } else if (action === 'delete') {
                            deleteUpcomingFlight(flightId);
                        } else if (action === 'rate') {
                            showRatingModal(flightId);
                        } else if (action === 'viewPath') {
                            viewFlightPath(flightId);
                        }
                    });
                });

                // Sync button
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.addEventListener('click', syncFlights);
                }

                // Settings buttons
                const syncSettingsBtn = document.getElementById('syncSettingsBtn');
                if (syncSettingsBtn) {
                    syncSettingsBtn.addEventListener('click', syncFlights);
                }

                const updateWorkerBtn = document.getElementById('updateWorkerBtn');
                if (updateWorkerBtn) {
                    updateWorkerBtn.addEventListener('click', () => {
                        const newUrl = document.getElementById('workerUrlInput').value;
                        if (newUrl) {
                            state.syncSettings.workerUrl = newUrl;
                            saveToStorage('syncSettings', state.syncSettings);
                            state.syncMessage = { type: 'success', text: 'Worker URL updated' };
                            setTimeout(() => {
                                state.syncMessage = null;
                                render();
                            }, 2000);
                        }
                    });
                }

                // Advanced Settings toggle
                const advancedToggle = document.getElementById('advancedToggle');
                const advancedContent = document.getElementById('advancedContent');
                if (advancedToggle && advancedContent) {
                    advancedToggle.addEventListener('click', () => {
                        advancedToggle.classList.toggle('open');
                        advancedContent.classList.toggle('open');
                        const arrow = advancedToggle.querySelector('span:last-child');
                        if (arrow) {
                            arrow.textContent = advancedContent.classList.contains('open') ? '‚ñº' : '‚ñ∂';
                        }
                    });
                }

                // Test Connection button
                const testConnectionBtn = document.getElementById('testConnectionBtn');
                if (testConnectionBtn) {
                    testConnectionBtn.addEventListener('click', async () => {
                        await checkConnection();
                        render();
                    });
                }

                // Trip Planner mode toggle buttons
                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.dataset.mode;
                        if (mode && (mode === 'auto' || mode === 'route')) {
                            state.plannerMode = mode;
                            render();
                        }
                    });
                });

                // Route Mode search button
                const findRouteSpotsBtn = document.getElementById('findRouteSpotsBtn');
                if (findRouteSpotsBtn) {
                    findRouteSpotsBtn.addEventListener('click', async () => {
                        const startInput = document.getElementById('routeStartInput');
                        const endInput = document.getElementById('routeEndInput');
                        if (startInput && endInput && startInput.value && endInput.value) {
                            state.routeStart = startInput.value;
                            state.routeEnd = endInput.value;

                            // V6.1: Geocode start and end locations for route polyline
                            findRouteSpotsBtn.disabled = true;
                            findRouteSpotsBtn.innerHTML = '<span class="spinner"></span> Searching...';

                            try {
                                const startLocation = await geocodeLocation(state.routeStart);
                                const endLocation = await geocodeLocation(state.routeEnd);

                                if (startLocation && endLocation) {
                                    state.routeStartCoords = startLocation;
                                    state.routeEndCoords = endLocation;

                                    // Search for POIs along the route (use midpoint for now)
                                    const midLat = (startLocation.lat + endLocation.lat) / 2;
                                    const midLng = (startLocation.lng + endLocation.lng) / 2;
                                    const pois = await searchPOIsNearLocation(midLat, midLng, 20, `${state.routeStart} to ${state.routeEnd}`);

                                    state.spots = pois && pois.length > 0 ? pois : scenicSpots;
                                } else {
                                    state.routeStartCoords = null;
                                    state.routeEndCoords = null;
                                    state.spots = scenicSpots;
                                }
                            } catch (error) {
                                console.error('Route geocoding error:', error);
                                state.routeStartCoords = null;
                                state.routeEndCoords = null;
                                state.spots = scenicSpots;
                            } finally {
                                findRouteSpotsBtn.disabled = false;
                                findRouteSpotsBtn.textContent = 'Find Spots Along Route';
                                render();
                            }
                        }
                    });
                }

                // Export data
                const exportDataBtn = document.getElementById('exportDataBtn');
                if (exportDataBtn) {
                    exportDataBtn.addEventListener('click', exportData);
                }
            }

            // Helper functions
            function showSavePlanModal() {
                const spot = state.spots.find(s => s.id === state.selectedSpot);
                if (!spot) return;

                const modal = document.getElementById('savePlanModal');
                const content = document.getElementById('savePlanContent');

                content.innerHTML = `
                    <div class="input-group">
                        <label>Flight Date & Time</label>
                        <input type="datetime-local" id="planDateTime">
                    </div>
                    <div class="input-group">
                        <label>Notes (optional)</label>
                        <textarea id="planNotes" rows="3" placeholder="Flight plan notes..."></textarea>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="confirmSavePlan">Save Plan</button>
                        <button class="btn btn-secondary" id="cancelSavePlan">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                document.getElementById('confirmSavePlan').addEventListener('click', () => {
                    const dateTime = document.getElementById('planDateTime').value;
                    const notes = document.getElementById('planNotes').value;

                    if (dateTime) {
                        state.upcomingFlights.push({
                            id: Date.now(),
                            spotId: spot.id,
                            spotName: spot.name,
                            spotData: spot,
                            dateTime,
                            notes
                        });
                        saveToStorage('upcomingFlights', state.upcomingFlights);
                        modal.classList.remove('active');
                        alert('Flight plan saved!');
                    } else {
                        alert('Please select a date and time');
                    }
                });

                document.getElementById('cancelSavePlan').addEventListener('click', () => {
                    modal.classList.remove('active');
                });
            }

            function markFlightAsFlown(flightId) {
                const flightIndex = state.upcomingFlights.findIndex(f => f.id == flightId);
                if (flightIndex === -1) return;

                const flight = state.upcomingFlights[flightIndex];

                state.flights.unshift({
                    id: Date.now(),
                    type: 'manual',
                    name: flight.spotName,
                    location: flight.spotName,
                    date: new Date(flight.dateTime).toISOString(),
                    duration: 0,
                    notes: flight.notes,
                    spotData: flight.spotData
                });

                state.upcomingFlights.splice(flightIndex, 1);

                saveToStorage('upcomingFlights', state.upcomingFlights);
                saveToStorage('flights', state.flights);

                showRatingModal(state.flights[0].id);
            }

            function deleteUpcomingFlight(flightId) {
                if (confirm('Delete this flight plan?')) {
                    state.upcomingFlights = state.upcomingFlights.filter(f => f.id != flightId);
                    saveToStorage('upcomingFlights', state.upcomingFlights);
                    render();
                }
            }

            function showRatingModal(flightId) {
                const flight = state.flights.find(f => f.id == flightId);
                if (!flight) return;

                const modal = document.getElementById('ratingModal');
                const content = document.getElementById('ratingContent');

                state.currentRating = {
                    flightId: flight.id,
                    descAccuracy: 0,
                    shotTypeMatch: 0,
                    accessibility: 0,
                    wouldFlyAgain: null,
                    notes: ''
                };

                content.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <strong>Location:</strong> ${flight.name || flight.location}
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Description Accuracy</label>
                        <div class="star-rating" id="descAccuracy">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Shot Type Match</label>
                        <div class="star-rating" id="shotTypeMatch">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px;">Accessibility</label>
                        <div class="star-rating" id="accessibility">
                            ${[1,2,3,4,5].map(i => `<span class="star" data-rating="${i}">‚òÖ</span>`).join('')}
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Additional Notes (optional)</label>
                        <textarea id="ratingNotes" rows="3" placeholder="Any additional feedback..."></textarea>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="submitRating">Submit Rating</button>
                        <button class="btn btn-secondary" id="cancelRating">Cancel</button>
                    </div>
                `;

                modal.classList.add('active');

                // Star rating handlers
                document.querySelectorAll('.star-rating').forEach(group => {
                    const stars = group.querySelectorAll('.star');
                    stars.forEach(star => {
                        star.addEventListener('click', (e) => {
                            const rating = parseInt(e.target.dataset.rating);
                            const category = group.id;
                            state.currentRating[category] = rating;

                            stars.forEach((s, i) => {
                                s.classList.toggle('active', i < rating);
                            });
                        });
                    });
                });

                // Submit rating
                document.getElementById('submitRating').addEventListener('click', () => {
                    const notes = document.getElementById('ratingNotes').value;

                    if (state.currentRating.descAccuracy > 0 &&
                        state.currentRating.shotTypeMatch > 0 &&
                        state.currentRating.accessibility > 0) {

                        state.currentRating.notes = notes;
                        state.ratings.push({...state.currentRating});
                        saveToStorage('ratings', state.ratings);

                        modal.classList.remove('active');
                        state.currentRating = null;
                        render();
                    } else {
                        alert('Please complete all ratings');
                    }
                });

                document.getElementById('cancelRating').addEventListener('click', () => {
                    modal.classList.remove('active');
                    state.currentRating = null;
                });
            }

            // V6.1: Export flights data as CSV format
            function exportData() {
                let csv = 'Date,Location,Duration,Type,Notes\n';
                state.flights.forEach(flight => {
                    csv += `${formatDate(flight.date)},"${flight.name || flight.location}",${flight.duration || 0},${flight.type || 'manual'},"${flight.notes || ''}"\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'dronescout-flights.csv';
                a.click();
            }

            // Initial render
            checkConnection();
            getUserLocation(); // V6: Request user's location for map
            render();
        }
    </script>
</body>
</html>
